"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[8009],{3080:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>p,data:()=>r});var e=a(9034);const l=[(0,e.Fv)('<h1 id="worker-threads" tabindex="-1"><a class="header-anchor" href="#worker-threads"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#worker-threads" target="_blank" rel="noopener noreferrer">Worker threads</a></span></a></h1><p>理解 Node.js 中的 Worker Threads（工作线程）对于提升你的编程技能是非常重要的，特别是当涉及到在单个 Node.js 进程中执行多任务并行处理时。我将尽量用简单易懂的语言给你解释这个概念，并通过一些实际的例子来帮助你更好地理解。</p><h3 id="什么是-worker-threads" tabindex="-1"><a class="header-anchor" href="#什么是-worker-threads"><span>什么是 Worker Threads？</span></a></h3><p>首先，让我们了解 Node.js 的基础。Node.js 是单线程的，这意味着默认情况下，所有你的代码都在一个主线程上顺序执行。对于 IO 密集型的操作（如读写文件、网络请求等），这种模型效率很高，因为它们是异步非阻塞的，可以在等待 IO 操作完成时执行其他脚本代码。但对于 CPU 密集型的任务（如大量计算），这可能会导致应用性能下降，因为这些计算会阻塞主线程，直到完成为止。</p><p>这就是 Worker Threads 发挥作用的地方。Worker Threads 允许你创建额外的线程，运行 JavaScript 和 Node.js 的 API，而不必阻塞主线程。这意味着你可以在后台线程中执行计算或其他任务，而主线程继续响应用户请求或其他 I/O 操作。</p><h3 id="实际运用示例" tabindex="-1"><a class="header-anchor" href="#实际运用示例"><span>实际运用示例</span></a></h3><h4 id="示例-1-进行复杂计算" tabindex="-1"><a class="header-anchor" href="#示例-1-进行复杂计算"><span>示例 1：进行复杂计算</span></a></h4><p>假设你正在开发一个 Web 应用，需要在服务器端进行大量的数据分析或图像处理。这些操作通常很耗时，并且如果放在主线程上执行，它会阻塞其他请求的处理。</p><p>使用 Worker Threads，你可以创建一个后台线程来处理这些计算密集型的任务，而主线程可以继续处理新的用户请求，从而提高整体应用性能。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在主线程执行</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从 Worker 收到: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello, Worker!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在 Worker 线程执行</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从主线程收到: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello, main thread!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="示例-2-并行处理" tabindex="-1"><a class="header-anchor" href="#示例-2-并行处理"><span>示例 2：并行处理</span></a></h4><p>如果你有一组任务需要执行，比如在一个视频分享网站上转码上传的视频，这些任务彼此独立，可以并行执行以缩短总完成时间。</p><p>使用 Worker Threads，你可以为每个转码任务创建一个单独的线程。这样，多个视频可以同时转码，而不是按顺序一个接一个地进行，极大提高了效率。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> runService</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">workerData</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#81A1C1;"> new</span><span style="color:#8FBCBB;"> Promise</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">resolve</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./videoTranscoder.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> resolve</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">      if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;"> !==</span><span style="color:#B48EAD;"> 0</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#88C0D0;">        reject</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker stopped with exit code </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">async</span><span style="color:#81A1C1;"> function</span><span style="color:#88C0D0;"> main</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> results</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> await</span><span style="color:#8FBCBB;"> Promise</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">all</span><span style="color:#D8DEE9FF;">([</span></span>\n<span class="line"><span style="color:#88C0D0;">    runService</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">video1.mp4</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#88C0D0;">    runService</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">video2.mp4</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#88C0D0;">    runService</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">video3.mp4</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">  ])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">results</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">main</span><span style="color:#D8DEE9FF;">()</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">catch</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">err</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">err</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h3><p>Worker Threads 提供了一种强大的方式来提升 Node.js 应用的性能，特别是对于计算密集型的任务。通过在后台线程中执行这些任务，你可以确保主线程保持响应，从而提供更流畅的用户体验。希望这些例子能帮助你理解 Worker Threads 的概念和如何在你的应用中利用它们。</p><h2 id="worker-getenvironmentdata-key" tabindex="-1"><a class="header-anchor" href="#worker-getenvironmentdata-key"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workergetenvironmentdatakey" target="_blank" rel="noopener noreferrer">worker.getEnvironmentData(key)</a></span></a></h2><p>理解<code>worker.getEnvironmentData(key)</code>之前，我们需要先明白 Node.js 中的“Worker Threads（工作线程）”概念。Node.js 是单线程的，这意味着默认情况下，所有代码都在一个线程上运行。但有时，为了更好地利用多核 CPU 或处理耗时任务而不阻塞主线程，我们会使用工作线程来在后台执行代码。</p><p>在 Node.js 的工作线程模块中，<code>worker.getEnvironmentData(key)</code>允许你从工作线程的环境数据存储中获取之前存储的值。这个功能非常适合于在主线程和工作线程之间共享一些数据，而无需显式地通过消息传递来实现。</p><h3 id="实际运用" tabindex="-1"><a class="header-anchor" href="#实际运用"><span>实际运用</span></a></h3><p>假设你正在开发一个 Web 服务器，需要对大量图片进行压缩。这是一个 CPU 密集型任务，如果在主线程上进行，可能会导致服务器响应变慢。为此，你可以创建一个工作线程专门用于图像压缩，而主线程继续处理其他 Web 请求。</p><h4 id="步骤-1-在主线程中创建工作线程并传递环境数据" tabindex="-1"><a class="header-anchor" href="#步骤-1-在主线程中创建工作线程并传递环境数据"><span>步骤 1：在主线程中创建工作线程并传递环境数据</span></a></h4><p>首先，在主线程中，你可以设置工作线程需要的一些环境数据，比如图片压缩的质量设置。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建工作线程时，通过workerData传递数据</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {</span><span style="color:#88C0D0;"> quality</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 75</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./path/to/workerScript.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-在工作线程中读取环境数据" tabindex="-1"><a class="header-anchor" href="#步骤-2-在工作线程中读取环境数据"><span>步骤 2：在工作线程中读取环境数据</span></a></h4><p>然后，在工作线程脚本中，你可以使用<code>worker.getEnvironmentData(key)</code>获取主线程传递过来的数据。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用worker.getEnvironmentData(key)获取环境数据</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> quality</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">getEnvironmentData</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">quality</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 假设这里有一个函数compressImage用于压缩图片</span></span>\n<span class="line"><span style="color:#88C0D0;">compressImage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">quality</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">then</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">compressedImage</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 压缩完成后，将结果发送回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">compressedImage</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>使用<code>worker.getEnvironmentData(key)</code>可以非常方便地在主线程和工作线程之间共享配置信息或其它数据。这种方式避免了复杂的消息传递逻辑，使得代码更简洁、易于理解。它特别适用于那些需要工作线程根据不同的配置执行不同任务的场景。</p><h2 id="worker-ismainthread" tabindex="-1"><a class="header-anchor" href="#worker-ismainthread"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerismainthread" target="_blank" rel="noopener noreferrer">worker.isMainThread</a></span></a></h2><p>当我们在 Node.js 中谈论<code>worker.isMainThread</code>，我们其实在讨论的是多线程。在 Node.js 的世界里，通常情况下代码是按顺序、一步接一步运行的，这种模式被称为单线程。但有时，你可能需要同步执行多个任务，比如同时从多个源获取数据，或者进行大量的计算，这时候就需要用到多线程。</p><p>Node.js 通过一个名为<code>worker_threads</code>的模块提供了多线程的功能。在这个模块中，可以创建新的线程来并行处理任务。每个这样的线程都可以看作是独立的工作者（Worker），与主程序并行运行。</p><h3 id="worker-ismainthread-1" tabindex="-1"><a class="header-anchor" href="#worker-ismainthread-1"><span><code>worker.isMainThread</code></span></a></h3><p>在使用<code>worker_threads</code>模块时，你可能想知道当前的代码是在主线程中运行还是在一个工作线程中。这就是<code>worker.isMainThread</code>属性的用处。</p><ul><li>如果<code>worker.isMainThread</code>为<code>true</code>，意味着你的代码正在主线程中执行。</li><li>如果它为<code>false</code>，则表示代码正在一个工作线程中执行。</li></ul><h3 id="实际应用示例" tabindex="-1"><a class="header-anchor" href="#实际应用示例"><span>实际应用示例</span></a></h3><h4 id="示例-1-基本检查" tabindex="-1"><a class="header-anchor" href="#示例-1-基本检查"><span>示例 1: 基本检查</span></a></h4><p>假设你正在编写一个脚本，该脚本既可以作为主程序运行，也可以作为工作线程运行。你可能会这样使用<code>worker.isMainThread</code>：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">这段代码在主线程中执行</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">这段代码在工作线程中执行</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="示例-2-创建一个简单的工作线程" tabindex="-1"><a class="header-anchor" href="#示例-2-创建一个简单的工作线程"><span>示例 2: 创建一个简单的工作线程</span></a></h4><p>让我们来看一个更具体的例子，如何创建一个工作线程来异步执行任务：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程开始运行</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 创建一个工作线程来运行当前文件</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 监听来自工作线程的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">来自工作线程的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程问候</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 向工作线程发送消息</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">收到来自主线程的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">工作线程的回应</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个工作线程，并与之通信。首先，主线程向工作线程发送了一个消息，并设置了一个监听器来接收来自工作线程的响应。当工作线程接收到消息后，也发送了一个消息回到主线程。</p><p>通过这样的方式，<code>worker.isMainThread</code>使得同一个文件能够根据其执行的上下文（主线程或工作线程）采取不同的行动，非常适合于写复用度高和需要执行并行任务的应用程序。</p><h2 id="worker-markasuntransferable-object" tabindex="-1"><a class="header-anchor" href="#worker-markasuntransferable-object"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workermarkasuntransferableobject" target="_blank" rel="noopener noreferrer">worker.markAsUntransferable(object)</a></span></a></h2><p>当我们在使用 Node.js 的<code>worker_threads</code>模块来创建多线程应用时，经常会涉及到在主线程和工作线程之间传递数据。理解<code>worker.markAsUntransferable(object)</code>功能将有助于你更高效地管理这些数据的传输。</p><h3 id="什么是-worker-markasuntransferable-object" tabindex="-1"><a class="header-anchor" href="#什么是-worker-markasuntransferable-object"><span>什么是 <code>worker.markAsUntransferable(object)</code>？</span></a></h3><p>在 Node.js 的<code>worker_threads</code>模块中，<code>worker.markAsUntransferable(object)</code>是一个方法，它允许你标记一个对象为“不可转移”。这意味着一旦你将某个对象标记为不可转移，该对象就不能通过<code>postMessage</code>方法从一个工作线程传递给另一个工作线程或主线程，并且在尝试传递该对象时，它会被复制而不是转移。</p><h3 id="为什么要使用-worker-markasuntransferable-object" tabindex="-1"><a class="header-anchor" href="#为什么要使用-worker-markasuntransferable-object"><span>为什么要使用 <code>worker.markAsUntransferable(object)</code>？</span></a></h3><p>通常，当我们通过<code>postMessage</code>方法在线程之间传递数据时，如果传递的是<code>ArrayBuffer</code>或者<code>MessagePort</code>等可转移对象，Node.js 会尝试“转移”这个对象的所有权而非复制它。这意味着一旦转移发生，源线程将无法再访问该对象，而是直接将对象的控制权交给目标线程，这样做可以显著提高性能，因为不需要进行深拷贝。</p><p>然而，在某些情况下，你可能不希望对象被转移。比如：</p><ul><li>当你需要在源线程中保留对该对象的访问权限时。</li><li>当对象被多个线程共享，且不想改变其所有权时。</li></ul><p>这时，<code>worker.markAsUntransferable(object)</code>就派上了用场。</p><h3 id="实际例子" tabindex="-1"><a class="header-anchor" href="#实际例子"><span>实际例子</span></a></h3><p>假设你正在开发一个简单的图像处理应用，其中利用工作线程来处理图像数据，但同时你希望在主线程中保留对原始图像数据的完整访问权限，以便同时执行其他操作（例如，显示原图）。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 创建一个工作线程执行当前文件</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> imageBuffer</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> ArrayBuffer</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">1024</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 假设这是要处理的图像数据</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">imageBuffer</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">imageBuffer</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 尝试转移图像数据至工作线程</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 我们希望保留对imageBuffer的访问，所以标记它为不可转移</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">markAsUntransferable</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">imageBuffer</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 即使尝试转移，imageBuffer也不会失去其在主线程的引用</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">imageBuffer</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 依然可以访问</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">imageBuffer</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">    // 在这里处理接收到的图像数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">图像数据已接收，但未被转移</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们尝试在主线程和工作线程之间传递一个图像数据（模拟为<code>ArrayBuffer</code>）。在发送之前，我们通过调用<code>worker.markAsUntransferable(imageBuffer)</code>确保即使我们尝试将<code>imageBuffer</code>作为转移对象发送，它也不会失去在主线程中的引用。这样，我们就可以在工作线程处理图像的同时，在主线程中保持对原始图像数据的访问权限，实现了数据的高效管理和并行处理。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p><code>worker.markAsUntransferable(object)</code>是 Node.js 中用于管理线程间数据传递行为的重要方法。通过防止对象转移，它允许开发者灵活地设计多线程应用架构，确保数据安全且高效地在各线程间流动。</p><h2 id="worker-ismarkedasuntransferable-object" tabindex="-1"><a class="header-anchor" href="#worker-ismarkedasuntransferable-object"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerismarkedasuntransferableobject" target="_blank" rel="noopener noreferrer">worker.isMarkedAsUntransferable(object)</a></span></a></h2><p>理解 <code>worker.isMarkedAsUntransferable(object)</code> 这个 API，我们首先需要了解 Node.js 的 Worker Threads 模块以及 &quot;transferable objects&quot; 这个概念。</p><p><strong>Worker Threads</strong>:<br> Node.js 允许通过 Worker Threads（工作线程）来实现多线程编程，这对于执行耗时的操作非常有用，因为它们可以并行处理，从而不会阻塞主线程。</p><p><strong>Transferable Objects</strong>:<br> 在多线程编程中，通常需要在不同的线程之间传递数据。一些对象，比如 ArrayBuffer，可以被标记为 &quot;transferable&quot;（可转移的）。当你将一个可转移的对象从一个线程传递给另一个线程时，它实际上是将所有权从一个线程转移到另一个线程，而不是复制数据。这样做的好处是效率更高，因为不需要复制大量数据。</p><p>现在，谈到 <code>worker.isMarkedAsUntransferable(object)</code>：</p><p>这个方法用于检查一个对象是否被标记为 &quot;untransferable&quot;（不可转移的）。也就是说，该方法检查你是否可以安全地将某个对象作为可转移的数据从一个线程传递到另一个线程。如果对象被标记为不可转移，那么尝试将其传递将不会改变原始线程中对象的状态，但在目标线程中，你将无法按预期使用该对象。</p><h3 id="实际应用例子" tabindex="-1"><a class="header-anchor" href="#实际应用例子"><span>实际应用例子</span></a></h3><p>假设你有一个应用程序，需要处理大量数据进行复杂计算，例如图像处理或大型数据集分析。为了优化性能，你决定使用 Worker Threads 来并行处理任务。</p><ol><li><p><strong>创建共享数据</strong>:<br> 首先，你创建了一个 ArrayBuffer —— 这是一种可以存储二进制数据的结构，适合在不同线程间共享。</p></li><li><p><strong>检查可转移性</strong>:<br> 在将 ArrayBuffer 传递给 worker 线程之前，你可能想确认它没有被错误地标记为不可转移。这是因为，如果 ArrayBuffer 被标记为不可转移，那么它就不能以最高效的方式传递给 worker 线程。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">isMarkedAsUntransferable</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">myArrayBuffer</span><span style="color:#D8DEE9FF;">)) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">This buffer cannot be transferred</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">myArrayBuffer</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">myArrayBuffer</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段首先检查 <code>myArrayBuffer</code> 是否被标记为不可转输。如果没有，它会通过 <code>postMessage</code> 方法将 <code>myArrayBuffer</code> 发送给一个 worker 线程，并且由于其可转移性，该操作几乎不消耗时间和内存。</p></li><li><p><strong>在 Worker 线程中使用数据</strong>:<br> Worker 线程接收到 ArrayBuffer 后，可以立即开始进行数据处理，比如进行图像处理或分析数据集等操作。完成后，结果可以发送回主线线程，或者根据需求再次传递给其他 Worker 线程。</p></li></ol><p>通过上述例子，你可以看到 <code>worker.isMarkedAsUntransferable(object)</code> 在确保对象可以以最高效的方式在主线程和 Worker 线程之间传递时的重要性。此方法有助于避免在不必要时复制数据，从而提高应用程序的效率和性能。</p><h2 id="worker-movemessageporttocontext-port-contextifiedsandbox" tabindex="-1"><a class="header-anchor" href="#worker-movemessageporttocontext-port-contextifiedsandbox"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workermovemessageporttocontextport-contextifiedsandbox" target="_blank" rel="noopener noreferrer">worker.moveMessagePortToContext(port, contextifiedSandbox)</a></span></a></h2><p>好的，让我们一起深入了解 <code>worker.moveMessagePortToContext(port, contextifiedSandbox)</code> 这个方法在 Node.js 中的用途和应用方式。</p><p>首先，要理解这个方法，我们需要弄清楚几个关键概念：<code>Worker threads</code>, <code>MessagePort</code>, 和 <code>contextifiedSandbox</code>。</p><ol><li><p><strong>Worker Threads</strong>:<br> 在 Node.js 中，通常情况下，代码是单线程运行的，这意味着一次只能执行一个任务。但是，有些任务是计算密集型的，如果放在主线程上执行，会阻塞其他任务。为了解决这个问题，Node.js 提供了 Worker 线程（通过 <code>worker_threads</code> 模块），允许你创建多个线程来并行处理任务。</p></li><li><p><strong>MessagePort</strong>:<br> 当你使用 Worker 线程时，主线程和 Worker 线程之间需要一种通信机制。这就是 <code>MessagePort</code> 的用武之地。它允许两个不同的线程互发消息。</p></li><li><p><strong>Contextified Sandbox</strong>:<br> JavaScript 代码通常在一个全局上下文中运行。但是，在某些情况下，你可能想要在隔离的环境中运行代码，这样的环境被称为 &quot;sandbox&quot;。通过创建一个 sandbox，你可以控制代码执行的环境，并且限制它所能访问的资源。在 Node.js 中，你可以通过 <code>vm</code> 模块创建一个“contextified” sandbox，即将普通的 JavaScript 对象转变成一个脚本可以在其中运行的上下文。</p></li></ol><p>现在，让我们看看 <code>worker.moveMessagePortToContext(port, contextifiedSandbox)</code> 是如何工作的：</p><p>这个方法允许你将一个 <code>MessagePort</code> 对象移动到一个新的上下文 (<code>contextifiedSandbox</code>) 中。简而言之，这使得你可以在一个隔离的环境中进行线程间的通信。</p><h3 id="实际应用示例-1" tabindex="-1"><a class="header-anchor" href="#实际应用示例-1"><span>实际应用示例</span></a></h3><p>假设你正在开发一个 Node.js 应用，其中包含一个非常消耗 CPU 资源的任务，比如图像处理或复杂计算。你不希望这个任务阻塞主线程，因此决定使用 Worker 线程来处理它。</p><p>但同时，你还想确保这个任务运行在一个安全的环境中，以免它访问或修改全局状态或敏感信息。为此，你可以使用 <code>worker.moveMessagePortToContext(port, contextifiedSandbox)</code> 方法。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  Worker</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  isMainThread</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  workerData</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> createContext</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> runInContext</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">vm</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> sandbox</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {</span><span style="color:#88C0D0;"> port</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> context</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> createContext</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">sandbox</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">port</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    sandbox</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> port</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">moveMessagePortToContext</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">port</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> context</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">start</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">    // 现在，port 已经被移动到了 sandbox 上下文中。</span></span>\n<span class="line"><span style="color:#616E88;">    // 可以安全地在 sandbox 内与 worker 线程通信了。</span></span>\n<span class="line"><span style="color:#D8DEE9;">    port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from the main thread!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> port1</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> port2</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MessageChannel</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">port1</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">port1</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  port2</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">msg</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 接收来自主线程的消息</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 响应主线程的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  port2</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from worker thread!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中：</p><ul><li>主线程创建了一个 Worker 线程来执行耗时的任务，同时创建了一个 sandbox 来隔离 Worker 线程。</li><li>使用 <code>MessageChannel</code> 创建了一对 <code>MessagePort</code> 对象，并通过 <code>worker.moveMessagePortToContext</code> 把其中一个端口移动到了 sandbox 上下文中。</li><li>如此一来，主线程与 Worker 线程之间的通信就被限制在了这个 sandbox 环境内，增强了应用的安全性。</li></ul><p>希望这个解释和示例对你有所帮助！</p><h2 id="worker-parentport" tabindex="-1"><a class="header-anchor" href="#worker-parentport"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerparentport" target="_blank" rel="noopener noreferrer">worker.parentPort</a></span></a></h2><p>好的，让我们深入了解 Node.js 中的 <code>worker.parentPort</code>，特别是在 v21.7.1 的上下文中。首先，要理解 <code>worker.parentPort</code>，我们需要先简要介绍 Node.js 中的 Worker 线程（Worker Threads）。</p><h3 id="什么是-worker-线程" tabindex="-1"><a class="header-anchor" href="#什么是-worker-线程"><span>什么是 Worker 线程？</span></a></h3><p>在 Node.js 中，Worker 线程允许您运行 JavaScript 操作在与主线程分离的并行线程中。这对于执行计算密集型任务特别有用，因为它们不会阻塞事件循环，从而保持应用程序的响应性。</p><h3 id="worker-parentport-是什么" tabindex="-1"><a class="header-anchor" href="#worker-parentport-是什么"><span><code>worker.parentPort</code> 是什么？</span></a></h3><p><code>worker.parentPort</code> 是一个对象，它提供了一种在 Worker 线程和其创建它的主线程之间进行通信的途径。通过这个端口，Worker 可以发送消息回到创建它的主线程。本质上，<code>parentPort</code> 允许双向通信：主线程可以通过 Worker 实例向 Worker 发送消息，而 Worker 则可以通过 <code>parentPort</code> 向主线程发送消息。</p><h3 id="如何使用-worker-parentport" tabindex="-1"><a class="header-anchor" href="#如何使用-worker-parentport"><span>如何使用 <code>worker.parentPort</code>？</span></a></h3><p>让我们通过一些实际的例子来看看如何使用 <code>worker.parentPort</code>：</p><h4 id="示例-1-在-worker-线程中发送消息" tabindex="-1"><a class="header-anchor" href="#示例-1-在-worker-线程中发送消息"><span>示例 1：在 Worker 线程中发送消息</span></a></h4><p>假设您有一个进行重计算任务的 Worker 线程，并且一旦完成，您希望将结果发送回主线程。</p><p><strong>Worker.js</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 执行一些计算</span></span>\n<span class="line"><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> performHeavyComputation</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用 parentPort 发送计算结果回到主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> performHeavyComputation</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设这里有复杂的计算</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">计算结果</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>main.js</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建 Worker 线程并指向我们的脚本</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./Worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听来自 Worker 线程的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从 Worker 接收到的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们在 Worker 线程里计算了一些东西，然后使用 <code>parentPort.postMessage()</code> 将结果发送回主线程。主线程通过监听 <code>message</code> 事件接收到这个消息。</p><h4 id="示例-2-主线程和-worker-线程的双向通信" tabindex="-1"><a class="header-anchor" href="#示例-2-主线程和-worker-线程的双向通信"><span>示例 2：主线程和 Worker 线程的双向通信</span></a></h4><p>您还可以从主线程向 Worker 线程发送消息，并且 Worker 线程也可以回应。</p><p><strong>main.js</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./Worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从 Worker 接收到的信息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 发送消息到 Worker 线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello, Worker!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Worker.js</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从主线程收到的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 回应消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hi, main thread!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程和 Worker 线程通过 <code>postMessage</code> 和 <code>on(&#39;message&#39;, callback)</code> 互相通信。</p><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><p>使用 Node.js 的 <code>worker.parentPort</code>，您可以轻松地在 Worker 线程和主线程之间进行双向通信，这对于在后台执行任务而不阻塞主事件循环特别有用。通过这种方式，您可以提高 Node.js 应用程序的性能和响应性。</p><h2 id="worker-receivemessageonport-port" tabindex="-1"><a class="header-anchor" href="#worker-receivemessageonport-port"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerreceivemessageonportport" target="_blank" rel="noopener noreferrer">worker.receiveMessageOnPort(port)</a></span></a></h2><p>了解 <code>worker.receiveMessageOnPort(port)</code> 方法之前，我们需要先简要介绍一下 Node.js 中的 <code>worker_threads</code> 模块和多线程概念。</p><h3 id="多线程与-worker-threads-模块" tabindex="-1"><a class="header-anchor" href="#多线程与-worker-threads-模块"><span>多线程与 <code>worker_threads</code> 模块</span></a></h3><p>Node.js 是基于事件循环机制执行代码，传统上被认为是单线程的。然而，对于 CPU 密集型任务，这种模型可能不是最高效的。为了充分利用多核 CPU 的能力，Node.js 引入了 <code>worker_threads</code> 模块，允许你运行多个 JavaScript 工作线程。这意味着你可以在后台并行处理任务，而不会阻塞主事件循环。</p><h3 id="worker-receivemessageonport-port-1" tabindex="-1"><a class="header-anchor" href="#worker-receivemessageonport-port-1"><span><code>worker.receiveMessageOnPort(port)</code></span></a></h3><p><code>worker.receiveMessageOnPort(port)</code> 是 <code>worker_threads</code> 模块中的一个方法，它允许你从指定的 MessagePort 接收消息。这里的 <code>port</code> 参数就是一个 MessagePort 实例，通过它可以进行线程间的通信。</p><p>每当使用 <code>postMessage(value)</code> 方法向 <code>port</code> 发送消息时，<code>value</code> 就会被排队准备接收。当你调用 <code>worker.receiveMessageOnPort(port)</code> 时，它会同步返回队列中的下一个消息，如果队列为空，则返回 <code>undefined</code>。</p><h3 id="实际运用示例-1" tabindex="-1"><a class="header-anchor" href="#实际运用示例-1"><span>实际运用示例</span></a></h3><p>假设我们有一个场景，需要在后台线程执行复杂计算，比如图像处理或者大数据分析，同时不想阻塞主线程。我们可以创建一个工作线程来处理复杂计算，并通过 MessagePort 进行主线程和工作线程之间的通信。</p><p><strong>步骤 1</strong>: 首先，在主线程中创建工作线程并初始化通信端口。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> MessageChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个新的 MessageChannel，它包含两个互联的端口</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> port1</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> port2</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MessageChannel</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建工作线程，将其中一个端口通过 workerData 传递给它</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">  workerData</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> {</span><span style="color:#88C0D0;"> port</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> port2</span><span style="color:#ECEFF4;"> },</span></span>\n<span class="line"><span style="color:#88C0D0;">  transferList</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">port2</span><span style="color:#D8DEE9FF;">]</span><span style="color:#ECEFF4;">,</span><span style="color:#616E88;"> // 这确保了port2 被转移到工作线程，而不是在主线程中克隆</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听从工作线程发送回来的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">port1</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">从工作线程收到:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 发送消息给工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">port1</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> task</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">do some heavy calculations</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>步骤 2</strong>: 在 <code>worker.js</code>（工作线程脚本）中处理接收的消息，并发送回复。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 从 workerData 获取通信端口</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> port</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 当主线程发送消息时处理</span></span>\n<span class="line"><span style="color:#D8DEE9;">port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">从主线程收到:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 执行一些操作...比如一个耗时的任务</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 完成后，向主线程发送消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> result</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">计算完成</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个简单的例子展示了如何使用 <code>worker_threads</code> 模块和 <code>worker.receiveMessageOnPort(port)</code> 方法（尽管在这个特定的例子中，我们直接使用 <code>port.on(&#39;message&#39;, callback)</code> 来接收消息，这也是另一种常见的模式）来实现主线程和工作线程之间的非阻塞通信。这使得 Node.js 应用能够更有效地利用系统资源，提高性能。</p><h2 id="worker-resourcelimits" tabindex="-1"><a class="header-anchor" href="#worker-resourcelimits"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerresourcelimits" target="_blank" rel="noopener noreferrer">worker.resourceLimits</a></span></a></h2><p>在 Node.js 中，<code>worker.resourceLimits</code>是一个与工作线程（Worker Threads）功能相关的概念。为了更好地理解这个概念，首先我们需要简单了解一下工作线程以及为什么对它们设置资源限制很重要。</p><h3 id="工作线程-worker-threads" tabindex="-1"><a class="header-anchor" href="#工作线程-worker-threads"><span>工作线程（Worker Threads）</span></a></h3><p>在 Node.js 中，你的代码默认运行在一个主线程中。这意味着如果你执行一个非常耗时的任务，比如大量计算或者处理大量的数据，这将阻塞（即暂停）其他代码的执行，直到该任务完成。为了避免这种情况，Node.js 引入了工作线程。简而言之，工作线程让你可以创建额外的线程来并行执行代码，这样就可以在一个线程中执行耗时任务而不会影响到其他线程。</p><h3 id="为什么需要资源限制" tabindex="-1"><a class="header-anchor" href="#为什么需要资源限制"><span>为什么需要资源限制</span></a></h3><p>虽然工作线程极大地增强了 Node.js 的能力，使其可以执行多任务并行处理，但也带来了新的挑战：资源管理。每个工作线程都会使用系统资源，比如内存。如果不加以限制，一个工作线程可能会使用过多的资源，从而影响到整个系统的性能，甚至导致系统崩溃。</p><p>这就是<code>worker.resourceLimits</code>发挥作用的地方。</p><h3 id="worker-resourcelimits-1" tabindex="-1"><a class="header-anchor" href="#worker-resourcelimits-1"><span><code>worker.resourceLimits</code></span></a></h3><p><code>worker.resourceLimits</code>是一个选项对象(option object)，当你创建一个新的工作线程时可以提供它。通过这个对象，你可以指定该工作线程所能使用的最大资源量，例如最大的内存使用量。Node.js v21.7.1 中支持的资源限制包括：</p><ul><li><strong>maxYoungGenerationSizeMb</strong>：用于控制年轻代（young generation，一种用于垃圾回收的内存空间）的最大大小（以 MB 为单位）。</li><li><strong>maxOldGenerationSizeMb</strong>：用于控制老年代（old generation，另一种用于垃圾回收的内存空间）的最大大小（以 MB 为单位）。</li><li><strong>codeRangeSizeMb</strong>：限制可用于存放代码的内存大小（以 MB 为单位）。</li><li><strong>stackSizeMb</strong>：限制线程栈的大小（以 MB 为单位），这影响到递归调用的深度等。</li></ul><h4 id="实际运用的例子" tabindex="-1"><a class="header-anchor" href="#实际运用的例子"><span>实际运用的例子</span></a></h4><p>假设你正在开发一个 Node.js 应用，该应用需要处理大量图片转换任务。每个任务都很耗时，所以你决定使用工作线程来并行处理这些任务。但是，你注意到如果转换的图片太大，某些工作线程可能会消耗大量内存，影响到应用的整体性能。</p><p>为了避免这种情况，你可以在创建工作线程时设置资源限制：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./image-processing-task.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">  resourceLimits</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">    maxOldGenerationSizeMb</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 512</span><span style="color:#ECEFF4;">,</span><span style="color:#616E88;"> // 将老年代内存限制为512MB</span></span>\n<span class="line"><span style="color:#88C0D0;">    maxYoungGenerationSizeMb</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 256</span><span style="color:#ECEFF4;">,</span><span style="color:#616E88;"> // 将年轻代内存限制为256MB</span></span>\n<span class="line"><span style="color:#ECEFF4;">  },</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，无论工作线程的具体任务如何，它都不会使用超过设定限制的内存资源。这有助于防止单个工作线程占用过多资源，从而保证应用的稳定运行。</p><p>总结起来，<code>worker.resourceLimits</code>是一个强大的工具，它帮助开发者更好地管理和限制工作线程的资源使用，从而优化 Node.js 应用的性能和稳定性。</p><h2 id="worker-share-env" tabindex="-1"><a class="header-anchor" href="#worker-share-env"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workershare_env" target="_blank" rel="noopener noreferrer">worker.SHARE_ENV</a></span></a></h2><p>Node.js 中的 <code>worker.SHARE_ENV</code> 用于在使用 Web Worker 线程时共享环境变量。要理解这个概念，我们需要先简单讲解一下 Node.js 的线程和环境变量。</p><h3 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识"><span>基础知识</span></a></h3><ol><li><p><strong>Web Worker 线程</strong></p><ul><li>Node.js 允许通过创建多线程来执行并行操作，提高程序的执行效率。这些线程可以独立运行代码，互不干扰。</li></ul></li><li><p><strong>环境变量</strong></p><ul><li>环境变量是存储在操作系统中，可以被运行在该系统上的应用程序访问的键值对。它们常用于配置程序运行的参数，如数据库连接信息或外部 API 密钥。</li></ul></li></ol><h3 id="worker-share-env-1" tabindex="-1"><a class="header-anchor" href="#worker-share-env-1"><span><code>worker.SHARE_ENV</code></span></a></h3><p>在 Node.js 中，<code>worker.SHARE_ENV</code> 是一个特殊值，允许你在创建新的 Worker 线程时共享父线程的环境变量。默认情况下，每个 Worker 线程有自己的环境变量副本，与父线程隔离。但如果你想让所有线程都能访问同样的环境变量，比如为了保持配置数据的一致性，可以使用 <code>worker.SHARE_ENV</code>。</p><h3 id="实例说明" tabindex="-1"><a class="header-anchor" href="#实例说明"><span>实例说明</span></a></h3><p>假设你正在开发一个 Node.js 应用程序，需要执行大量数据处理任务，并且这些任务需要读取同样的环境变量来获取数据库连接信息。为了提高效率，你决定使用 Worker 线程来并行处理这些任务。此时，<code>worker.SHARE_ENV</code> 就非常有用了。</p><h4 id="示例代码片段" tabindex="-1"><a class="header-anchor" href="#示例代码片段"><span>示例代码片段</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  Worker</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  isMainThread</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  workerData</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  SHARE_ENV</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  process</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">env</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">SECRET_KEY</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">mysecretkey</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 设置环境变量</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 创建一个 Worker 线程，使用 SHARE_ENV 来共享环境变量</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">    `</span></span>\n<span class="line"><span style="color:#A3BE8C;">        const { parentPort } = require(&#39;worker_threads&#39;);</span></span>\n<span class="line"><span style="color:#A3BE8C;">        parentPort.postMessage(process.env.SECRET_KEY); // 使用共享的环境变量</span></span>\n<span class="line"><span style="color:#ECEFF4;">    `</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">    {</span><span style="color:#88C0D0;"> eval</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> true</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> env</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> SHARE_ENV</span><span style="color:#ECEFF4;"> }</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">  )</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从 Worker 收到的秘密键: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程的代码</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中：</p><ul><li>我们在主线程中设置了一个名为 <code>SECRET_KEY</code> 的环境变量。</li><li>接着，我们创建了一个 Worker 线程，传递 <code>SHARE_ENV</code> 作为 <code>env</code> 选项的值。这表示新的 Worker 线程将共享主线程的环境变量。</li><li>在 Worker 线程中，我们通过 <code>process.env.SECRET_KEY</code> 访问了共享的环境变量，并通过消息发送回主线程。</li></ul><p>这种方式使得所有线程都能以一致的方式访问环境变量，无需额外的同步机制，从而简化了线程间共享配置信息的处理。</p><p>总结来说，<code>worker.SHARE_ENV</code> 在并行处理场景中，尤其是需要共享配置数据时，提供了一个非常便利的解决方案。</p><h2 id="worker-setenvironmentdata-key-value" tabindex="-1"><a class="header-anchor" href="#worker-setenvironmentdata-key-value"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workersetenvironmentdatakey-value" target="_blank" rel="noopener noreferrer">worker.setEnvironmentData(key[, value])</a></span></a></h2><p>Node.js 中的<code>worker.setEnvironmentData(key[, value])</code>是一个与 Worker 线程有关的功能。为了解释这个方法，我们需要首先理解几个关键概念：Node.js、Worker 线程以及环境数据。</p><h3 id="_1-node-js-简介" tabindex="-1"><a class="header-anchor" href="#_1-node-js-简介"><span>1. Node.js 简介</span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许开发者在服务器端运行 JavaScript 代码。Node.js 的设计目的是为了构建快速、可扩展的网络应用程序。</p><h3 id="_2-worker-线程" tabindex="-1"><a class="header-anchor" href="#_2-worker-线程"><span>2. Worker 线程</span></a></h3><p>在多核 CPU 的系统上，Node.js 可以通过创建多个线程来充分利用多核处理能力，从而提高性能。这些额外的线程称为“Worker 线程”。每个 Worker 线程都可以执行 JavaScript 代码或者 Node.js 操作，相互之间独立，但也可以通过消息传递来通信。</p><h3 id="_3-环境数据-environment-data" tabindex="-1"><a class="header-anchor" href="#_3-环境数据-environment-data"><span>3. 环境数据（Environment Data）</span></a></h3><p>环境数据是指存储在特定环境（如 Worker 线程）中的键值对数据。这些数据可以被线程内的各个部分访问和修改，允许不同代码片段共享信息。</p><h3 id="worker-setenvironmentdata-key-value-方法" tabindex="-1"><a class="header-anchor" href="#worker-setenvironmentdata-key-value-方法"><span><code>worker.setEnvironmentData(key[, value])</code> 方法</span></a></h3><p>此方法允许你在 Worker 线程的环境中设置或更新键值对数据。这其中，<code>key</code>是你想要设置的数据的名称，而<code>value</code>是与该键相关联的值。如果不提供<code>value</code>，则默认为<code>undefined</code>。</p><h4 id="参数" tabindex="-1"><a class="header-anchor" href="#参数"><span>参数</span></a></h4><ul><li><code>key</code> (string | Symbol): 要设置的数据的键。</li><li><code>value</code> (any): 与键关联的值。如果省略，将会把键对应的值设为<code>undefined</code>。</li></ul><h4 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h4><p>假设你正在开发一个 Web 应用程序，这个程序使用 Worker 线程来处理图像的压缩。每个线程负责一张图像的处理。你可能需要在 Worker 线程中保存一些元数据，比如图像的原始大小和目标大小。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 主线程文件 main.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个Worker线程</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 设置Worker线程环境数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">setEnvironmentData</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">imageMeta</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span><span style="color:#88C0D0;"> originalSize</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 1024</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> targetSize</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 512</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// worker.js中的Worker线程可以访问这些环境数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// Worker线程文件 worker.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> threadId</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> getEnvironmentData</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 获取并使用环境数据</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> imageMeta</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> getEnvironmentData</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">imageMeta</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">  `</span><span style="color:#A3BE8C;">Worker </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;"> is processing an image from </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">imageMeta</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">originalSize</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;"> to </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">imageMeta</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">targetSize</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">.</span><span style="color:#ECEFF4;">`</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3"><span>总结</span></a></h3><p>通过<code>worker.setEnvironmentData(key[, value])</code>方法，你可以在 Node.js 的 Worker 线程中设置环境数据，这些数据可以被当前线程中的任何代码访问和修改。这种方式非常适合在不同代码片段之间共享状态或配置信息。</p><h2 id="worker-threadid" tabindex="-1"><a class="header-anchor" href="#worker-threadid"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid" target="_blank" rel="noopener noreferrer">worker.threadId</a></span></a></h2><p>当我们谈论 Node.js，我们通常指的是一个能让 JavaScript 运行在服务器端的平台。Node.js 非常擅长处理高并发、I/O 密集型的任务，但它默认是单线程的。这意味着一次只能执行一个任务。为了克服这一限制，Node.js 引入了“工作线程(Worker Threads)”这个概念。</p><p>在 Node.js 中，“工作线程(Worker Threads)”是实现多线程功能的一种方式。每一个工作线程都可以执行一个任务，而不会阻塞主线程。这样，你就可以在同一时间内并行处理多个任务了。</p><h3 id="worker-threadid-1" tabindex="-1"><a class="header-anchor" href="#worker-threadid-1"><span>worker.threadId</span></a></h3><p><code>worker.threadId</code>是 Node.js 中一个非常具体的属性，它属于<code>worker_threads</code>模块。这个属性提供了当前工作线程的唯一标识符（ID）。每个工作线程都有一个独一无二的 ID，即使是在多核 CPU 系统上并行运行时也是如此。这个 ID 对于跟踪和管理工作线程非常有用。</p><h3 id="实际运用例子" tabindex="-1"><a class="header-anchor" href="#实际运用例子"><span>实际运用例子</span></a></h3><p>假设你正在构建一个 Web 服务器，这个服务器需要同时处理多个复杂的计算任务，比如图片处理或者大数据分析。如果这些计算直接在主线程上执行，会导致服务器响应变慢，影响用户体验。这时候，你就可以使用工作线程来并行处理这些计算任务。</p><h4 id="例子-1-使用-worker-threads-加速计算" tabindex="-1"><a class="header-anchor" href="#例子-1-使用-worker-threads-加速计算"><span>例子 1：使用 Worker Threads 加速计算</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> threadId</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">主线程ID: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">    // 创建一个工作线程去处理耗时计算</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">        console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">来自工作线程</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">开始工作</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">    // 工作线程收到消息后开始进行耗时计算</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">        console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">        // 模拟耗时计算</span></span>\n<span class="line"><span style="color:#81A1C1;">        let</span><span style="color:#D8DEE9;"> sum</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 0</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">        for</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#B48EAD;"> 1e9</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#D8DEE9;">            sum</span><span style="color:#81A1C1;"> +=</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">        }</span></span>\n<span class="line"><span style="color:#616E88;">        // 将计算结果发送回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">        parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">计算结果: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">sum</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个工作线程去执行耗时的累加计算，计算完成后，工作线程将结果发送回主线程。通过<code>worker.threadId</code>和主线程的<code>threadId</code>，你能清晰地看到哪些操作是在哪个线程上执行的。</p><h4 id="例子-2-使用-worker-threads-进行资源密集型操作" tabindex="-1"><a class="header-anchor" href="#例子-2-使用-worker-threads-进行资源密集型操作"><span>例子 2：使用 Worker Threads 进行资源密集型操作</span></a></h4><p>考虑一个场景，你需要在服务器上处理大量的图像转换任务。这种情况下，你可以为每个转换任务创建一个工作线程，从而不会阻塞主线程，确保服务器能够继续快速响应其他网络请求。</p><p>这两个例子展示了<code>worker.threadId</code>在实际应用中的重要性，它帮助开发者在调试和优化多线程程序时，更好地理解和管理不同的工作线程。</p><h2 id="worker-workerdata" tabindex="-1"><a class="header-anchor" href="#worker-workerdata"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerworkerdata" target="_blank" rel="noopener noreferrer">worker.workerData</a></span></a></h2><p>理解 <code>worker.workerData</code> 之前，首先得知道 Node.js 中的<code>Worker Threads</code>模块是用于多线程编程的。在单线程运行时，JavaScript 代码执行在一个主线程上，但有时候为了提高性能，我们需要在后台并行执行一些任务而不阻塞主线程，这时候就可以使用<code>Worker Threads</code>。</p><h3 id="worker-threads-简介" tabindex="-1"><a class="header-anchor" href="#worker-threads-简介"><span>Worker Threads 简介</span></a></h3><p><code>Worker Threads</code>允许你创建多个线程，在这些线程上运行 JavaScript 代码。这对于执行 CPU 密集型操作特别有用，因为它们可以被分散到多个核心上，避免阻塞事件循环和影响应用程序的整体性能。</p><h3 id="worker-workerdata-1" tabindex="-1"><a class="header-anchor" href="#worker-workerdata-1"><span>worker.workerData</span></a></h3><p>当你创建一个新的<code>Worker</code>线程时，可能希望传递一些数据给这个线程，以便这个线程可以根据这些数据执行特定的操作。这正是<code>worker.workerData</code>的用途所在。</p><p><code>worker.workerData</code>是在创建 Worker 线程时，通过<code>Worker</code>构造函数的第二个参数传入的数据的一个引用。这意味着，你可以在主线程发送数据到工作线程，或者在工作线程之间共享数据。</p><h3 id="实际运用例子-1" tabindex="-1"><a class="header-anchor" href="#实际运用例子-1"><span>实际运用例子</span></a></h3><p>假设你正在开发一个应用程序，需要从几个大文件中读取数据，并基于这些数据执行一些复杂的计算。</p><ol><li><p><strong>无使用 Worker Thread</strong>：你可能会直接在主线程中进行读取和计算，但这会导致应用响应迟缓，因为文件读取和计算都是阻塞操作。</p></li><li><p><strong>使用 Worker Thread</strong>：你创建一个新的 Worker 线程来处理数据读取和计算，这样主线程就可以保持响应用户操作。</p></li></ol><h4 id="具体代码示例" tabindex="-1"><a class="header-anchor" href="#具体代码示例"><span>具体代码示例</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 主线程 main.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> runService</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">workerData</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#81A1C1;"> new</span><span style="color:#8FBCBB;"> Promise</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">resolve</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./service.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> resolve</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">      if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;"> !==</span><span style="color:#B48EAD;"> 0</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#88C0D0;">        reject</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker stopped with exit code </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {</span><span style="color:#88C0D0;"> filePath</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">path/to/bigFile.txt</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">runService</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">workerData</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">then</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 工作线程 service.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> fs</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">fs</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 假设是一个异步的大文件读取操作</span></span>\n<span class="line"><span style="color:#D8DEE9;">fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">readFile</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">workerData</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">filePath</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">err</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">err</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">throw</span><span style="color:#D8DEE9;"> err</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 对数据进行一些处理</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> processData</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 将结果发送回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> processData</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这里是数据处理逻辑</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#D8DEE9;"> data</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 示例中直接返回原数据</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中：</p><ul><li><strong>主线程</strong> 创建了一个工作线程，将包含大文件路径的<code>workerData</code>对象传递给它。</li><li><strong>工作线程</strong> 接收<code>workerData</code>，利用它来读取文件并进行处理，然后将结果发送回主线程。</li></ul><p>通过这种方式，即使是处理大量数据也不会阻塞主线程，从而提高了应用程序的响应性和性能。</p><h2 id="class-broadcastchannel-extends-eventtarget" tabindex="-1"><a class="header-anchor" href="#class-broadcastchannel-extends-eventtarget"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#class-broadcastchannel-extends-eventtarget" target="_blank" rel="noopener noreferrer">Class: BroadcastChannel extends EventTarget</a></span></a></h2><p>Node.js v21.7.1 中的<code>BroadcastChannel</code>是一个非常实用的功能，特别是在处理多线程应用时。让我来详细解释一下它是什么，以及如何在实际项目中使用它。</p><h3 id="什么是broadcastchannel" tabindex="-1"><a class="header-anchor" href="#什么是broadcastchannel"><span>什么是<code>BroadcastChannel</code>？</span></a></h3><p>在多线程编程中，不同的线程需要通信，以协调工作或交换数据。<code>BroadcastChannel</code>提供了一个简单的通信机制，允许我们跨多个工作线程（worker threads）发送消息。这意味着你可以创建一个消息通道，并且在多个线程之间共享信息。</p><p>它是<code>EventTarget</code>的一个扩展，这意味着它能够监听和触发事件。通过利用事件驱动的编程模型，它允许不同的线程订阅和发布消息。</p><h3 id="如何工作" tabindex="-1"><a class="header-anchor" href="#如何工作"><span>如何工作？</span></a></h3><ol><li><strong>创建广播通道：</strong> 首先，在需要通信的各个工作线程中创建同名的<code>BroadcastChannel</code>。</li><li><strong>发送消息：</strong> 然后，任何一个线程都可以通过这个通道发送消息。</li><li><strong>接收消息：</strong> 其他所有订阅了该通道（即创建了同名<code>BroadcastChannel</code>）的线程都能接收到这个消息，并根据需要进行处理。</li></ol><h3 id="实际运用示例-2" tabindex="-1"><a class="header-anchor" href="#实际运用示例-2"><span>实际运用示例</span></a></h3><p>假设你正在开发一个 Node.js 应用，该应用需要执行一些耗时的数据处理任务，并且希望将处理结果实时更新给用户界面。</p><h4 id="步骤-1-创建工作线程" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建工作线程"><span>步骤 1: 创建工作线程</span></a></h4><p>首先，你会创建一个或多个工作线程来处理这些耗时的任务。这可以通过 Node.js 的<code>worker_threads</code>模块完成。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个工作线程来处理任务</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./path/to/workerCode.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-在工作线程中使用broadcastchannel" tabindex="-1"><a class="header-anchor" href="#步骤-2-在工作线程中使用broadcastchannel"><span>步骤 2: 在工作线程中使用<code>BroadcastChannel</code></span></a></h4><p>在工作线程的代码中，你会创建一个<code>BroadcastChannel</code>，并监听来自其他线程的消息，同时也可以发送消息。</p><p><code>workerCode.js</code>示例：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data-processing</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received message: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 处理接收到的消息...</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 假设某个条件满足，向其他线程广播消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Processing done</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-3-在主线程或其他工作线程中接收消息" tabindex="-1"><a class="header-anchor" href="#步骤-3-在主线程或其他工作线程中接收消息"><span>步骤 3: 在主线程或其他工作线程中接收消息</span></a></h4><p>在主线程或其他工作线程中，你也创建一个同名的<code>BroadcastChannel</code>，以接收消息并据此更新用户界面或执行其他操作。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data-processing</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received message: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 根据接收到的消息更新用户界面等</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-4" tabindex="-1"><a class="header-anchor" href="#总结-4"><span>总结</span></a></h3><p>通过上述例子，可以看到<code>BroadcastChannel</code>使得跨工作线程的通信变得简单高效。无论是更新 UI、同步状态、还是其他需要线程间通信的场景，<code>BroadcastChannel</code>提供了一种便捷的方式来实现这些功能，使得你的 Node.js 多线程应用更加强大和灵活。</p><h3 id="new-broadcastchannel-name" tabindex="-1"><a class="header-anchor" href="#new-broadcastchannel-name"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#new-broadcastchannelname" target="_blank" rel="noopener noreferrer">new BroadcastChannel(name)</a></span></a></h3><p>Node.js 中的<code>BroadcastChannel</code>是一个相对较新的功能，它提供了一种非常方便的方式，允许不同的线程（或者在浏览器环境下的标签页、workers 等）之间进行通信。它特别适用于那些需要多个部分之间实时共享数据的场景。</p><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><p>首先，让我们来理解一下<code>BroadcastChannel</code>的基本概念。<code>BroadcastChannel</code>是一个创建广播频道的方法，它允许你发送一个消息到同一个频道的所有监听者。这意味着你可以非常容易地在不同的工作线程、服务线程甚至是不同的 Node.js 进程之间共享信息。</p><h3 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用"><span>如何使用</span></a></h3><p>使用<code>BroadcastChannel</code>非常简单。首先，你需要在你的代码中引入或访问它。然后，你可以创建一个新的<code>BroadcastChannel</code>实例，并给它指定一个名称。所有使用同一个名称创建的<code>BroadcastChannel</code>实例都会被认为是在同一个频道上。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 引入 worker_threads 模块，以便可以使用 BroadcastChannel</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个新的 BroadcastChannel 实例，命名为 &quot;myChannel&quot;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">myChannel</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用 postMessage 方法发送消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello, World!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实际运用示例-3" tabindex="-1"><a class="header-anchor" href="#实际运用示例-3"><span>实际运用示例</span></a></h3><h4 id="_1-多个工作线程间的状态同步" tabindex="-1"><a class="header-anchor" href="#_1-多个工作线程间的状态同步"><span>1. 多个工作线程间的状态同步</span></a></h4><p>假设你正在开发一个 Node.js 应用，这个应用需要执行一些密集的 CPU 任务，因此你决定使用 Worker Threads 来并行处理这些任务。但是，你需要所有的工作线程能够实时共享某些状态信息（例如，任务的进度、是否有线程遇到错误等）。这时，<code>BroadcastChannel</code>就可以派上用场。</p><p>每个工作线程可以创建或加入一个共同的频道，并通过这个频道与其他线程共享重要的状态更新。</p><h4 id="_2-微服务间的轻量级事件广播" tabindex="-1"><a class="header-anchor" href="#_2-微服务间的轻量级事件广播"><span>2. 微服务间的轻量级事件广播</span></a></h4><p>在一个由多个微服务构成的系统中，往往需要一种机制来无缝地传递事件或消息。虽然这通常通过使用消息队列或事件总线来实现，但在某些轻量级的需求中，<code>BroadcastChannel</code>也可以作为一个非常有效的替代方案。</p><p>比如，如果你有一个负责用户认证的微服务和另一个处理用户订单的微服务，当一个用户成功登录后，用户认证服务可以通过<code>BroadcastChannel</code>广播一个“用户登录”事件，而处理用户订单的微服务则可以实时监听这个事件，并据此做出相应的处理。</p><h4 id="_3-开发调试工具" tabindex="-1"><a class="header-anchor" href="#_3-开发调试工具"><span>3. 开发调试工具</span></a></h4><p>如果你正在开发一个需要同时监控多个进程或线程状态的调试工具，<code>BroadcastChannel</code>可以使得这些组件之间的通信变得非常简单。每个进程或线程可以将其状态和日志消息广播出去，而主监控工具则可以接收并展示这些信息，帮助开发者更好地理解应用的运行情况。</p><h3 id="总结-5" tabindex="-1"><a class="header-anchor" href="#总结-5"><span>总结</span></a></h3><p><code>BroadcastChannel</code>在 Node.js 中提供了一种简单而强大的通信机制，特别适合需要跨线程或跨服务共享信息的场景。通过几个简单的 API，你可以轻松地在你的应用中实现复杂的通信模式，从而提高效率和响应速度。</p><h3 id="broadcastchannel-close" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-close"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelclose" target="_blank" rel="noopener noreferrer">broadcastChannel.close()</a></span></a></h3><p>好的，让我帮你理解 Node.js 里的 <code>broadcastChannel.close()</code> 方法，以及它在实际应用中的用途。</p><h3 id="理解-broadcastchannel" tabindex="-1"><a class="header-anchor" href="#理解-broadcastchannel"><span>理解 BroadcastChannel</span></a></h3><p>首先，<code>BroadcastChannel</code> 是一个 Node.js 中用于不同工作线程（worker threads）之间进行简便通信的机制。想象一下，如果你有一个大型的 Web 服务器或者应用，这个应用可能需要执行很多任务，比如处理用户请求、读写数据库、进行复杂计算等。为了提高效率，你可以把这些任务分配给不同的“工人”去完成，这里的“工人”就是所谓的工作线程。</p><p>使用 <code>BroadcastChannel</code>，你可以创建一个通信频道，通过这个频道，一个工作线程可以向所有订阅（监听）了这个频道的工作线程发送消息。这样做的好处是能够简化不同线程间的通信过程，特别是当你需要广播信息时。</p><h3 id="使用-broadcastchannel-close" tabindex="-1"><a class="header-anchor" href="#使用-broadcastchannel-close"><span>使用 broadcastChannel.close()</span></a></h3><p>现在来到了具体的 <code>broadcastChannel.close()</code> 方法。正如其名，这个方法用于关闭一个 <code>BroadcastChannel</code>。当你调用这个方法时，当前的通信频道会被关闭，这意味着之后就不能再通过这个频道发送或接收消息了。关闭通道是一个好习惯，尤其是在你确定不再需要这个通信频道时，因为它可以帮助释放系统资源。</p><h3 id="实际运用的例子-1" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-1"><span>实际运用的例子</span></a></h3><p>让我们通过一个简单的例子来看看 <code>broadcastChannel.close()</code> 是如何工作的：</p><h4 id="场景描述" tabindex="-1"><a class="header-anchor" href="#场景描述"><span>场景描述</span></a></h4><p>假设你正在开发一个在线编辑器，这个编辑器允许多个用户同时编辑同一个文档。为了同步不同用户的编辑，你决定使用 Node.js 的工作线程来处理数据同步。每当一个用户做出更改时，这个更改就会通过一个 <code>BroadcastChannel</code> 发送给其他所有用户。</p><h4 id="使用-broadcastchannel-close-1" tabindex="-1"><a class="header-anchor" href="#使用-broadcastchannel-close-1"><span>使用 broadcastChannel.close()</span></a></h4><ol><li><strong>启动阶段</strong>: 当服务启动时，你创建了一个 <code>BroadcastChannel</code> 名为 &quot;document-sync&quot;，所有的编辑操作和同步请求都通过这个频道进行广播。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> documentSyncChannel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">document-sync</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>操作阶段</strong>: 用户 A 对文档进行了编辑，这个更改通过 &quot;document-sync&quot; 频道广播给所有其他用户。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 假设 editEvent 是用户A编辑操作的事件对象</span></span>\n<span class="line"><span style="color:#D8DEE9;">documentSyncChannel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">editEvent</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>关闭阶段</strong>: 假设该文档编辑项目结束，或者服务器需要进行维护，这时候你需要关闭 <code>BroadcastChannel</code> 来停止进一步的通信。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#D8DEE9;">documentSyncChannel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">close</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>关闭频道之后，无论是尝试发送消息还是监听新消息，都会失败，因为频道已经不再活跃了。</p><h3 id="总结-6" tabindex="-1"><a class="header-anchor" href="#总结-6"><span>总结</span></a></h3><p>通过上面的例子，你可以看到 <code>broadcastChannel.close()</code> 在管理资源和确保应用程序正确关闭时的重要性。在实际应用中，合理地打开和关闭通信频道，可以帮助你维持应用的高效运行和稳定性。</p><h3 id="broadcastchannel-onmessage" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-onmessage"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelonmessage" target="_blank" rel="noopener noreferrer">broadcastChannel.onmessage</a></span></a></h3><p>Node.js 是一个非常强大的 JavaScript 运行时，它让你能够在服务器端运行 JavaScript。随着 Node.js 的发展，它引入了很多功能来支持多线程处理和进程间通信。其中一种进阶特性就是 BroadcastChannel API。理解这个概念，我们可以从几个简单的角度来看：什么是 <code>BroadcastChannel</code>、如何使用它、以及它的实际应用例子。</p><h3 id="什么是-broadcastchannel" tabindex="-1"><a class="header-anchor" href="#什么是-broadcastchannel"><span>什么是 BroadcastChannel？</span></a></h3><p><code>BroadcastChannel</code> 是一个允许不同的浏览器标签页、Iframes 或者工作线程之间进行简单通信的接口。在 Node.js 中，它主要被用于不同工作线程之间的通信。每个通过相同名称创建的 <code>BroadcastChannel</code> 都会加入到一个通信频道中，任何一个成员发送的消息都会被频道内的所有成员接收。</p><h3 id="如何使用-broadcastchannel-onmessage" tabindex="-1"><a class="header-anchor" href="#如何使用-broadcastchannel-onmessage"><span>如何使用 <code>broadcastChannel.onmessage</code>？</span></a></h3><p>使用 <code>broadcastChannel.onmessage</code> 非常直接。首先，你需要创建一个 <code>BroadcastChannel</code> 实例，然后，通过监听 <code>onmessage</code> 事件来接收消息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  BroadcastChannel</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  isMainThread</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  workerData</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个BroadcastChannel实例</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">channel_name</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程逻辑</span></span>\n<span class="line"><span style="color:#616E88;">  // 发送消息给其他线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from the main thread</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程逻辑</span></span>\n<span class="line"><span style="color:#616E88;">  // 监听消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received message: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码演示了如何在主线程中创建一个 <code>BroadcastChannel</code> 并发送消息，在工作线程中接收这个消息。</p><h3 id="实际运用的例子-2" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-2"><span>实际运用的例子</span></a></h3><h4 id="例子-1-进度更新" tabindex="-1"><a class="header-anchor" href="#例子-1-进度更新"><span>例子 1：进度更新</span></a></h4><p>假设你正在编写一个视频处理应用程序，该程序拆分为多个工作线程以加速处理过程。你可以使用 <code>BroadcastChannel</code> 来广播处理进度的更新，这样用户界面（可能运行在主线程中）就能实时显示进度信息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 工作线程中</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> progress</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> calculateProgress</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> type</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">progress</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> value</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> progress</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="例子-2-任务分配和结果收集" tabindex="-1"><a class="header-anchor" href="#例子-2-任务分配和结果收集"><span>例子 2：任务分配和结果收集</span></a></h4><p>如果你有一个任务需要多个工作线程共同完成，你可以利用 <code>BroadcastChannel</code> 来分配任务，并收集处理结果。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 主线程中分配任务</span></span>\n<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9;"> numberOfTasks</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#D8DEE9;">    channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;">type</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &#39;</span><span style="color:#A3BE8C;">task</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> taskId</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> i</span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 工作线程中接收任务并返回结果</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">type</span><span style="color:#81A1C1;"> ===</span><span style="color:#ECEFF4;"> &#39;</span><span style="color:#A3BE8C;">task</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#81A1C1;">        const</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> performTask</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">taskId</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">        channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;">type</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &#39;</span><span style="color:#A3BE8C;">result</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> taskId</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">taskId</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> result</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> result</span><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上例子展示了 <code>BroadcastChannel</code> 可以如何使不同的工作线程之间的通信更加简单和高效。通过使用这个 API，开发人员可以更容易地构建出复杂的多线程应用程序，提升应用的性能和响应速度。</p><h3 id="broadcastchannel-onmessageerror" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-onmessageerror"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelonmessageerror" target="_blank" rel="noopener noreferrer">broadcastChannel.onmessageerror</a></span></a></h3><p>理解 <code>broadcastChannel.onmessageerror</code> 之前，我们需要先了解 Node.js 中的几个概念：<code>BroadcastChannel</code>, <code>Worker Threads</code> 和事件监听。</p><ol><li><p><strong>BroadcastChannel</strong>: 这是一个允许不同的服务或线程之间进行通信的机制。想象一下，如果你有多个窗口（在浏览器环境中）或多个工作线程（在 Node.js 环境中），你希望它们之间能够交换消息，那么 <code>BroadcastChannel</code> 就是一个实用的工具。</p></li><li><p><strong>Worker Threads</strong>: 在 Node.js 中，工作线程（Worker Threads）允许你执行 JavaScript 代码并行运行，这对于执行耗时操作特别有用，因为它可以避免阻塞主线程，从而提高应用性能。</p></li><li><p><strong>事件监听(Event Listeners)</strong>: 在 JavaScript 或 Node.js 中，事件监听是一种常见的模式，用于响应各种事件（例如用户点击按钮、接收到网络请求等）。程序员可以定义一个函数，当特定事件发生时，这个函数会被自动调用。</p></li></ol><p>现在来看 <code>broadcastChannel.onmessageerror</code>：</p><ul><li>当使用 <code>BroadcastChannel</code> 来进行通信时，你可能会发送消息给其他的听众（其他的窗口或工作线程）。如果出于某种原因，消息无法被正确接收或处理（比如，接收方无法解析消息内容），就会产生一个错误。</li><li><code>onmessageerror</code> 是一个事件监听器，专门用来捕获和处理这种情况。通过设置 <code>onmessageerror</code>，你可以定义一个函数，当消息错误发生时执行，从而可以优雅地处理错误，而不是让整个应用崩溃或进入不稳定状态。</li></ul><h3 id="实际应用例子-1" tabindex="-1"><a class="header-anchor" href="#实际应用例子-1"><span>实际应用例子</span></a></h3><p>假设你正在开发一个 Node.js 应用，该应用利用工作线程来处理一些耗时的数据分析任务。同时，你希望主线程能够与这些工作线程通信，例如发送任务参数，并接收处理结果。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">analysis</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessageerror</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">消息接收错误:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 启动相同的文件作为工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#88C0D0;">    task</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">Analyze data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#88C0D0;">    parameters</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">      /* 一些参数*/</span></span>\n<span class="line"><span style="color:#ECEFF4;">    },</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">analysis</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">接收到任务:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">    // 处理任务...</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">    // 假设处理过程中发生了错误，导致不能正确解析消息</span></span>\n<span class="line"><span style="color:#616E88;">    // 这会在主线程中触发 onmessageerror 事件</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个工作线程，并通过 <code>BroadcastChannel</code> 发送了一个任务。此外，主线程设置了 <code>onmessageerror</code> 监听器来捕获任何消息错误。如果工作线程中的消息处理出现问题，主线程可以通过 <code>onmessageerror</code> 得知，并采取适当的错误处理措施，比如重新发送消息、记录错误日志等。</p><p>这样，即使在并行处理和通信过程中遇到问题，应用也能更加健壮和可靠。</p><h3 id="broadcastchannel-postmessage-message" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-postmessage-message"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelpostmessagemessage" target="_blank" rel="noopener noreferrer">broadcastChannel.postMessage(message)</a></span></a></h3><p>了解 <code>broadcastChannel.postMessage(message)</code> 之前，我们先要明白几个关键的概念：<strong>Node.js</strong>、<strong>Worker Threads</strong> 和 <strong>BroadcastChannel</strong>。</p><h3 id="node-js-简介" tabindex="-1"><a class="header-anchor" href="#node-js-简介"><span>Node.js 简介</span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它让你可以在服务器端运行 JavaScript，使得开发高性能网络应用成为可能。</p><h3 id="worker-threads-1" tabindex="-1"><a class="header-anchor" href="#worker-threads-1"><span>Worker Threads</span></a></h3><p>在 Node.js 中，Worker Threads 提供了一种简单的方法来创建多线程应用程序。默认情况下，Node.js 运行在单线程模式下，但是有时候，为了更好地利用多核 CPU 的能力，我们可能需要并行执行代码。这时候就需要使用到 Worker Threads 了。</p><h3 id="broadcastchannel" tabindex="-1"><a class="header-anchor" href="#broadcastchannel"><span>BroadcastChannel</span></a></h3><p><code>BroadcastChannel</code> 是在 Node.js v15.4.0 引入的功能，允许在相同的 Node.js 实例中不同的 Worker Threads 之间进行简单的通信。简而言之，<code>BroadcastChannel</code> 允许我们跨 Worker 线程广播消息。</p><h3 id="broadcastchannel-postmessage-message-1" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-postmessage-message-1"><span>broadcastChannel.postMessage(message)</span></a></h3><p><code>broadcastChannel.postMessage(message)</code> 方法允许你发送一个消息给同一个 <code>BroadcastChannel</code> 名称下的所有监听者（其他 Worker Threads 或者当前的 Worker Thread）。这非常有用于当你需要在多个线程间共享状态或通知所有线程某些事件时。</p><h3 id="实际运用示例-4" tabindex="-1"><a class="header-anchor" href="#实际运用示例-4"><span>实际运用示例</span></a></h3><p>假设我们正在开发一个网站后端服务，该服务需要处理大量的数据分析任务，这些任务是并行且独立的。我们可以使用 Worker Threads 来并行处理这些任务，并使用 <code>BroadcastChannel</code> 来通知所有任务完成的状态。</p><h4 id="步骤-1-创建-worker-thread" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建-worker-thread"><span>步骤 1: 创建 Worker Thread</span></a></h4><p>首先，我们创建一个新的 Worker 文件，命名为 <code>worker.js</code>：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">task</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 处理任务...</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">处理任务: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">task</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设任务完成后，我们通过 parentPort 发送一个完成的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">task</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;"> 完成</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-使用-broadcastchannel-在主文件中" tabindex="-1"><a class="header-anchor" href="#步骤-2-使用-broadcastchannel-在主文件中"><span>步骤 2: 使用 BroadcastChannel 在主文件中</span></a></h4><p>在主文件中，我们创建 Worker Threads 并使用 <code>BroadcastChannel</code> 来监听所有 Worker 的完成消息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建 BroadcastChannel</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">任务通知</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听来自任何 Worker 的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">收到消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建 Worker Threads 并发送任务</span></span>\n<span class="line"><span style="color:#81A1C1;">for</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#81A1C1;">let</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 0</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#B48EAD;"> 5</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;">++</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">./worker.js</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">任务 </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">i</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 发送任务到 Worker</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 模拟在一个 Worker 中发送广播消息</span></span>\n<span class="line"><span style="color:#88C0D0;">setTimeout</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">所有任务都已完成！</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">},</span><span style="color:#B48EAD;"> 5000</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个 <code>BroadcastChannel</code> 实例，并在五个 Worker Threads 中分配了任务。每个 Worker 在完成其任务后通过 <code>parentPort.postMessage</code> 发送消息。主线程监听 <code>BroadcastChannel</code> 的消息，并在收到任何 Worker 的完成消息时打印出来。</p><p>通过这个机制，我们可以有效地在多个 Worker Threads 之间进行通信和状态同步，从而提高应用程序的性能和响应能力。</p><h3 id="broadcastchannel-ref" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-ref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelref" target="_blank" rel="noopener noreferrer">broadcastChannel.ref()</a></span></a></h3><p>Node.js 是一个非常强大的 JavaScript 运行环境，它允许你使用 JavaScript 来编写后端代码。在 Node.js 的多版本中，有一项功能叫做 <code>BroadcastChannel</code>，这是一个允许不同的 Node.js 进程（也可以称为工作线程）之间进行通信的机制。</p><p>首先，了解一下什么是 <code>BroadcastChannel</code>。简单来说，<code>BroadcastChannel</code> 是一种允许同一台机器上运行的不同 Node.js 实例（或者说是工作线程）之间进行数据广播的方式。它的工作原理类似于现实生活中的广播站：一方发送消息，所有订阅了这个频道的收听者都能接收到这条消息。</p><p>在 Node.js v21.7.1 版本中, <code>BroadcastChannel.ref()</code> 和 <code>BroadcastChannel.unref()</code> 是两个方法，它们用于控制 <code>BroadcastChannel</code> 对象是否应该让 Node.js 进程保持活跃状态。</p><h3 id="broadcastchannel-ref-1" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-ref-1"><span><code>broadcastChannel.ref()</code></span></a></h3><p>当你调用 <code>broadcastChannel.ref()</code> 方法时，你告诉 Node.js：“即使这是当前进程中正在运行的唯一操作，我也希望 Node.js 保持活跃状态，不要关闭。” 这个方法确保了只要 BroadcastChannel 存在并且被引用，Node.js 进程就会保持运行状态。</p><h3 id="实际应用示例-2" tabindex="-1"><a class="header-anchor" href="#实际应用示例-2"><span>实际应用示例</span></a></h3><p>设想一个实时聊天应用程序，运行在不同的用户设备上，但所有设备都连接到同一服务器。你可能有一个主服务器处理大部分请求，而另外几个辅助服务器负责处理特定任务，比如发送通知。</p><p>如果辅助服务器需要向主服务器发送实时更新（例如，通知用户新消息的到达），它们可以使用 <code>BroadcastChannel</code> 来做到这点。每个服务器实例都可以加入相同的 <code>BroadcastChannel</code>，然后任何一个服务器实例都可以通过这个频道广播消息给其他所有实例。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> BroadcastChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个 BroadcastChannel 实例</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">chat-updates</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用 .ref() 确保 Node.js 进程保持活动状态，等待消息。</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">ref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 在一个服务器实例上监听消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received message: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 在另一个服务器实例上发送消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello, this is a new chat message!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，无论是发送消息还是接收消息的服务器，都通过调用 <code>.ref()</code> 确保了只要他们还在交流，整个 Node.js 进程都不会退出。</p><p>总之，<code>BroadcastChannel.ref()</code> 方法是一种保证 Node.js 应用在需要持续监听某些事件（如跨线程或跨实例通信）时不会意外退出的有效方式。</p><h3 id="broadcastchannel-unref" tabindex="-1"><a class="header-anchor" href="#broadcastchannel-unref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelunref" target="_blank" rel="noopener noreferrer">broadcastChannel.unref()</a></span></a></h3><p>要理解 <code>broadcastChannel.unref()</code> 在 Node.js 中的使用和意义，首先我们需要了解几个概念：<code>BroadcastChannel</code>, <code>ref</code> 和 <code>unref</code>。我会逐步引导你理解这些概念，接着解释 <code>broadcastChannel.unref()</code> 的作用，并给出一些实际运用的例子。</p><h3 id="_1-什么是-broadcastchannel" tabindex="-1"><a class="header-anchor" href="#_1-什么是-broadcastchannel"><span>1. 什么是 <code>BroadcastChannel</code>？</span></a></h3><p>在 Node.js 中，<code>BroadcastChannel</code> 是一种允许不同的工作线程（Worker threads）之间进行简单通信的机制。它可以让一个线程广播消息给其他所有订阅了同一频道 (<code>channel</code>) 的线程。这对于在多核 CPU 上并行处理任务时共享状态或数据非常有用。</p><h3 id="_2-ref-和-unref-是什么" tabindex="-1"><a class="header-anchor" href="#_2-ref-和-unref-是什么"><span>2. <code>ref</code> 和 <code>unref</code> 是什么？</span></a></h3><ul><li><p><strong>ref()</strong>：当一个对象被“引用”(<code>ref</code>)时，它会保持 Node.js 进程的活跃状态，即使没有其他活动保持进程打开。例如，如果定时器或网络请求被设置为 <code>ref</code>，Node.js 将不会结束进程直到这些操作完成。</p></li><li><p><strong>unref()</strong>：与 <code>ref</code> 相反，当一个对象被“取消引用”(<code>unref</code>)时，它将不再阻止 Node.js 进程退出。也就是说，如果所有的异步操作都被 <code>unref</code>，且没有其他操作保持进程打开，Node.js 进程可以在这些操作完成前退出。</p></li></ul><h3 id="_3-broadcastchannel-unref-的作用" tabindex="-1"><a class="header-anchor" href="#_3-broadcastchannel-unref-的作用"><span>3. <code>broadcastChannel.unref()</code> 的作用</span></a></h3><p><code>broadcastChannel.unref()</code> 允许你将一个 <code>BroadcastChannel</code> 实例标记为 &quot;unref&quot;。这意味着即使这个频道上还有未处理的消息，Node.js 主进程也可以在其他条件允许的情况下正常退出。这非常有用，特别是当您希望避免因频道上的消息处理而延迟进程退出时。</p><h3 id="实际运用的例子-3" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-3"><span>实际运用的例子：</span></a></h3><p>假设你正在开发一个应用，该应用中有一个主线程和多个工作线程，工作线程需要完成一些耗时的计算任务，并且它们之间需要交换状态或结果数据。你决定使用 <code>BroadcastChannel</code> 来实现这种通信。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  BroadcastChannel</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  isMainThread</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#D8DEE9;">  workerData</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">my_channel</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from the main thread!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 允许 Node.js 主进程在不需要等待频道消息的情况下退出</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">unref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> BroadcastChannel</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">my_channel</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">onmessage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received message: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">event</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 同样地，允许工作线程在完成其它任务后退出</span></span>\n<span class="line"><span style="color:#D8DEE9;">  channel</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">unref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程向名为 <code>&#39;my_channel&#39;</code> 的 <code>BroadcastChannel</code> 发送了一个消息。所有监听这个频道的工作线程都能接收到这个消息并处理它。调用 <code>unref()</code> 确保了即使消息正在传输或等待处理，Node.js 进程也能在其他任务完成后立即退出，不会因为 <code>BroadcastChannel</code> 的活动而无谓地保持运行状态。</p><p>总结起来，<code>broadcastChannel.unref()</code> 提供了一种灵活的方式来管理 Node.js 进程的生命周期，尤其是在涉及跨线程通信时。这样，开发者可以更好地控制程序的结束时机，避免不必要的延迟。</p><h2 id="class-messagechannel" tabindex="-1"><a class="header-anchor" href="#class-messagechannel"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#class-messagechannel" target="_blank" rel="noopener noreferrer">Class: MessageChannel</a></span></a></h2><p>在解释 Node.js 中的 <code>MessageChannel</code> 类之前，让我们首先简要了解一下 Node.js 的一些背景信息。Node.js 是一个开源和跨平台的 JavaScript 运行时环境，它允许你在服务器端运行 JavaScript。Node.js 的设计哲学之一是支持异步编程，这意味着它能够处理并发操作，使得应用程序可以同时执行多个操作，而不是按顺序一个接一个地执行。这种能力对于构建高性能的网络应用程序至关重要。</p><h3 id="messagechannel-简介" tabindex="-1"><a class="header-anchor" href="#messagechannel-简介"><span>MessageChannel 简介</span></a></h3><p><code>MessageChannel</code> 是 Node.js 提供的一个 API，用于在不同的执行线程（如 Worker 线程）之间安全地传递消息。在 Node.js 中，并发模型主要通过使用 Worker 线程来实现，允许进行真正的并行执行。<code>MessageChannel</code> 提供了一种通信机制，使得主线程和 Worker 线程或者不同的 Worker 线程之间可以互相发送消息。</p><h3 id="messagechannel-结构" tabindex="-1"><a class="header-anchor" href="#messagechannel-结构"><span>MessageChannel 结构</span></a></h3><p><code>MessageChannel</code> 包含两个 <code>MessagePort</code> 对象，每个 <code>MessagePort</code> 都可以被用来发送和接收消息。简单来说，您可以将 <code>MessageChannel</code> 想象成一个有两个端口的管道，消息可以从一个端口发送出去，并且从另一个端口接收。</p><h3 id="如何使用-1" tabindex="-1"><a class="header-anchor" href="#如何使用-1"><span>如何使用</span></a></h3><ol><li><strong>创建 MessageChannel：</strong> 首先，你需要实例化 <code>MessageChannel</code>。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> MessageChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MessageChannel</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>通过端口发送和接收消息：</strong> 使用 <code>port1</code> 和 <code>port2</code> 来发送和接收消息。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 发送消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port1</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> some</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 在另一端接收消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port2</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Received:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实际应用示例-3" tabindex="-1"><a class="header-anchor" href="#实际应用示例-3"><span>实际应用示例</span></a></h3><h4 id="主线程与-worker-线程间的通信" tabindex="-1"><a class="header-anchor" href="#主线程与-worker-线程间的通信"><span>主线程与 Worker 线程间的通信</span></a></h4><p>假设你正在构建一个 Node.js 应用，该应用需要执行一个复杂的图像处理任务。为了不阻塞主线程，你决定将图像处理任务放在一个 Worker 线程中执行。</p><ol><li><strong>在主线程中：</strong></li></ol><p>首先，你需要创建一个 Worker 线程，并且使用 <code>MessageChannel</code> 与它通信。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> MessageChannel</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个 MessageChannel</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> channel</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MessageChannel</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个 Worker 线程</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./path/to/worker_script.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 发送 port2 到 Worker 线程，保留 port1 用于接收消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> port</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> channel</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port2</span><span style="color:#ECEFF4;"> },</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port2</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 通过 port1 接收来自 Worker 的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">channel</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port1</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Message from Worker:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>在 Worker 线程脚本中 (<code>worker_script.js</code>)：</strong></li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 从主线程接收 MessagePort</span></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ({</span><span style="color:#D8DEE9;"> port</span><span style="color:#ECEFF4;"> })</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 使用 port 发送消息回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from the Worker!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>MessageChannel</code> 被用来在主线程和一个 Worker 线程之间建立一个通信通道。主线程发送一个端口给 Worker 线程，并通过另一个端口监听来自 Worker 的消息。这种方式非常适合于那些需要后台执行密集型任务、但又不希望影响到主线程响应能力的场景。</p><p>通过上述解释和示例，我希望你能更好地理解 Node.js 中的 <code>MessageChannel</code> 及其在实际应用中的作用。</p><h2 id="class-messageport" tabindex="-1"><a class="header-anchor" href="#class-messageport"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport" target="_blank" rel="noopener noreferrer">Class: MessagePort</a></span></a></h2><p>了解 <code>MessagePort</code> 类，首先我们要明白它是 Node.js 中一个用于实现线程间通信（Inter-thread communication）的机制，特别是在使用 <code>worker_threads</code> 模块时。这个模块允许你创建多线程应用程序，有效地利用多核 CPU 资源。<code>MessagePort</code> 是该模块的一部分，提供了一个通道，通过它不同的线程可以相互发送消息。</p><h3 id="messageport-简介" tabindex="-1"><a class="header-anchor" href="#messageport-简介"><span>MessagePort 简介</span></a></h3><p>在 Node.js 的 <code>worker_threads</code> 模块中，每当你创建一个新的 Worker 线程时，你可以通过 <code>MessagePort</code> 对象来与这个线程进行双向通信。每一个 <code>MessagePort</code> 实例都代表着通信的一端，可以把它看作是电话通话中的一个电话。如果你想要两个线程（比如主线程和一个工作线程）相互通信，那么你需要在这两个线程之间建立一个 <code>MessagePort</code> 通道。</p><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h3><ol><li><p><strong>创建 Worker 线程并使用 MessagePort 进行通信</strong></p><p>首先，你需要使用 <code>worker_threads</code> 模块来创建一个 Worker 线程。然后，通过 <code>MessagePort</code> 发送和接收消息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 这段代码在主线程中运行</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从工作线程收到: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">hello worker</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从主线程收到: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">toUpperCase</span><span style="color:#D8DEE9FF;">())</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个工作线程，并通过 <code>postMessage</code> 方法给它发送了一条消息。工作线程接收到消息后，将消息转为大写并返回给主线程。</p></li></ol><h3 id="实际运用例子-2" tabindex="-1"><a class="header-anchor" href="#实际运用例子-2"><span>实际运用例子</span></a></h3><ol><li><p><strong>数据处理应用：</strong></p><p>假设你正在开发一个图像处理应用，这个应用需要对大量图像进行复杂的处理。你可以创建多个工作线程，每个线程处理一部分图像，然后通过 <code>MessagePort</code> 将处理结果返回给主线程。这样可以显著加快处理速度，因为你同时利用了多核 CPU。</p></li><li><p><strong>实时数据聚合服务：</strong></p><p>如果你正在开发一个需要处理来自多个来源实时数据的服务，例如股票价格分析器或社交媒体流分析器，你可以为每个数据源创建一个工作线程。每个线程负责收集和初步处理数据，然后通过 <code>MessagePort</code> 将处理过的数据发送到主线线程进行汇总和进一步分析。</p></li><li><p><strong>Web 服务器背景任务处理：</strong></p><p>在构建一个 Web 服务器时，某些请求可能需要执行耗时的操作，比如生成报告或处理大文件。为了避免这些操作阻塞主线程并影响服务器性能，你可以将这些任务分配给工作线程。通过在主线程和工作线程之间建立 <code>MessagePort</code>，你可以实现非阻塞的任务处理和结果传递。</p></li></ol><p>总之，<code>MessagePort</code> 提供了一种强大的机制来实现 Node.js 多线程应用中的线程间通信，使得构建高效、可扩展的多线程应用成为可能。</p><h3 id="event-close" tabindex="-1"><a class="header-anchor" href="#event-close"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-close" target="_blank" rel="noopener noreferrer">Event: &#39;close&#39;</a></span></a></h3><p>Node.js 是一种运行在服务器端的 JavaScript 环境，使得开发者能够使用 JavaScript 来编写服务器端的代码。Node.js 中有一个非常重要的特性叫做“工作线程”(Worker Threads)，这允许 Node.js 程序能够进行多线程处理，提高了程序处理效率，尤其是在执行多个独立任务时。</p><p>在 Node.js 的某些版本（例如 v21.7.1）中，工作线程（Worker Threads）模块包含了一个名为 &#39;close&#39; 的事件。当你在使用工作线程处理任务时，理解这个事件是非常重要的。</p><h3 id="event-close-1" tabindex="-1"><a class="header-anchor" href="#event-close-1"><span>Event: &#39;close&#39;</span></a></h3><p><code>&#39;close&#39;</code> 事件在工作线程 (worker thread) 完成所有操作并且线程的底层资源被关闭之后触发。这个事件表明该工作线程已经彻底完成了它的工作，并且现在是安全地从内存中清除或进行后续步骤的好时机。</p><h4 id="实际运用示例-5" tabindex="-1"><a class="header-anchor" href="#实际运用示例-5"><span>实际运用示例：</span></a></h4><p>想象一下，你正在构建一个 Web 应用程序，这个应用需要执行大量的数据处理工作，比如图片处理或复杂计算，这些工作可能会阻塞主线程，导致整个 Web 应用响应变慢。</p><p>为了避免这种情况，你可以使用 Node.js 的工作线程来处理这些耗时的任务。下面是一个简单的例子：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在主线程中运行</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程启动</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 创建一个新的工作线程来执行耗时任务</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 监听 &#39;close&#39; 事件</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">close</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">工作线程结束，资源被释放</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在工作线程中运行</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 假设这里进行一些耗时操作...</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">工作线程正在处理任务</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 模拟耗时任务完成</span></span>\n<span class="line"><span style="color:#88C0D0;">  setTimeout</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">工作线程完成任务</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">    // 主动结束工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">    process</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">exit</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  },</span><span style="color:#B48EAD;"> 1000</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程启动了一个工作线程来处理一项耗时任务（这里用 <code>setTimeout</code> 模拟）。当工作线程完成任务并退出时（通过 <code>process.exit()</code>），<code>&#39;close&#39;</code> 事件会被触发，此时主线程会收到通知，打印出“工作线程结束，资源被释放”。这告诉我们工作线程已经安全地完成了它的工作，资源已被清理。</p><p>通过这种方式，你可以利用多核 CPU 的能力，让你的 Node.js 应用能够同时处理多个任务而不会互相阻塞，从而显著提高应用的性能和响应速度。</p><h3 id="event-message" tabindex="-1"><a class="header-anchor" href="#event-message"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-message" target="_blank" rel="noopener noreferrer">Event: &#39;message&#39;</a></span></a></h3><p>当你开始深入学习 Node.js，尤其是在涉及到并发处理和多线程操作时，<code>worker_threads</code>模块会成为你的好帮手。Node.js 自从 v10.5.0 版本引入了这一实验性功能，它允许 Node.js 运行在多个线程中，而不仅仅是单个线程。这对于执行 CPU 密集型任务特别有用，因为它可以显著提高性能。</p><p>在<code>worker_threads</code>模块中，<code>Event: &#39;message&#39;</code>事件扮演着核心角色。它允许主线程与工作线程（或者说，工作线程之间）进行通信。每当一个<code>Worker</code>线程通过其<code>postMessage()</code>方法发送消息时，该消息会在目标接收端触发<code>&#39;message&#39;</code>事件。</p><h3 id="如何使用-message-事件" tabindex="-1"><a class="header-anchor" href="#如何使用-message-事件"><span>如何使用 <code>&#39;message&#39;</code> 事件</span></a></h3><p>假设你在编写一个 Node.js 应用，需要处理大量数据排序，这种计算密集型的任务可能会阻塞你的主线程，导致整个应用响应变慢。利用<code>worker_threads</code>，你可以把这项任务分配给一个或多个工作线程处理，而主线程可以继续执行其他任务，比如响应用户输入，保持应用的流畅性。</p><h4 id="步骤-1-创建一个工作线程" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建一个工作线程"><span>步骤 1: 创建一个工作线程</span></a></h4><p>首先，你需要创建一个工作线程来处理数据排序任务。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// sortWorker.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听来自主线程的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 执行排序操作</span></span>\n<span class="line"><span style="color:#D8DEE9;">  data</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">sort</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 将排序后的结果发送回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-从主线程发送数据并监听结果" tabindex="-1"><a class="header-anchor" href="#步骤-2-从主线程发送数据并监听结果"><span>步骤 2: 从主线程发送数据并监听结果</span></a></h4><p>然后，在主线程中，你将发送待排序的数据给工作线程，并监听排序后的结果。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个指向sortWorker.js的Worker实例</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./sortWorker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 发送包含待排序数据的消息给工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">([</span><span style="color:#B48EAD;">3</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 1</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 4</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 1</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 5</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 9</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 2</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 6</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听来自工作线程的消息（即排序后的数据）</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">sortedData</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">排序后的数据: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">sortedData</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程负责初始化工作线程并发送待处理的数据。工作线程接收这些数据，完成排序任务，然后将结果发送回主线线程。这种方式允许主线程在等待排序结果的同时，继续执行其他任务，有效提高了应用的性能和响应能力。</p><h3 id="实际应用场景" tabindex="-1"><a class="header-anchor" href="#实际应用场景"><span>实际应用场景</span></a></h3><ul><li><strong>Web 服务器处理大量请求</strong>：当你的 Node.js Web 服务器需要处理大量并发请求时，比如图像或视频处理、大数据分析等，你可以利用工作线程来分担主线程的负载，提高处理速度。</li><li><strong>实时数据处理</strong>：对于需要实时处理大量数据的应用，例如股票交易平台、在线游戏服务器等，使用工作线程可以优化性能，减少数据处理时间。</li><li><strong>复杂计算</strong>：机器学习、科学计算或任何需要大量计算的情况，都可以通过工作线程来并行处理，加快结果的产出。</li></ul><p>通过合理利用<code>worker_threads</code>模块提供的<code>&#39;message&#39;</code>事件，你可以设计出更高效、响应更快的 Node.js 应用。</p><h3 id="event-messageerror" tabindex="-1"><a class="header-anchor" href="#event-messageerror"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-messageerror" target="_blank" rel="noopener noreferrer">Event: &#39;messageerror&#39;</a></span></a></h3><p>Node.js 中的 <code>Event: &#39;messageerror&#39;</code> 是在 <code>worker_threads</code> 模块中出现的一个事件，这是 Node.js 提供的一个用于实现多线程功能的模块。理解这个概念之前，我们需要先了解一些基础知识。</p><h3 id="什么是-worker-threads-1" tabindex="-1"><a class="header-anchor" href="#什么是-worker-threads-1"><span>什么是 worker_threads？</span></a></h3><p>在 Node.js 中，默认情况下代码是单线程运行的，这意味着你的代码从上到下依次执行，一次只能做一件事情。然而，有时候我们希望能够并行处理多个任务来提高效率，特别是当遇到一些耗时的操作时（比如读写文件、网络请求等）。为了实现这一点，Node.js 提供了 <code>worker_threads</code> 模块，允许我们创建额外的线程来并行执行代码。</p><h3 id="event-messageerror-1" tabindex="-1"><a class="header-anchor" href="#event-messageerror-1"><span>Event: &#39;messageerror&#39;</span></a></h3><p>当你使用 <code>worker_threads</code> 模块创建一个新的线程（称为 Worker）来执行任务时，主线程和 Worker 线程之间可以相互发送消息。<code>&#39;messageerror&#39;</code> 事件就是在主线程向 Worker 发送消息或者 Worker 向主线程发送消息时，如果消息无法被成功接收或者处理，会触发这个事件。</p><h3 id="实际应用例子-2" tabindex="-1"><a class="header-anchor" href="#实际应用例子-2"><span>实际应用例子</span></a></h3><p>假设你在开发一个应用，这个应用需要处理大量的图片。如果在主线程中处理所有图片，可能会导致应用响应变得缓慢。这时，你可以使用 <code>worker_threads</code> 来创建额外的线程去并行处理这些图片。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">收到消息：</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">messageerror</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">error</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">消息错误：</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">error</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">  )</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 向 Worker 线程发送数据，此处模拟发送一个无法在 Worker 中正常解析的数据结构</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">undefined</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">value</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">工作线程接收到的值：</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">value</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">    // 假设这里有对收到的数据进行处理的逻辑</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个 Worker 线程，并尝试通过 <code>postMessage</code> 方法向其发送一个 <code>undefined</code> 值。在 JavaScript 中， <code>undefined</code> 并不是一种可以被结构化克隆算法处理的数据类型，因此当 Worker 尝试接收这个消息时会失败，并且触发 <code>&#39;messageerror&#39;</code> 事件。在这个事件的回调函数中，我们可以对错误进行处理，比如打印错误信息。</p><p>通过这种方式，你可以利用 Node.js 的 <code>worker_threads</code> 模块来实现多线程并行处理任务，同时确保应用的健壮性和错误处理机制得到加强。</p><h3 id="port-close" tabindex="-1"><a class="header-anchor" href="#port-close"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#portclose" target="_blank" rel="noopener noreferrer">port.close()</a></span></a></h3><p>Node.js 是一个非常强大的 JavaScript 运行环境，它让你能在服务器端运行 JavaScript 代码。在 Node.js 中，有一个模块叫作 <code>worker_threads</code>，这个模块允许我们在后台运行 JavaScript 代码，而不会阻塞主线程。这在处理耗时任务时特别有用，比如读取大文件、执行复杂计算等。</p><p><code>worker_threads</code> 模块中的 <code>port.close()</code> 方法是用于关闭 <code>MessagePort</code> 的。<code>MessagePort</code> 是 <code>worker_threads</code> 通信的通道之一，允许主线程与工作线程（或者工作线程之间）进行数据交换。当你决定不再通过这个端口发送或接收消息时，使用 <code>port.close()</code> 可以关闭它，释放资源。</p><h3 id="实际运用例子-3" tabindex="-1"><a class="header-anchor" href="#实际运用例子-3"><span>实际运用例子</span></a></h3><p>想象一个场景：你正在开发一个网站的后端服务，这个服务需要处理一些复杂的数据分析任务，比如用户上传了一个大文件，你需要读取这个文件并进行一系列复杂的分析。</p><p>如果直接在主线程上执行这个任务，那么在文件读取和分析期间，你的服务器将无法响应其他用户的请求——因为它被一个耗时的任务阻塞了。这显然是不可接受的，因此你可以使用 <code>worker_threads</code> 来解决这个问题：</p><ol><li>当用户上传文件时，主线程接收到请求并创建一个新的工作线程来处理文件。</li><li>主线程通过 <code>MessagePort</code> 向工作线程发送包含文件数据的消息，并继续监听其他用户的请求。</li><li>工作线程接收到文件数据，开始执行必要的分析操作。</li><li>一旦工作线程完成任务，它就通过 <code>MessagePort</code> 将结果发送回主线线程。</li><li>主线程接收到结果，通过网络将其发送给用户，并关闭与工作线程的通信端口。</li></ol><p>以下是个简化的代码示范：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 在主线程中</span></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> port</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MessageChannel</span><span style="color:#D8DEE9FF;">()</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">port1</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#D8DEE9;"> port</span><span style="color:#ECEFF4;"> },</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#D8DEE9;">port</span><span style="color:#D8DEE9FF;">])</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received result: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">close</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 关闭端口，任务完成</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ({</span><span style="color:#D8DEE9;"> port</span><span style="color:#ECEFF4;"> })</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">    // 假设这里进行一些复杂的计算</span></span>\n<span class="line"><span style="color:#81A1C1;">    let</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> complexCalculation</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    port</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">close</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 完成后关闭</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们在主线程创建了一个工作线程和一个 <code>MessagePort</code> 用于通信。工作线程完成计算后，通过端口发送结果回主线程，然后主线程接收结果并关闭端口。这样做的好处是主线程可以继续处理其他事情，从而保持应用的响应性。</p><h3 id="port-postmessage-value-transferlist" tabindex="-1"><a class="header-anchor" href="#port-postmessage-value-transferlist"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist" target="_blank" rel="noopener noreferrer">port.postMessage(value[, transferList])</a></span></a></h3><p>理解 <code>port.postMessage(value[, transferList])</code> 这个方法之前，让我们先了解一些基础概念。</p><h3 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念"><span>基础概念</span></a></h3><ol><li><p><strong>Node.js</strong>: Node.js 是一个能够在服务器端运行 JavaScript 的平台。它让 JavaScript 能够进行文件操作、网络通信等后端任务。</p></li><li><p><strong>Worker Threads (工作线程)</strong>: 在 Node.js 中，由于 JavaScript 本身是单线程的，为了充分利用多核 CPU 的计算能力，Node.js 提供了 Worker Threads。这使得你可以创建多个线程来并行执行代码。</p></li><li><p><strong>Message Passing (消息传递)</strong>: 工作线程之间并不能直接共享内存（除非使用 SharedArrayBuffer），因此它们通过消息传递来互相通信。每个线程都有一个消息端口（<code>MessagePort</code>），可以通过这个端口发送消息给其他线程。</p></li></ol><p>现在，了解了这些背景信息，我们来深入 <code>port.postMessage(value[, transferList])</code>。</p><h3 id="解析-port-postmessage-value-transferlist" tabindex="-1"><a class="header-anchor" href="#解析-port-postmessage-value-transferlist"><span>解析 <code>port.postMessage(value[, transferList])</code></span></a></h3><p>这个方法允许你通过一个 Worker 线程的端口发送消息给另一个线程。这里的 &quot;端口&quot; (<code>port</code>) 是指 <code>MessagePort</code> 对象，它提供了在 Worker 线程之间通信的通道。</p><ul><li><p><strong>value</strong>: 这是要发送的消息内容。它可以是任何可序列化的 JavaScript 值，包括对象、数组等。</p></li><li><p><strong>transferList</strong> （可选）: 如果你想要将某些资源（如 <code>ArrayBuffer</code>） &quot;转移&quot; 给接收线程（这样发送线程就无法再访问它），可以将这些资源放在 <code>transferList</code> 数组中。转移操作会使数据传输更高效，因为它避免了复制数据的开销。</p></li></ul><h3 id="实际应用例子-3" tabindex="-1"><a class="header-anchor" href="#实际应用例子-3"><span>实际应用例子</span></a></h3><p>假设你正在开发一个应用程序，需要在后台进行一些密集型的数据处理任务，而不影响主线程的性能。你决定使用 Worker Threads 来并行处理这些任务。</p><h4 id="步骤-1-创建一个工作线程-1" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建一个工作线程-1"><span>步骤 1: 创建一个工作线程</span></a></h4><p>首先，你需要创建一个新的 Worker 线程。假设你有一个名为 <code>dataProcessor.js</code> 的脚本，专门用于处理数据。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// main.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./dataProcessor.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-使用-postmessage-发送数据到工作线程" tabindex="-1"><a class="header-anchor" href="#步骤-2-使用-postmessage-发送数据到工作线程"><span>步骤 2: 使用 <code>postMessage</code> 发送数据到工作线程</span></a></h4><p>然后，你想要发送一些数据到这个工作线程去处理。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// main.js</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> data</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">这里是要处理的数据</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-3-在工作线程中接收和处理数据" tabindex="-1"><a class="header-anchor" href="#步骤-3-在工作线程中接收和处理数据"><span>步骤 3: 在工作线程中接收和处理数据</span></a></h4><p>在 <code>dataProcessor.js</code> 文件中，你将监听 <code>message</code> 事件来接收主线程发送的数据，并进行处理。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// dataProcessor.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">接收到数据:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> message</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 进行一些处理...</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用 <code>postMessage</code> 方法和工作线程，你可以有效地在后台处理复杂任务，而不会阻塞或减慢主线程的执行。</p><p>希望这个解释和示例使你对 <code>port.postMessage(value[, transferList])</code> 以及其在 Node.js 中的应用有了清晰的理解！</p><h4 id="considerations-when-transferring-typedarrays-and-buffers" tabindex="-1"><a class="header-anchor" href="#considerations-when-transferring-typedarrays-and-buffers"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#considerations-when-transferring-typedarrays-and-buffers" target="_blank" rel="noopener noreferrer">Considerations when transferring TypedArrays and Buffers</a></span></a></h4><p>Node.js 中的 <code>worker_threads</code> 模块允许你运行 JavaScript 代码在工作线程中，这样可以有效利用多核 CPU 的能力来提高应用程序的性能。当你在主线程和工作线程之间传递数据时，特别是大量数据，理解如何有效地传输这些数据变得非常重要。</p><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h3><p>JavaScript 中的 <code>TypedArray</code> 和 <code>Buffer</code> 是处理二进制数据的结构。<code>TypedArray</code> 是一个泛化的概念，包括例如 <code>Uint8Array</code>, <code>Int16Array</code> 等类型，专门用于处理不同的数字类型。而 <code>Buffer</code> 类是 Node.js 特有的，用于处理二进制数据流，常见于文件读写、网络数据传输等场景。</p><h3 id="传输-vs-共享" tabindex="-1"><a class="header-anchor" href="#传输-vs-共享"><span>传输 VS. 共享</span></a></h3><p>当你在主线程和工作线程之间传递 <code>TypedArrays</code> 或 <code>Buffers</code> 时，你有两种方式：<strong>传输（Transfer）<strong>或</strong>共享（Shared）</strong>。</p><ul><li><p><strong>传输（Transfer）</strong>: 当你传输一个 <code>Buffer</code> 或 <code>TypedArray</code> 到另一个线程时，它实际上将那块内存的所有权从一个线程转移到了另一个线程。这意味着一旦传输完成，原线程中的那个 <code>Buffer</code> 或 <code>TypedArray</code> 将变得不再可用，因为它的内容已经被移动到了新线程。</p><p>这种方法的好处是效率极高，因为它避免了复制数据带来的开销。这对于需要处理大量数据并且关注性能的场景非常有用。</p></li><li><p><strong>共享（Shared）</strong>: 另一种选择是使用 <code>SharedArrayBuffer</code>，它允许在不同的工作线程之间共享内存。这意味着多个线程可以同时读写相同的内存区域，但这也引入了必须通过某种形式的同步机制来管理访问冲突的复杂性。</p><p>共享内存可能对于某些需要高度协作的线程之间的数据交换场景更为合适，但它通常需要更细致的控制来避免问题。</p></li></ul><h3 id="实际应用例子-4" tabindex="-1"><a class="header-anchor" href="#实际应用例子-4"><span>实际应用例子</span></a></h3><ol><li><p><strong>图像处理</strong>: 假设你正在编写一个服务，需要对上传的图片进行处理。你可以创建工作线程来处理图像数据（转换格式、调整大小、添加滤镜等）。在这种情况下，如果每张图片都较大，使用传输而非克隆（复制）图像数据到工作线程会更高效。</p></li><li><p><strong>数据分析</strong>: 如果你的应用需要对大量数值数据进行复杂计算，如统计分析或机器学习预处理，你可以将这些数据作为 <code>TypedArrays</code> 传输到工作线程进行计算。通过传输而不是共享内存，你可以确保每个线程独立处理数据片段，从而避免同步的开销。</p></li><li><p><strong>实时游戏服务器</strong>: 对于一个需要处理大量用户状态和实时交互的游戏服务器，使用 <code>SharedArrayBuffer</code> 共享玩家状态和游戏数据可能更加合适。这样，不同的工作线程可以在处理用户请求的同时，实时更新和读取游戏状态，但需要注意适当的同步策略以防止数据冲突。</p></li></ol><h3 id="结论-1" tabindex="-1"><a class="header-anchor" href="#结论-1"><span>结论</span></a></h3><p>选择传输还是共享取决于具体的应用场景和性能需求。传输是高效的，适用于“一次性”处理大量数据的场景。而共享则适用于需要高度交互和协作处理数据的复杂应用场景，但管理起来更复杂。理解这两种方法及其适用情况可以帮助你设计出更高效、更可靠的多线程应用程序。</p><h4 id="considerations-when-cloning-objects-with-prototypes-classes-and-accessors" tabindex="-1"><a class="header-anchor" href="#considerations-when-cloning-objects-with-prototypes-classes-and-accessors"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#considerations-when-cloning-objects-with-prototypes-classes-and-accessors" target="_blank" rel="noopener noreferrer">Considerations when cloning objects with prototypes, classes, and accessors</a></span></a></h4><p>在 Node.js 中，有一个功能叫做 Worker Threads（工作线程），它允许你运行 JavaScript 代码在后台的独立线程中。这对于执行耗时任务特别有用，因为它可以避免阻塞主线程，从而保持应用程序的响应性。</p><p>当你在主线程和工作线程之间传递数据时，Node.js 使用一种称为结构化克隆算法来复制这些数据。这个过程通常很直接，但当你试图克隆带有原型、类实例或访问器属性（getter/setter）的对象时，就需要格外注意了。这就是 Node.js v21.7.1 文档中提到的“Considerations when cloning objects with prototypes, classes, and accessors”。</p><h3 id="原型和类实例" tabindex="-1"><a class="header-anchor" href="#原型和类实例"><span>原型和类实例</span></a></h3><p>在 JavaScript 中，几乎所有的对象都是通过构造函数或者类创建的，并且它们都有一个原型（prototype）。原型是一个对象，其他对象可以继承这个对象的属性和方法。</p><p>例如，假设我们有一个简单的<code>Person</code>类：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">class</span><span style="color:#8FBCBB;"> Person</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  constructor</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">name</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">name</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> name</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">  greet</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Hello, my name is </span><span style="color:#81A1C1;">${</span><span style="color:#81A1C1;">this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">name</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">!</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们创建一个<code>Person</code>的实例并尝试通过结构化克隆算法将其传递给工作线程，该实例的方法（如<code>greet</code>）不会被复制。这是因为结构化克隆只能复制数据，而不能复制函数或原型链。</p><h3 id="访问器属性-getter-setter" tabindex="-1"><a class="header-anchor" href="#访问器属性-getter-setter"><span>访问器属性（Getter/Setter）</span></a></h3><p>访问器属性是用<code>get</code>和<code>set</code>关键词定义的属性，它们允许你在读取或写入属性时执行代码。</p><p>例如，考虑下面这个带有访问器属性的对象：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> person</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">  firstName</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">John</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#88C0D0;">  lastName</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">Doe</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#81A1C1;">  get</span><span style="color:#88C0D0;"> fullName</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    return</span><span style="color:#ECEFF4;"> `</span><span style="color:#81A1C1;">${</span><span style="color:#81A1C1;">this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">firstName</span><span style="color:#81A1C1;">}</span><span style="color:#81A1C1;"> ${</span><span style="color:#81A1C1;">this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">lastName</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  },</span></span>\n<span class="line"><span style="color:#81A1C1;">  set</span><span style="color:#88C0D0;"> fullName</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">name</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">    [</span><span style="color:#81A1C1;">this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">firstName</span><span style="color:#ECEFF4;">,</span><span style="color:#81A1C1;"> this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">lastName</span><span style="color:#D8DEE9FF;">] </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9;"> name</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">split</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  },</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你尝试通过结构化克隆算法克隆这个对象，访问器属性（<code>fullName</code>）将会被转换为普通属性，失去其特殊的 getter 和 setter 功能。</p><h3 id="实际运用的例子-4" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-4"><span>实际运用的例子</span></a></h3><p>假设你正在开发一个 Node.js 应用，需要在一个工作线程中处理一批用户数据。每个用户都是一个<code>User</code>类的实例，包含一些基本信息和一些方法来操作这些信息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">class</span><span style="color:#8FBCBB;"> User</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  constructor</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">id</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> name</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">id</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> id</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">    this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">name</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> name</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">  sayHello</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Hello, my name is </span><span style="color:#81A1C1;">${</span><span style="color:#81A1C1;">this</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">name</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你想在一个工作线程中处理这批用户数据时，如果你直接传递<code>User</code>实例，那么在工作线程中你将无法调用<code>sayHello</code>方法，因为这个方法不会被结构化克隆算法复制。</p><p>解决方案是在传输之前将对象转换为一个可以被完整复制的格式，如纯粹的数据对象或 JSON 字符串，并在接收方重新构建原始对象。</p><h3 id="结论-2" tabindex="-1"><a class="header-anchor" href="#结论-2"><span>结论</span></a></h3><p>当使用 Node.js 工作线程并需要在它们之间传递复杂对象时，理解结构化克隆算法的限制非常重要。意识到原型、类实例和访问器属性可能不会按预期被克隆，可以帮助你设计出更健壮、可靠的多线程 Node.js 应用。</p><h3 id="port-hasref" tabindex="-1"><a class="header-anchor" href="#port-hasref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#porthasref" target="_blank" rel="noopener noreferrer">port.hasRef()</a></span></a></h3><p>当你开始使用 Node.js 进行编程时，你可能会遇到一种情况，即你的程序需要执行多个任务，而这些任务可能很耗时，例如读取大文件、进行复杂计算或者处理网络请求。在这种情况下，你可以使用 Node.js 的<code>worker_threads</code>模块来创建额外的线程。这样，你就可以将耗时的任务分配给这些额外的线程去处理，从而不会阻塞（停滞不前）你的主线程，让你的应用程序能够继续接受和处理新的用户请求。</p><p>在使用<code>worker_threads</code>模块时，主线程与工作线程之间会通过一个内置的通信渠道进行数据交换，这个通信渠道就是<code>MessagePort</code>。每当你使用<code>worker_threads</code>模块创建一个新的工作线程时，都会为你提供一个<code>MessagePort</code>实例，以便你能够发送消息至工作线程，或者接收来自工作线程的消息。</p><p>现在，让我们谈谈<code>port.hasRef()</code>这个方法，并结合一些实际的例子来加深理解。</p><h3 id="port-hasref-1" tabindex="-1"><a class="header-anchor" href="#port-hasref-1"><span>port.hasRef()</span></a></h3><p><code>port.hasRef()</code>是<code>MessagePort</code>的一个方法，它允许你检查一个端口（<code>MessagePort</code>实例）是否被引用。在 Node.js 中，如果一个对象被引用，意味着它仍然处于活动状态，不会被垃圾回收机制回收。在多线程编程中，了解哪些资源是&quot;存活&quot;的非常重要，因为这直接影响着程序的性能和行为。</p><p>简单来说，如果<code>port.hasRef()</code>返回<code>true</code>，则表示该端口目前被引用（激活状态），事件循环会保持运行状态直到此端口不再被引用。如果返回<code>false</code>，则表示该端口当前没有被引用，也就是说，在当前的工作流中，该端口不会阻止 Node.js 进程退出。</p><h4 id="实际应用示例-4" tabindex="-1"><a class="header-anchor" href="#实际应用示例-4"><span>实际应用示例</span></a></h4><ol><li><p><strong>多任务处理</strong>：假设你正在构建一个 Web 服务器，需要同时处理多个数据密集型任务。你可以为每项任务创建一个工作线程，并通过<code>MessagePort</code>与之通信。使用<code>port.hasRef()</code>，你可以监控特定的端口是否仍然被引用（即任务是否正在进行），基于这些信息，你可以决定是否向客户端发送任务完成的通知，或者管理工作线程的生命周期，比如重用或关闭未被引用的端口。</p></li><li><p><strong>资源管理</strong>：在一个复杂的应用程序中，合理管理系统资源非常关键。通过使用<code>port.hasRef()</code>，开发者可以编写逻辑来检测哪些端口没有被引用，这对于释放那些不再需要的资源，避免内存泄漏非常有帮助。</p></li><li><p><strong>负载平衡</strong>：在处理大量并发请求时，你可能会创建多个工作线程来分摊负载。通过检查各个<code>MessagePort</code>的引用状态（使用<code>port.hasRef()</code>），你可以更智能地分配任务给那些不太忙碌的线程，从而提高整体的处理效率和响应速度。</p></li></ol><p>总结起来，<code>port.hasRef()</code>方法在 Node.js 的多线程编程中扮演着一个小但重要的角色，它帮助开发者更好地理解和控制程序的行为和资源管理。通过上述的几个例子，我希望你能够明白如何在实践中应用这一概念。</p><h3 id="port-ref" tabindex="-1"><a class="header-anchor" href="#port-ref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#portref" target="_blank" rel="noopener noreferrer">port.ref()</a></span></a></h3><p>Node.js 在多线程编程中提供了一个模块叫做 <code>worker_threads</code>。这个模块允许你在主 Node.js 进程之外运行 JavaScript 代码，从而执行一些计算密集型的任务或是其他不想阻塞事件循环的操作。</p><p>在这个模块中，<code>MessagePort</code> 是一个允许主线程与工作线程（worker threads）之间相互通信的对象。每当你创建一个新的工作线程时，你会得到一个与该线程通信的 <code>MessagePort</code> 对象。</p><p>现在，谈谈 <code>port.ref()</code> 方法的作用：</p><p>默认情况下，如果还有活跃的工作线程（也就是说，与之相关的 <code>MessagePort</code> 对象是 &quot;引用的&quot; 状态），Node.js 的事件循环会保持运行状态，即使没有其他活动（例如网络请求或者定时器）。这确保了只要还有工作线程在运行，主进程就不会退出。</p><p>但是，在某些情况下，你可能想要允许程序退出，即使还有工作线程在运行。这时，你可以使用 <code>port.unref()</code> 让 Node.js 的事件循环忽略这个工作线程，从而允许程序在主线程完成后直接退出，即使有工作线程尚未完成其任务。</p><p>相反地，如果你之前调用了 <code>port.unref()</code>，但后来决定你希望主程序等待这个工作线程完成，你可以通过调用 <code>port.ref()</code> 来重新引用这个端口。这样做会告诉 Node.js 的事件循环重新考虑这个工作线程，防止程序在此工作线程完成之前退出。</p><h3 id="实际应用示例-5" tabindex="-1"><a class="header-anchor" href="#实际应用示例-5"><span>实际应用示例</span></a></h3><p>假设你正在开发一个 Web 服务器，它在启动时需要载入一些大数据集到内存中。这是一个计算密集型的任务，可能需要几秒钟时间，所以你决定将这个任务放在一个工作线程中执行，以避免阻塞主线程。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">parentPort</span><span style="color:#81A1C1;"> ===</span><span style="color:#81A1C1;"> null</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 假设我们希望在数据载入完成前服务器能够开始处理请求，</span></span>\n<span class="line"><span style="color:#616E88;">  // 但是在所有数据载入完成前禁止服务器关闭。</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">ref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 其他服务器启动代码...</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 工作线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">parentPort</span><span style="color:#81A1C1;"> !==</span><span style="color:#81A1C1;"> null</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 执行数据载入操作...</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 告诉主线程数据已经载入完成</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Data loaded</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，使用 <code>worker.ref()</code> 确保了主服务器进程不会在数据加载任务完成前退出。这对于确保应用的正确初始化非常有用。</p><h3 id="port-start" tabindex="-1"><a class="header-anchor" href="#port-start"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#portstart" target="_blank" rel="noopener noreferrer">port.start()</a></span></a></h3><p>Node.js 是一个强大的 JavaScript 运行环境，它允许你在服务器端执行 JavaScript 代码。<strong><code>worker_threads</code></strong> 模块是 Node.js 中用于处理多线程的工具，而 <code>port.start()</code> 方法则是这个模块中很有用的一部分。</p><h3 id="理解-port-start" tabindex="-1"><a class="header-anchor" href="#理解-port-start"><span>理解 <code>port.start()</code></span></a></h3><p>在 Node.js 的 <code>worker_threads</code> 模块中，<strong><code>MessagePort</code></strong> 是进行线程间通信的关键对象。当你创建一个新的工作线程（worker thread）时，父线程和子线程之间会通过一个**<code>MessageChannel</code><strong>建立联系，该</strong><code>MessageChannel</code><strong>包含两个</strong><code>MessagePort</code>** 对象，分别用于双向通信。</p><p>通常情况下，当你从主线程向子线程发送消息或者反过来时，消息传递是自动开始的。但有些情况下，你可能希望手动控制这个过程，这就是 <code>port.start()</code> 发挥作用的地方。</p><h3 id="使用-port-start" tabindex="-1"><a class="header-anchor" href="#使用-port-start"><span>使用 <code>port.start()</code></span></a></h3><p>调用 <code>port.start()</code> 方法后，将启动 <strong><code>MessagePort</code></strong> 上的消息队列处理。如果你在接收端（无论是父线程还是子线程）没有显式调用这个方法，那么消息会被排队等待，直到这个方法被调用。</p><h3 id="实际应用示例-6" tabindex="-1"><a class="header-anchor" href="#实际应用示例-6"><span>实际应用示例</span></a></h3><p>假设你正在开发一个 Node.js 应用，需要进行图像处理操作，这是一个计算密集型任务，使用工作线程可以避免阻塞主线程。</p><ol><li><strong>创建工作线程：</strong></li></ol><p>首先，你需要创建一个工作线程来处理图像。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">收到消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">开始处理图像</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">工作线程接收到消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">    // 假设这里进行某种图像处理...</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">图像处理完成</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们没有直接使用 <code>port.start()</code>，因为默认情况下消息传递是自动开始的。</p><ol start="2"><li><strong>手动启动消息队列处理：</strong></li></ol><p>如果出于某种原因，你希望延迟工作线程对消息的处理，那么你可以显式调用 <code>port.start()</code>。</p><p>修改工作线程中的代码如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">工作线程接收到首条消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 在处理第一条消息后，启动消息处理</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">start</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使得工作线程在接收到第一条消息并处理之后，再开始处理后续的消息队列。这样的控制可以让你根据实际需求更灵活地处理消息。</p><h3 id="总结-7" tabindex="-1"><a class="header-anchor" href="#总结-7"><span>总结</span></a></h3><p><code>port.start()</code> 在 Node.js 的 <code>worker_threads</code> 模块中用于手动开始处理通过 <strong><code>MessagePort</code></strong> 接收到的消息队列。虽然在许多情况下，消息传递会自动开始，但在需要精细控制消息处理时刻的场景下，<code>port.start()</code> 提供了必要的功能支持。通过利用工作线程，Node.js 应用可以有效地进行资源密集型或耗时较长的任务处理，而不会阻塞主线程，保持应用的响应性和性能。</p><h3 id="port-unref" tabindex="-1"><a class="header-anchor" href="#port-unref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#portunref" target="_blank" rel="noopener noreferrer">port.unref()</a></span></a></h3><p>好的，让我来详细地解释一下 Node.js 中的 <code>port.unref()</code> 方法，尤其是在 v21.7.1 版本中的用法和实际应用场景。</p><p>首先，要理解 <code>port.unref()</code>，我们需要知道它与 Node.js 中的 <code>worker_threads</code> 模块有关。这个模块允许 Node.js 运行中的脚本创建新的线程，以执行任务，而不会阻塞主线程。使用 <code>worker_threads</code> 模块时，可以创建一个 <code>Worker</code> 来运行另一个脚本文件，在这种情况下，主线程和工作线程之间可以通过一个叫做 <code>MessageChannel</code> 的对象进行通信，而 <code>MessageChannel</code> 包含两个 <code>MessagePort</code> 对象来实现双向通信。</p><p>在这里，<code>port.unref()</code> 方法就派上了用场。这个方法属于 <code>MessagePort</code> 对象。</p><h3 id="什么是-port-unref" tabindex="-1"><a class="header-anchor" href="#什么是-port-unref"><span>什么是 <code>port.unref()</code>?</span></a></h3><p>简单来说，当你调用 <code>port.unref()</code> 时，你告诉 Node.js 的事件循环（Event Loop）如果这个 <code>MessagePort</code> 是唯一剩余的工作项，那么它可以退出程序。这意味着，如果除了这个 <code>MessagePort</code> 外没有其他定时器、请求、任务等待处理，Node.js 进程可以干净地结束，即使 <code>MessagePort</code> 仍然开着。</p><h3 id="实际运用的例子-5" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-5"><span>实际运用的例子</span></a></h3><h4 id="示例-1-简单的工作线程通信" tabindex="-1"><a class="header-anchor" href="#示例-1-简单的工作线程通信"><span>示例 1: 简单的工作线程通信</span></a></h4><p>假设你有一个简单的任务，比如读取一个大文件或者计算一些复杂的数据，这项任务被放在一个独立的工作线程中以避免阻塞主线程。在这种情况下，主线程和工作线程会通过 <code>MessageChannel</code> 的端口进行通信。当工作完毕，而你又不希望 Node.js 进程仅因为这个通信端口还开着就不退出时，你可以在适当时候调用 <code>port.unref()</code>。这样，一旦其他任务都完成了，即使这个端口还在，Node.js 进程也会退出。</p><h4 id="示例-2-定期更新数据" tabindex="-1"><a class="header-anchor" href="#示例-2-定期更新数据"><span>示例 2: 定期更新数据</span></a></h4><p>想象一个后台服务的场景，这个服务定期从互联网获取最新数据，但大部分时间处于空闲状态。你可能会使用工作线程来处理数据获取和更新操作，以避免阻塞主服务。在这种案例中，每当工作线程启动时，你可能不希望仅因为这个更新操作的通信端口打开，就让整个服务不能优雅地结束。使用 <code>port.unref()</code> 可以确保，一旦需要关闭服务（比如接收到停止信号），Node.js 进程可以无视仍然开放的通信端口而正常退出。</p><h3 id="总结-8" tabindex="-1"><a class="header-anchor" href="#总结-8"><span>总结</span></a></h3><p><code>port.unref()</code> 在 Node.js 的多线程编程中是一个非常有用的方法。通过允许 Node.js 进程在没有其他活动（除了打开的 <code>MessagePort</code>）时退出，它有助于资源管理和提高应用的健壮性。无论是运行一次性的背景任务还是构建复杂的后台服务，理解并合理应用 <code>port.unref()</code> 都是提升 Node.js 应用性能和用户体验的有效手段。</p><h2 id="class-worker" tabindex="-1"><a class="header-anchor" href="#class-worker"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#class-worker" target="_blank" rel="noopener noreferrer">Class: Worker</a></span></a></h2><p>Node.js 中的 <code>Worker</code> 类是属于 <code>worker_threads</code> 模块的一部分。这个模块允许你在 Node.js 应用程序中运行 JavaScript 代码在多个线程中，这在过去是做不到的，因为 JavaScript 和 Node.js 都是设计成单线程运行的。使用 <code>Worker</code> 类，你可以创建新的工作线程来执行复杂或耗时的任务，而不会阻塞主线程。</p><h3 id="如何工作-1" tabindex="-1"><a class="header-anchor" href="#如何工作-1"><span>如何工作？</span></a></h3><p>当你使用 <code>Worker</code> 类创建一个新的工作线程（即 worker）时，你需要提供一个脚本路径（JavaScript 文件），这个脚本将在新的线程中执行。这意味着主线程和工作线程将并行运行，他们可以通过消息传递相互通信。</p><h3 id="基本用法示例" tabindex="-1"><a class="header-anchor" href="#基本用法示例"><span>基本用法示例：</span></a></h3><p>假设有一个计算密集型任务，例如计算斐波那契数列的第 N 项。在不使用 <code>Worker</code> 的情况下，当你执行这种复杂计算时，整个服务器可能会变得无响应。但使用 <code>Worker</code>, 你可以将该任务放在后台线程中执行，这样主线程就可以继续处理其他事务，如响应用户请求。</p><ol><li><strong>创建 Worker</strong></li></ol><p>首先，创建一个名为 <code>fibonacci.js</code> 的文件，这个文件将包含计算斐波那契数列的函数，并且它会作为工作线程运行。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// fibonacci.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#B48EAD;"> 2</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9;"> n</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">    return</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;"> -</span><span style="color:#B48EAD;"> 1</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">+</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;"> -</span><span style="color:#B48EAD;"> 2</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#88C0D0;">fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，你可以在主脚本中创建一个 <code>Worker</code> 来运行上述脚本。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// main.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">//拉丁文：Auctor QQ:3255927970</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./fibonacci.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Fibonacci result: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">10</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 发送 N 的值给工作线程</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>main.js</code> 创建了一个工作线程来执行 <code>fibonacci.js</code>。<code>fibonacci.js</code> 里的代码定义了一个计算斐波那契数列的函数，并监听从主线程发送过来的消息（也就是要计算的数列项 <code>n</code>）。一旦接收到 <code>n</code>，它就计算出结果并将结果发送回主线程。</p><h3 id="实际应用场景-1" tabindex="-1"><a class="header-anchor" href="#实际应用场景-1"><span>实际应用场景</span></a></h3><ol><li><p><strong>数据处理：</strong> 如果你的应用程序需要处理大量数据，例如图像或视频处理，机器学习计算等，你可以使用 <code>Worker</code> 来并行处理这些任务，以提高效率。</p></li><li><p><strong>API 请求汇总：</strong> 当你的服务器需要向多个不同的服务发起 API 请求，然后汇总所有结果时，可以为每个请求分配一个 <code>Worker</code>，从而并行进行所有请求，显著减少总的响应时间。</p></li><li><p><strong>实时数据处理：</strong> 对于需要实时处理大量动态数据的应用程序（比如股票交易平台），使用 <code>Worker</code> 可以帮助你在不影响用户体验的情况下，快速完成数据的计算和分析。</p></li></ol><p>通过在 Node.js 中合理利用 <code>Worker</code> 类和 <code>worker_threads</code> 模块，你可以有效地克服 JavaScript 单线程的限制，开发出性能更好、响应更快的应用程序。</p><h3 id="new-worker-filename-options" tabindex="-1"><a class="header-anchor" href="#new-worker-filename-options"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options" target="_blank" rel="noopener noreferrer">new Worker(filename[, options])</a></span></a></h3><p>Node.js 的 <code>Worker</code> 线程是一种强大的特性，它允许你在后台执行 JavaScript 代码而不会阻塞主线程。这非常有用，尤其当你需要处理一些密集、耗时的计算任务时，可以把这些任务放到一个或多个 Worker 线程中去执行，从而不会影响到主线程的响应速度和用户体验。</p><p>简单来说，<code>new Worker(filename[, options])</code> 是用来创建一个新的 Worker 线程的方法。接下来我将通过一些基本概念和实际例子来详细解释这个功能。</p><h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1"><span>基本概念</span></a></h3><ul><li><strong>filename</strong>：这是你想要在 Worker 线程中运行的脚本文件的路径。Node.js 会在新的 Worker 纑程中加载并执行这个文件。</li><li><strong>options</strong>：这是一个可选参数，里面包含了一些配置项，比如你可能会设置 Worker 线程的一些初始化数据，或者是否启用 <code>workerData</code> 功能等。</li></ul><h3 id="实际例子-1" tabindex="-1"><a class="header-anchor" href="#实际例子-1"><span>实际例子</span></a></h3><p>假设你正在开发一个网站后端服务，这个服务需要处理大量的图片压缩。由于图片压缩是一个计算密集型任务，如果在主线程中进行处理，那么服务器响应其他请求的能力将大大降低。这个时候，你就可以利用 Worker 线程来优化。</p><p>首先，创建一个名为 <code>compress.js</code> 的文件，这个文件将包含压缩图片的代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">image</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这里是图片压缩的逻辑</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">开始压缩图片: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">image</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设压缩完成后发送一个消息回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">图片压缩完成: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">image</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，在你的主程序中，使用 <code>new Worker()</code> 来创建一个 Worker 线程，并向它发送要压缩的图片信息：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个 Worker 线程来处理图片压缩</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./compress.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 向 Worker 发送要处理的图片</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">example.png</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听 Worker 发送回来的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">msg</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 输出：图片压缩完成: example.png</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，主线程就可以继续执行其他任务，比如处理更多的网络请求，而不会被图片压缩这样的繁重任务所阻塞。当 Worker 线程完成图片压缩任务后，它会发送一个消息回主线程，你可以根据这个消息来更新用户界面或者是执行其他逻辑。</p><p>总之，通过使用 Node.js 的 Worker 线程，你可以极大地提高应用程序的性能和响应速度，尤其是在涉及到密集型计算任务时。</p><h3 id="event-error" tabindex="-1"><a class="header-anchor" href="#event-error"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-error" target="_blank" rel="noopener noreferrer">Event: &#39;error&#39;</a></span></a></h3><p>Node.js 是一个让 JavaScript 运行在服务器端的平台，它可以用来开发各种网络应用。在 Node.js 中，有许多内置模块和事件，而 <code>worker_threads</code> 模块是其中之一，它允许你在单独的线程中运行 JavaScript 代码，这对于执行耗时任务特别有帮助，因为它们不会阻塞你的主线程。</p><p>在 <code>worker_threads</code> 模块中，有一个特别重要的事件叫做 <code>&#39;error&#39;</code>。当你在 worker 线程中运行的代码遇到错误时，这个 <code>&#39;error&#39;</code> 事件就会被触发。监听并处理这个事件对于开发稳健的多线程应用非常关键，它可以帮助你捕获和处理异步操作过程中可能发生的错误，从而避免程序崩溃。</p><h3 id="例子解释" tabindex="-1"><a class="header-anchor" href="#例子解释"><span>例子解释</span></a></h3><p>让我们通过一个简单的例子来理解这个概念：</p><p>假设你正在构建一个网络应用，这个应用需要处理大量的数据，例如生成报告或进行复杂的数学计算。如果你把这些任务放在主线程上执行，那么整个服务器就会变得缓慢，因为主线程会被占用，直到这些耗时任务完成。这就是为什么我们使用 worker 线程的原因。</p><p>首先，你需要在你的应用中引入 <code>worker_threads</code> 模块：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，你可以创建一个新的 worker 来执行耗时任务。让我们看一下如何在这个 worker 中监听错误：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在主线程中运行</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 监听 worker 中的 &#39;error&#39; 事件</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">error</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker 发生了错误:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> error</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这部分代码在 worker 线程中运行</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 人为制造一个错误</span></span>\n<span class="line"><span style="color:#81A1C1;">  throw</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">哦，出错啦!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先检查当前代码是否在主线程中运行。如果是，我们创建一个新的 <code>Worker</code> 实例，并且监听这个 worker 的 <code>&#39;error&#39;</code> 事件。在 worker 线程中，我们故意抛出一个错误。当这个错误发生时，它将会触发主线程中的 <code>&#39;error&#39;</code> 事件监听器，打印出错误信息。这样，即使在 worker 线程中发生了错误，你也可以在主线程中捕获到这个错误，采取相应的错误处理措施，比如记录错误日志或者重试任务，这样可以保证你的应用更加健壮和可靠。</p><p>通过使用这种模式，你可以有效地利用 Node.js 的多线程能力，同时确保你的应用在面对错误时能够优雅地恢复。</p><h3 id="event-exit" tabindex="-1"><a class="header-anchor" href="#event-exit"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-exit" target="_blank" rel="noopener noreferrer">Event: &#39;exit&#39;</a></span></a></h3><p>Node.js 是一个非常强大的 JavaScript 运行环境，它使得我们可以使用 JavaScript 来编写服务器端代码，也就是说你可以用 JavaScript 来做很多以前只能用 PHP、Python 或者 Ruby 等语言完成的工作。在 Node.js 中，有一种叫做 &quot;Worker Threads&quot; 的功能，它允许你运行耗时的任务而不会阻塞主线程。这对于提高应用程序的性能和响应速度非常有帮助。</p><h3 id="什么是-event-exit" tabindex="-1"><a class="header-anchor" href="#什么是-event-exit"><span>什么是 Event: &#39;exit&#39;？</span></a></h3><p>在 Node.js 的 <code>worker_threads</code> 模块中，<code>&#39;exit&#39;</code> 事件是一个特殊的事件，它会在 Worker 线程退出时触发。每个 Worker 线程都代表了一个独立的执行环境，在这个环境里你可以执行 JavaScript 代码。当这个线程完成它的任务，或者通过某种方式被终止（比如调用 <code>terminate()</code> 方法）时，它就会退出，并触发 <code>&#39;exit&#39;</code> 事件。</p><h3 id="为什么需要关注-exit-事件" tabindex="-1"><a class="header-anchor" href="#为什么需要关注-exit-事件"><span>为什么需要关注 &#39;exit&#39; 事件？</span></a></h3><p>监听 <code>&#39;exit&#39;</code> 事件可以让你知道 Worker 线程何时完成了它的工作或是否因为某些原因被意外终止。这对于资源清理、错误处理或者启动新的 Worker 线程来替代已经终止的线程等场景非常有用。</p><h3 id="如何使用-exit-事件" tabindex="-1"><a class="header-anchor" href="#如何使用-exit-事件"><span>如何使用 &#39;exit&#39; 事件？</span></a></h3><p>首先，你需要引入 Node.js 的 <code>worker_threads</code> 模块。然后，创建一个 Worker 线程，并监听它的 <code>&#39;exit&#39;</code> 事件：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个 Worker 线程并执行一个脚本</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./path/to/your/script.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听 &#39;exit&#39; 事件</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker exited with code </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，当 Worker 线程退出时，会打印出退出的状态码。状态码通常是一个数字，0 表示成功完成，非 0 值表示出现了某种错误或异常情况。</p><h3 id="实际运用的例子-6" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-6"><span>实际运用的例子</span></a></h3><ol><li><p><strong>并发处理数据</strong>：假设你有一个需要进行复杂计算的任务，比如图像处理或大量数据的分析。你可以将这个任务分成几部分，每部分用一个 Worker 线程来处理。当每个 Worker 完成它的任务并退出时，你可以收集结果并合并。</p></li><li><p><strong>Web 服务器背景任务</strong>：在一个 Web 应用中，可能需要在后台执行一些耗时的操作，比如发送大批量邮件或进行数据库维护。这些任务可以交给 Worker 线程来做，这样即使这些任务需要较长时间，也不会影响到主服务器的响应能力。</p></li></ol><p>通过这种方式，<code>&#39;exit&#39;</code> 事件成为了管理 Worker 线程生命周期和确保资源被适当管理的重要手段。希望这能帮助你理解 <code>worker_threads</code> 模块中的 <code>&#39;exit&#39;</code> 事件及其用法。</p><h3 id="event-message-1" tabindex="-1"><a class="header-anchor" href="#event-message-1"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-message_1" target="_blank" rel="noopener noreferrer">Event: &#39;message&#39;</a></span></a></h3><p>了解 Node.js 中的<code>Event: &#39;message&#39;</code>，我们首先要搞清楚几个关键点：Node.js、事件（Events）、工作线程（Worker Threads）以及消息传递。</p><h3 id="node-js-简介-1" tabindex="-1"><a class="header-anchor" href="#node-js-简介-1"><span>Node.js 简介</span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它使得开发者可以使用 JavaScript 开发服务器端应用程序。Node.js 特别适合构建高性能的网络应用程序。</p><h3 id="事件-events" tabindex="-1"><a class="header-anchor" href="#事件-events"><span>事件（Events）</span></a></h3><p>在 Node.js 中，很多对象都会触发事件：比如，一个网络请求可能会触发<code>data</code>事件，表示数据开始到达；或者一个流（Stream）完成时触发<code>end</code>事件。这些事件可以被监听器（listener）捕获，执行相应的功能代码。</p><h3 id="工作线程-worker-threads-1" tabindex="-1"><a class="header-anchor" href="#工作线程-worker-threads-1"><span>工作线程（Worker Threads）</span></a></h3><p>为了充分利用多核 CPU 的计算能力，Node.js 提供了工作线程模块（Worker Threads）。通过这个模块，你可以创建多个线程来处理任务，这对于执行密集型或阻塞操作特别有用，因为这样可以避免主事件循环被阻塞。</p><h3 id="event-message-2" tabindex="-1"><a class="header-anchor" href="#event-message-2"><span>Event: &#39;message&#39;</span></a></h3><p>在工作线程（Worker Threads）的上下文中，<code>&#39;message&#39;</code>事件是非常关键的一个概念。当你在主线程和工作线程之间发送信息时，接收方通过监听<code>&#39;message&#39;</code>事件来接收这些信息。</p><h4 id="如何工作-2" tabindex="-1"><a class="header-anchor" href="#如何工作-2"><span>如何工作？</span></a></h4><ol><li><strong>主线程</strong>创建了一个<strong>工作线程</strong>。</li><li>主线程向工作线程发送数据或指令。</li><li>工作线程通过监听<code>&#39;message&#39;</code>事件来接收这些数据或指令。</li><li>反之亦然，工作线程也可以向主线程发送消息，主线程通过监听相同的事件来接收消息。</li></ol><h4 id="实际应用示例-7" tabindex="-1"><a class="header-anchor" href="#实际应用示例-7"><span>实际应用示例</span></a></h4><p>假设我们有一个计算密集型任务，比如计算斐波那契数列的第 N 项，并且我们不想在主线程中执行它以避免阻塞。</p><p><strong>主线程代码</strong> (<code>main.js</code>):</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> calculateFibonacciInWorker</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#81A1C1;"> new</span><span style="color:#8FBCBB;"> Promise</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">resolve</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./fibonacciWorker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">      workerData</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> n</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">      console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">[Main Thread] Received result: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#88C0D0;">      resolve</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">      if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;"> !==</span><span style="color:#B48EAD;"> 0</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#88C0D0;">        reject</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker stopped with exit code </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用工作线程计算斐波那契数的第10项</span></span>\n<span class="line"><span style="color:#88C0D0;">calculateFibonacciInWorker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">10</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">then</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Fibonacci Result: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>工作线程代码</strong> (<code>fibonacciWorker.js</code>):</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> workerData</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">=</span><span style="color:#B48EAD;"> 1</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9;"> n</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">    return</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;">-</span><span style="color:#B48EAD;">1</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">+</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;">-</span><span style="color:#B48EAD;">2</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 计算结果</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> fibonacci</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">workerData</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 将结果发送回主线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中：</p><ul><li>我们在主线程中创建了一个工作线程来计算斐波那契数的第 N 项。</li><li>主线程通过监听<code>&#39;message&#39;</code>事件，接收工作线程完成计算后发送的结果。</li><li>工作线程在完成计算后，通过<code>postMessage</code>方法将结果发送回主线程。</li></ul><p>这种方式使得主线程可以继续执行其他任务，而不会被阻塞等待计算结果，提高了应用程序的响应能力和性能。</p><h3 id="event-messageerror-2" tabindex="-1"><a class="header-anchor" href="#event-messageerror-2"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-messageerror_1" target="_blank" rel="noopener noreferrer">Event: &#39;messageerror&#39;</a></span></a></h3><p>在 Node.js 中，<code>Event: &#39;messageerror&#39;</code> 是与 Worker Threads（工作线程）相关的一个事件。为了使这个解释更加通俗易懂，我会首先介绍一下 Worker Threads 的背景，然后再详细解释 <code>messageerror</code> 事件，最后举一些实际的例子。</p><h3 id="背景-worker-threads" tabindex="-1"><a class="header-anchor" href="#背景-worker-threads"><span>背景：Worker Threads</span></a></h3><p>在 Node.js 中，JavaScript 代码默认在单个线程上运行。这意味着所有的操作，包括计算密集型任务，都在同一个线程上执行，有可能导致应用性能瓶颈。为了解决这个问题，Node.js 引入了 Worker Threads，允许创建额外的线程来处理并发任务，从而提高应用的性能和响应速度。</p><h3 id="event-messageerror-3" tabindex="-1"><a class="header-anchor" href="#event-messageerror-3"><span>Event: &#39;messageerror&#39;</span></a></h3><p>在使用 Worker Threads 时，主线程和工作线程之间需要相互发送消息以进行通信。这是通过 <code>postMessage()</code> 方法实现的。通常情况下，发送的消息可以顺利到达对方，并通过 <code>&#39;message&#39;</code> 事件被接收。但是，如果在消息传递过程中发生了错误（例如，消息无法被序列化或反序列化），那么就会触发 <code>&#39;messageerror&#39;</code> 事件。</p><p>简单来说，<code>&#39;messageerror&#39;</code> 事件是当消息在发送或接收过程中出错时发出的通知，这让你有机会对这种错误做出反应，比如重试发送消息或者记录日志等。</p><h3 id="实际运用的例子-7" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-7"><span>实际运用的例子</span></a></h3><p>考虑这样一个场景：你正在开发一个 Web 应用，该应用需要进行一项计算密集型任务，例如图像处理或大数据分析。你决定使用 Worker Threads 来避免阻塞主线程，从而保持应用的响应性。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从工作线程接收到的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">messageerror</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">err</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">消息传递错误:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> err</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 尝试发送一个无法序列化的对象（会触发 messageerror）</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> fn</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">这将无法被发送</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">    // 正常处理消息</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们尝试从主线程向工作线程发送一个函数（函数不能被序列化以通过消息传送）。这会导致 <code>messageerror</code> 事件被触发，并在主线程中打印出错误信息。</p><p>通过监听 <code>messageerror</code> 事件，我们可以及时发现消息传递中的错误，并采取适当的措施，比如尝试使用不同的数据格式或记录错误日志等，从而增强应用的稳定性和可靠性。</p><h3 id="event-online" tabindex="-1"><a class="header-anchor" href="#event-online"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#event-online" target="_blank" rel="noopener noreferrer">Event: &#39;online&#39;</a></span></a></h3><p>Node.js 是一个运行在服务器上的 JavaScript 环境，它允许你使用 JavaScript 来编写服务器端的代码。在 Node.js 中，有一个模块叫做<code>worker_threads</code>。这个模块用于创建多线程应用程序，使得你可以在后台执行 JavaScript 代码而不会阻塞主线程。这在处理大量计算或 I/O 密集型任务时非常有用。</p><h3 id="event-online-1" tabindex="-1"><a class="header-anchor" href="#event-online-1"><span>Event: &#39;online&#39;</span></a></h3><p>在<code>worker_threads</code>模块中，有一个事件叫做<code>&#39;online&#39;</code>。当一个 Worker 线程（子线程）成功地启动并且可以接收消息时，将触发<code>&#39;online&#39;</code>事件。简单地说，当你创建一个新的 Worker 线程，并且这个线程已经准备好开始工作时，就会发生<code>&#39;online&#39;</code>事件。</p><p>让我们来看一下如何在实际中使用<code>&#39;online&#39;</code>事件。</p><h4 id="实例" tabindex="-1"><a class="header-anchor" href="#实例"><span>实例</span></a></h4><p>假设你正在开发一个 Web 应用，这个应用需要处理一些复杂的数据分析任务。为了不让主线程因为这些耗时的任务而变得不响应，你决定使用 Worker 线程来处理这些任务。</p><p>首先，你需要在你的 Node.js 应用中引入<code>worker_threads</code>模块：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，你可以创建一个 Worker 线程来执行一些任务，例如一个计算密集型的操作：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./heavy-task.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的<code>&#39;./heavy-task.js&#39;</code>是 Worker 线程要执行的脚本文件路径，这个文件包含了你想在子线程中运行的代码。</p><p>现在，为了知道这个 Worker 线程何时准备好并开始接收任务，你可以监听<code>&#39;online&#39;</code>事件：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">online</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker thread is now running and ready to receive messages.</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一旦 Worker 线程准备就绪，上面的回调函数就会被执行，你可以在控制台看到一条消息，表明 Worker 线程正在运行并且可以开始接受消息了。</p><p>这个功能在进行复杂和耗时任务的并行处理时非常有用。通过使用 Worker 线程，你可以把这些任务放在后台执行，从而提高应用的整体性能和响应速度。</p><p>记住，虽然使用 Worker 线程可以提高性能，但它也会增加复杂性，比如需要管理通信和数据同步等。因此，只有在确实需要时才使用 Worker 线程，以避免不必要的复杂性。</p><h3 id="worker-getheapsnapshot-options" tabindex="-1"><a class="header-anchor" href="#worker-getheapsnapshot-options"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workergetheapsnapshotoptions" target="_blank" rel="noopener noreferrer">worker.getHeapSnapshot([options])</a></span></a></h3><p>Node.js 的 <code>worker.getHeapSnapshot([options])</code> 方法是一个用于生成堆快照的功能，它存在于 Node.js 的 <code>worker_threads</code> 模块中。在深入解释这个方法之前，我们需要先了解几个概念：</p><ol><li><p><strong>Node.js</strong>: 一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行时环境，允许你在服务器端运行 JavaScript。</p></li><li><p><strong>Worker Threads</strong>: 在 Node.js 中，<code>worker_threads</code> 模块允许你执行 JavaScript 代码在与主线程分离的工作线程中，使你能够实现多线程。</p></li><li><p><strong>堆（Heap）</strong>: 堆是一种数据结构，也是 JavaScript 中存储对象和其他类型数据的内存区域。JavaScript 的垃圾回收机制会自动管理这部分内存，清除不再被使用的数据。</p></li><li><p><strong>堆快照（Heap Snapshot）</strong>: 堆快照是内存堆的一份完整拷贝，在某一特定时刻创建。它提供了那个时刻程序的内存使用情况的详细视图，包括所有对象、变量以及它们之间的引用关系。</p></li></ol><h3 id="解释-worker-getheapsnapshot-options" tabindex="-1"><a class="header-anchor" href="#解释-worker-getheapsnapshot-options"><span>解释 <code>worker.getHeapSnapshot([options])</code></span></a></h3><p>在 <code>worker_threads</code> 模块中，每个 Worker 实例都有一个 <code>getHeapSnapshot()</code> 方法。当你调用这个方法时，它会异步地生成当前工作线程中的堆快照。这对于诊断内存问题，如内存泄露、过度的内存占用等非常有用。</p><h4 id="参数-1" tabindex="-1"><a class="header-anchor" href="#参数-1"><span>参数</span></a></h4><ul><li><strong>options (可选)</strong>: 可配置项，可以控制如何生成堆快照。目前的 Node.js 文档中未明确指出此版本支持哪些选项。</li></ul><h4 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值"><span>返回值</span></a></h4><ul><li>返回一个 <code>Promise</code>，它解析为一个 <code>stream.Readable</code> 流。你可以通过这个流来读取堆快照的数据。</li></ul><h4 id="实际运用示例-6" tabindex="-1"><a class="header-anchor" href="#实际运用示例-6"><span>实际运用示例</span></a></h4><p>假设你正在开发一个复杂的 Node.js 应用，并发现在使用一段时间后应用开始变得缓慢或消耗大量内存。你怀疑这可能是由于内存泄露或某些数据结构过度膨胀造成的。在这种情况下，你可以使用 <code>worker.getHeapSnapshot()</code> 来帮助诊断问题。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> fs</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">fs</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 创建一个工作线程运行相同的文件</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span></span>\n<span class="line"><span style="color:#ECEFF4;">    .</span><span style="color:#88C0D0;">getHeapSnapshot</span><span style="color:#D8DEE9FF;">()</span></span>\n<span class="line"><span style="color:#ECEFF4;">    .</span><span style="color:#88C0D0;">then</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">snapshotStream</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">      const</span><span style="color:#D8DEE9;"> fileStream</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createWriteStream</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">heap-snapshot.heapsnapshot</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">      snapshotStream</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">pipe</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">fileStream</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 将堆快照写入文件</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">      fileStream</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">finish</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">        console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Heap snapshot saved successfully!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">      }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span></span>\n<span class="line"><span style="color:#ECEFF4;">    .</span><span style="color:#88C0D0;">catch</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">err</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">      console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Failed to generate heap snapshot:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> err</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#616E88;">  // 在这里执行一些操作...</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们在工作线程中执行了一些代码。如果我们想要分析这个工作线程的内存使用情况，我们可以在主线程中调用该工作线程的 <code>getHeapSnapshot()</code> 方法，然后将生成的堆快照保存到文件系统中进行进一步的分析。</p><p>总结，<code>worker.getHeapSnapshot()</code> 是一个强大的工具，可以帮助你理解和优化你的 Node.js 应用的内存使用情况。</p><h3 id="worker-performance" tabindex="-1"><a class="header-anchor" href="#worker-performance"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerperformance" target="_blank" rel="noopener noreferrer">worker.performance</a></span></a></h3><p>当我们谈论 Node.js 中的<code>worker.performance</code>，我们实际上是在讨论与 Worker 线程相关的性能监控工具。要理解这个概念，首先需要了解两个关键组成部分：Node.js 和 Worker 线程。</p><h3 id="node-js-简介-2" tabindex="-1"><a class="header-anchor" href="#node-js-简介-2"><span>Node.js 简介</span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它允许开发者使用 JavaScript 来编写服务器端代码。Node.js 设计之初就是为了构建高性能、可扩展的网络应用程序。</p><h3 id="worker-线程" tabindex="-1"><a class="header-anchor" href="#worker-线程"><span>Worker 线程</span></a></h3><p>在多核 CPU 的系统中，为了更好地利用系统资源并提高应用程序的性能，可以使用 Worker 线程来创建多线程应用程序。在 Node.js 中，<code>worker_threads</code>模块使得在 Node.js 应用中实现多线程成为可能。每个 Worker 线程都有其独立的 V8 实例，可以并行执行任务，这对于执行密集型或阻塞操作非常有用。</p><h3 id="worker-performance-1" tabindex="-1"><a class="header-anchor" href="#worker-performance-1"><span><code>worker.performance</code></span></a></h3><p>现在回到<code>worker.performance</code>。这是一个对象，提供了 Worker 线程的性能监控数据。这对于理解和优化 Worker 线程的执行效率至关重要。<code>worker.performance</code>对象包括了如启动时间、消息往返时间等指标，让你可以量化 Worker 的性能。</p><h3 id="实际应用例子-5" tabindex="-1"><a class="header-anchor" href="#实际应用例子-5"><span>实际应用例子</span></a></h3><h4 id="_1-大数据处理" tabindex="-1"><a class="header-anchor" href="#_1-大数据处理"><span>1. 大数据处理</span></a></h4><p>假设你正在编写一个需要处理大量数据的应用程序。这个过程可能会占用大量的 CPU 时间，导致主线程被阻塞，影响用户体验。此时，可以创建 Worker 线程来并行处理数据。通过查看<code>worker.performance</code>，你可以监控这些后台线程的性能，确保它们高效运行。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从Worker接收到: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">message</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程运行</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker线程运行</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello from Worker!</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">performance</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 查看Worker性能数据</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-web-服务器日志处理" tabindex="-1"><a class="header-anchor" href="#_2-web-服务器日志处理"><span>2. Web 服务器日志处理</span></a></h4><p>想象你运行一个繁忙的 Web 服务器，需要实时处理和分析日志文件。你可以将日志分析任务分配给一个或多个 Worker 线程，以避免干扰正常的服务器运行。使用<code>worker.performance</code>帮助你监控日志处理的效率和速度，确保系统平稳运行。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 假设这是一个伪代码，旨在说明概念</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> startLogAnalysis</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> logAnalysisWorker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./log-analysis-worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  logAnalysisWorker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">analysisResults</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">日志分析结果:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> analysisResults</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">logAnalysisWorker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">performance</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 监控性能</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">startLogAnalysis</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结-9" tabindex="-1"><a class="header-anchor" href="#总结-9"><span>总结</span></a></h3><p>通过<code>worker.performance</code>，Node.js 为开发者提供了强大的工具来监测和优化 Worker 线程的性能。无论是进行大规模数据处理、实时日志分析等场景，合理利用这一特性都能显著提升应用性能和用户体验。</p><h4 id="performance-eventlooputilization-utilization1-utilization2" tabindex="-1"><a class="header-anchor" href="#performance-eventlooputilization-utilization1-utilization2"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#performanceeventlooputilizationutilization1-utilization2" target="_blank" rel="noopener noreferrer">performance.eventLoopUtilization([utilization1[, utilization2]])</a></span></a></h4><p>好的，让我们一步步来解释 <code>performance.eventLoopUtilization()</code> 这个方法，并通过实际的例子来理解它在 Node.js 中如何使用以及它的用途。</p><h3 id="什么是-event-loop-事件循环" tabindex="-1"><a class="header-anchor" href="#什么是-event-loop-事件循环"><span>什么是 Event Loop（事件循环）？</span></a></h3><p>Node.js 是基于事件驱动的非阻塞 I/O 模型。这意味着 Node.js 可以在等待异步操作（例如读取文件、网络通信等）的完成时继续执行其他任务。这种机制是通过一个叫做“事件循环”的系统实现的。简单来说，事件循环允许 Node.js 执行非阻塞操作，而不是挂起等待，从而提高了效率和性能。</p><h3 id="event-loop-utilization-事件循环利用率" tabindex="-1"><a class="header-anchor" href="#event-loop-utilization-事件循环利用率"><span>Event Loop Utilization（事件循环利用率）</span></a></h3><p>事件循环利用率是指在给定时间内，事件循环正在忙于处理任务（而不是闲置）的百分比。这是衡量 Node.js 应用性能的一个重要指标。理想情况下，你希望你的事件循环保持高效运行，但也不要过载，以避免延迟和性能瓶颈。</p><h3 id="performance-eventlooputilization-方法" tabindex="-1"><a class="header-anchor" href="#performance-eventlooputilization-方法"><span>performance.eventLoopUtilization() 方法</span></a></h3><p>Node.js 提供了 <code>performance.eventLoopUtilization()</code> 方法，让开发者可以测量事件循环的利用率。这个方法可以接受最多两个参数：</p><ul><li><code>utilization1</code> （可选）: 第一次调用 <code>performance.eventLoopUtilization()</code> 得到的对象。</li><li><code>utilization2</code> （可选）: 第二次调用 <code>performance.eventLoopUtilization()</code> 得到的对象。</li></ul><p>当没有传入参数时，该方法返回一个对象，包含三个属性：</p><ol><li><code>idle</code>：事件循环处于空闲状态的时间总量。</li><li><code>active</code>：事件循环处于活跃状态（即正在处理任务）的时间总量。</li><li><code>utilization</code>：事件循环的利用率，即活跃时间占总时间的比例。</li></ol><h3 id="实际例子-2" tabindex="-1"><a class="header-anchor" href="#实际例子-2"><span>实际例子</span></a></h3><p>假设你正在运行一个 Node.js 应用，想监控它的性能表现，特别是事件循环的表现：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// 导入performance模块</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> performance</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> PerformanceObserver</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">perf_hooks</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 初始调用，用于基准记录</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> initialUtilization</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> performance</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">eventLoopUtilization</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">setTimeout</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设在这里之后有一些异步操作发生...</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 一段时间后，再次测量</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> newUtilization</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> performance</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">eventLoopUtilization</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">initialUtilization</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">事件循环利用率: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">newUtilization</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">utilization</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">},</span><span style="color:#B48EAD;"> 1000</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中，我们首先获取了事件循环利用率的初始值。然后设置了一个计时器，在 1 秒后再次测量和计算事件循环利用率。这将展示自第一次测量以来，事件循环的利用率变化，即在这 1 秒钟内，事件循环有多少时间是活跃的。</p><h3 id="总结-10" tabindex="-1"><a class="header-anchor" href="#总结-10"><span>总结</span></a></h3><p><code>performance.eventLoopUtilization()</code> 是一个强大的工具，用于监控和优化 Node.js 应用的性能。通过测量事件循环的利用率，开发者可以识别出潜在的性能瓶颈，从而进行必要的优化，确保应用运行得更加顺畅。</p><h3 id="worker-postmessage-value-transferlist" tabindex="-1"><a class="header-anchor" href="#worker-postmessage-value-transferlist"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist" target="_blank" rel="noopener noreferrer">worker.postMessage(value[, transferList])</a></span></a></h3><p>理解 <code>worker.postMessage(value[, transferList])</code> 方法前，我们需要先了解 Node.js 中的 Worker Threads 模块。在多核心 CPU 的计算机中，为了更高效地进行计算和处理，可以使用多线程来同时执行不同的任务。Node.js 提供了 Worker Threads 模块，允许我们在后台运行的独立线程上执行 JavaScript 代码，从而提高应用的性能和响应能力。</p><h3 id="什么是-worker-postmessage-value-transferlist" tabindex="-1"><a class="header-anchor" href="#什么是-worker-postmessage-value-transferlist"><span>什么是 <code>worker.postMessage(value[, transferList])</code>?</span></a></h3><p>这个方法是 Worker Threads API 的一部分，允许主线程与工作线程（worker thread）之间互相发送消息。这里的 <code>postMessage</code> 方法被用于从父线程向子线程（或反向）发送数据。</p><ul><li><strong>value</strong>: 这是你想要发送给工作线程的数据。</li><li><strong>transferList</strong> (可选): 这是一个对象数组，包括如 <code>ArrayBuffer</code>，它们将会被转移至工作线程。&quot;转移&quot;意味着一旦传递，原本线程将不再拥有这些对象的所有权。这有助于提升性能，因为避免了复制数据而直接进行所有权转移。</li></ul><h3 id="实际运用例子-4" tabindex="-1"><a class="header-anchor" href="#实际运用例子-4"><span>实际运用例子</span></a></h3><ol><li><p><strong>并行处理大量数据</strong></p><p>假设你正在开发一个应用，需要处理大量数据，比如图像或视频处理。你可以创建多个工作线程来并行处理数据，每个线程处理一部分，最后合并结果。这样可以显著缩短处理时间。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 创建一个工作线程执行当前文件</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello Worker</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 向工作线程发送消息</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">msg</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 接收并打印工作线程回复的消息</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 工作线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker received: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 打印从主线程收到的消息</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Hello Main Thread</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 回复消息给主线程</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Web 服务器后端处理</strong></p><p>在 Node.js 后端服务中，可能需要执行一些资源密集型的任务，如生成报告、数据分析等。这些任务可以放在工作线程中运行，以避免阻塞主事件循环，从而保持应用响应用户请求的能力。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> runHeavyTask</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#81A1C1;"> new</span><span style="color:#8FBCBB;"> Promise</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">resolve</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./heavyTaskWorker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 假设这是一个执行重任务的工作线程</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> resolve</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> reject</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">      if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;"> !==</span><span style="color:#B48EAD;"> 0</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#88C0D0;">        reject</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker stopped with exit code </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">      }</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 使用runHeavyTask函数处理一项重任务...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>通过这两个例子，你可以看到 <code>worker.postMessage</code> 方法使得在主线程和工作线程之间传递消息和数据成为可能，进而可以在 Node.js 中实现并行处理和提高应用性能。</p><h3 id="worker-ref" tabindex="-1"><a class="header-anchor" href="#worker-ref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerref" target="_blank" rel="noopener noreferrer">worker.ref()</a></span></a></h3><p>理解<code>worker.ref()</code>，首先要知道 Node.js 中的 Worker Threads（工作线程）是什么。Node.js 是单线程的，但为了充分利用多核 CPU，可以使用 Worker Threads 来创建额外的线程。这样，你就能并行执行 JavaScript 代码，提高应用的性能和响应速度。</p><p>在使用 Worker Threads 时，有两个重要的方法需要了解：<code>worker.ref()</code>和<code>worker.unref()</code>。它们影响着主 Node.js 进程的生命周期。</p><h3 id="worker-ref-1" tabindex="-1"><a class="header-anchor" href="#worker-ref-1"><span><code>worker.ref()</code></span></a></h3><p>当你创建一个 Worker 线程时，默认情况下，这个线程会被计入 Node.js 事件循环的引用计数中。这意味着，即使主线程的代码已经执行完毕，只要还有活跃的 Worker 线程，Node.js 进程会保持活动状态，等待 Worker 线程完成。</p><p><code>worker.ref()</code>方法就是用来确保这种行为的。如果你显式地调用了<code>worker.unref()</code>，表示你告诉 Node.js：“即便这个 Worker 线程还在运行，如果其他的异步操作都完成了，不需要因为这个 Worker 线程而保持 Node.js 进程的活动状态。”然后，如果你又想让这个 Worker 线程重新计入引用计数，可以调用<code>worker.ref()</code>，确保 Node.js 进程会保持活动状态直到该 Worker 线程运行结束。</p><h3 id="实际例子-3" tabindex="-1"><a class="header-anchor" href="#实际例子-3"><span>实际例子</span></a></h3><p>考虑这样一个场景：你正在开发一个 Web 服务器，为了提高性能，你决定使用 Worker 线程来处理一些 CPU 密集型的任务，比如图片或视频处理。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程开始</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设你在这里不需要立即需要worker完成操作</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">unref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">主线程结束</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker线程开始工作</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设这里有一些长时间运行的操作...</span></span>\n<span class="line"><span style="color:#88C0D0;">  setTimeout</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker线程结束工作</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  },</span><span style="color:#B48EAD;"> 5000</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 模拟长时间运行操作</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，主线程启动一个 Worker 线程后即结束。由于调用了<code>worker.unref()</code>，Node.js 主进程不会等待 Worker 线程结束就退出。这对于那些不希望阻塞主进程退出的后台任务非常有用。如果你想要主进程等待 Worker 线程完成，可以通过在适当的位置调用<code>worker.ref()</code>来实现。</p><p>记住，正确地管理 Worker 线程对于构建高效、响应快速的 Node.js 应用是至关重要的。通过<code>worker.ref()</code>和<code>worker.unref()</code>，你可以更灵活地控制应用的行为和资源管理。</p><h3 id="worker-resourcelimits-2" tabindex="-1"><a class="header-anchor" href="#worker-resourcelimits-2"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerresourcelimits_1" target="_blank" rel="noopener noreferrer">worker.resourceLimits</a></span></a></h3><p>当我们谈论 Node.js 中的 <code>worker.resourceLimits</code>，我们实际上是在讨论 Node.js 多线程编程的一个重要概念。在 Node.js 的世界里，虽然它主要以单线程运行以支持高并发，但通过使用 Worker 线程（通过 <code>worker_threads</code> 模块引入），Node.js 允许我们在后台执行 JavaScript 和 WebAssembly 代码，而不会影响主线程的性能。</p><h3 id="什么是-worker-resourcelimits" tabindex="-1"><a class="header-anchor" href="#什么是-worker-resourcelimits"><span>什么是 <code>worker.resourceLimits</code>?</span></a></h3><p>简单来说，<code>worker.resourceLimits</code> 是一个选项对象，你可以在创建新的 Worker 线程时传递给它。这个对象允许你设置某些资源限制，比如内存大小和执行时间，用于这个新创建的 Worker 线程。这对于控制和管理 Node.js 应用程序中的资源消耗非常有用，特别是在处理大量计算或需要隔离的任务时。</p><h3 id="worker-resourcelimits-包含哪些限制" tabindex="-1"><a class="header-anchor" href="#worker-resourcelimits-包含哪些限制"><span><code>worker.resourceLimits</code> 包含哪些限制？</span></a></h3><p>截至 Node.js v21.7.1，<code>worker.resourceLimits</code> 对象可包括以下几种限制：</p><ul><li><code>maxYoungGenerationSizeMb</code>: 最大新生代内存大小（单位为 MB）。新生代内存是 V8 垃圾回收机制中用于存储生命周期较短的对象的内存区域。</li><li><code>maxOldGenerationSizeMb</code>: 最大老生代内存大小（单位为 MB）。老生代内存用于存储生命周期较长或常驻的对象。</li><li><code>codeRangeSizeMb</code>: 代码范围大小（单位为 MB），用于存储 JIT 编译的代码。</li><li><code>stackSizeMb</code>: 栈大小（单位为 MB），用于控制线程的调用栈大小。</li></ul><h3 id="实际应用示例-8" tabindex="-1"><a class="header-anchor" href="#实际应用示例-8"><span>实际应用示例</span></a></h3><p>假设您正在开发一个 Node.js 应用程序，该程序需要执行大量数据处理任务，而这些任务可能会占用大量内存。为了避免单个任务消耗过多资源而影响整个系统的稳定性，您可以使用 Worker 线程配合资源限制来隔离和管理这些任务。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程中</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">    workerData</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#88C0D0;">    resourceLimits</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">      maxOldGenerationSizeMb</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 256</span><span style="color:#ECEFF4;">,</span><span style="color:#616E88;"> // 最多允许老生代内存使用 256MB</span></span>\n<span class="line"><span style="color:#88C0D0;">      maxYoungGenerationSizeMb</span><span style="color:#ECEFF4;">:</span><span style="color:#B48EAD;"> 64</span><span style="color:#ECEFF4;">,</span><span style="color:#616E88;"> // 最多允许新生代内存使用 64MB</span></span>\n<span class="line"><span style="color:#ECEFF4;">    },</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">message</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">开始任务</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程中</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">once</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 接收到 &#39;开始任务&#39;</span></span>\n<span class="line"><span style="color:#616E88;">    // 在这里执行一些内存密集型操作...</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">任务完成</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子展示了如何创建一个具有指定内存限制的 Worker 线程。通过限制 Worker 线程的资源使用，您可以更好地控制应用程序的总体资源消耗，从而提高其稳定性和响应能力。</p><h3 id="结语" tabindex="-1"><a class="header-anchor" href="#结语"><span>结语</span></a></h3><p>通过理解和利用 <code>worker.resourceLimits</code>，Node.js 开发者可以更细致地管理他们应用中的资源消耗，尤其是在执行资源密集型或长时间运行的任务时。这不仅有助于优化应用性能，还能提高其稳定性和用户体验。</p><h3 id="worker-stderr" tabindex="-1"><a class="header-anchor" href="#worker-stderr"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerstderr" target="_blank" rel="noopener noreferrer">worker.stderr</a></span></a></h3><p>Node.js 在其多线程编程模式下提供了一个模块叫 <code>worker_threads</code>。这个模块让你能够在 Node.js 应用中运行多个 JavaScript 工作线程，这是一种利用现代多核 CPU 进行高效并行处理的方式。在这个上下文中，<code>worker.stderr</code> 是这个模块的一个属性。</p><h3 id="什么是-worker-stderr" tabindex="-1"><a class="header-anchor" href="#什么是-worker-stderr"><span>什么是 <code>worker.stderr</code>？</span></a></h3><p>在 <code>worker_threads</code> 模块中，每个 Worker 线程都可以被看做是一个独立的运行环境，与主线程或其他 Worker 线程并行执行代码。<code>worker.stderr</code> 是一个特殊的流（stream），它代表了该 Worker 线程的标准错误输出（stderr）。</p><p>简单来说，<code>stderr</code> 是计算机程序用来输出错误信息的一种通道。与之对应的还有 <code>stdout</code>，即标准输出，通常用来输出正常的程序运行结果。在 Node.js 的 Worker 线程中，如果你的代码执行中遇到了错误或者需要特别标记的信息，那么这些信息可以通过 <code>worker.stderr</code> 输出。</p><h3 id="实际应用例子-6" tabindex="-1"><a class="header-anchor" href="#实际应用例子-6"><span>实际应用例子</span></a></h3><h4 id="例子-1-监听错误信息" tabindex="-1"><a class="header-anchor" href="#例子-1-监听错误信息"><span>例子 1：监听错误信息</span></a></h4><p>假设你在一个 Worker 线程里运行一段可能会报错的代码，你希望能够捕获并在主线程中处理这些错误信息。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程中</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 创建一个 Worker 线程运行当前文件</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">  // 监听该 Worker 线程的 stderr 流</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stderr</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">error</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">从 Worker 线程收到的错误信息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">error</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程中</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">这是一个错误消息</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，Worker 线程通过 <code>console.error</code> 向 <code>stderr</code> 输出了一条错误消息。主线程通过监听 <code>worker.stderr.on(&#39;data&#39;, ...)</code> 捕获了这条消息，并将其打印出来。</p><h4 id="例子-2-重定向错误日志" tabindex="-1"><a class="header-anchor" href="#例子-2-重定向错误日志"><span>例子 2：重定向错误日志</span></a></h4><p>在某些情况下，你可能希望将 Worker 线程的错误信息重定向到文件而不是控制台。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> fs</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">fs</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> path</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">path</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个可写流，用于将错误信息写入文件</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> errorLogStream</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> fs</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">createWriteStream</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">path</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">join</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__dirname</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">error.log</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#88C0D0;">  flags</span><span style="color:#ECEFF4;">:</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">a</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">  `</span></span>\n<span class="line"><span style="color:#A3BE8C;">  const { parentPort } = require(&#39;worker_threads&#39;);</span></span>\n<span class="line"><span style="color:#A3BE8C;">  console.error(&quot;模拟一个错误消息&quot;);</span></span>\n<span class="line"><span style="color:#ECEFF4;">`</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">  {</span><span style="color:#88C0D0;"> eval</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> true</span><span style="color:#ECEFF4;"> }</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 将 worker.stderr 重定向到文件</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stderr</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">pipe</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">errorLogStream</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker 线程已退出</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们通过 <code>.pipe()</code> 方法将 <code>worker.stderr</code> 的输出重定向到了一个文件（<code>error.log</code>）。这样，所有通过 <code>console.error</code> 或其他方式发送到 <code>stderr</code> 的信息都会被写入到 <code>error.log</code> 文件中，而不是显示在控制台上。</p><p>总结来说，<code>worker.stderr</code> 在 Node.js 多线程编程中提供了一种强大的方式来处理和重定向 Worker 线程的错误输出，从而使得错误管理和日志记录变得更加灵活和高效。</p><h3 id="worker-stdin" tabindex="-1"><a class="header-anchor" href="#worker-stdin"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerstdin" target="_blank" rel="noopener noreferrer">worker.stdin</a></span></a></h3><p><code>worker.stdin</code> 是 Node.js 中 Worker Threads 模块的一个属性，用于向工作线程（Worker Thread）发送数据。在解释这个概念之前，我们需要了解几个基本点：</p><ol><li><strong>Node.js</strong>：一个基于 Chrome V8 引擎的 JavaScript 运行环境，允许你在服务器端运行 JavaScript 代码。</li><li><strong>工作线程（Worker Threads）</strong>：Node.js 为了克服单线程限制，提供了 Worker Threads，使得可以创建多个线程，进行并行处理。</li></ol><p>在很多情况下，主线程可能需要与它创建的工作线程通信，比如发送数据或者某些指令给工作线程。这就是 <code>worker.stdin</code> 发挥作用的地方。</p><h3 id="worker-stdin-简介" tabindex="-1"><a class="header-anchor" href="#worker-stdin-简介"><span><code>worker.stdin</code> 简介</span></a></h3><ul><li><code>worker.stdin</code> 提供了一个可写流（Writable Stream），允许主线程向工作线程发送数据。</li><li>只有在工作线程内部使用 <code>parentPort</code> 或 <code>process.stdin</code> 监听时，发送的数据才能被接收和处理。</li></ul><h3 id="实际运用示例-7" tabindex="-1"><a class="header-anchor" href="#实际运用示例-7"><span>实际运用示例</span></a></h3><p>假设我们要进行一项计算密集型任务，比如大量数学计算，并且不想阻塞主线程。我们可以创建一个工作线程来完成这项任务，同时使用 <code>worker.stdin</code> 来发送需要计算的数据。</p><h4 id="步骤-1-创建工作线程文件" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建工作线程文件"><span>步骤 1: 创建工作线程文件</span></a></h4><p>创建一个文件 <code>worker.js</code>，这个文件将包含工作线程的代码。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 接收主线程发送的数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">process</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdin</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> performHeavyCalculation</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 假设的计算函数</span></span>\n<span class="line"><span style="color:#D8DEE9;">  process</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdout</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">write</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Result: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#EBCB8B;">\\n</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> performHeavyCalculation</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 这里进行实际的计算</span></span>\n<span class="line"><span style="color:#81A1C1;">  return</span><span style="color:#D8DEE9;"> data</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 示例返回接收到的数据</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-在主线程中使用-worker-stdin" tabindex="-1"><a class="header-anchor" href="#步骤-2-在主线程中使用-worker-stdin"><span>步骤 2: 在主线程中使用 <code>worker.stdin</code></span></a></h4><p>现在，在主线程中创建并使用 <code>worker.stdin</code> 向工作线程发送数据。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> path</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">path</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">path</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">resolve</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__dirname</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 向工作线程发送数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdin</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">write</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">123</span><span style="color:#EBCB8B;">\\n</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 发送字符串 &#39;123&#39; 加上换行符，因为我们在工作线程中使用的是 process.stdin.on(&#39;data&#39;)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdout</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Received from worker: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">data</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker exited</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，主线程创建了一个工作线程，并通过 <code>worker.stdin.write(&#39;123\\n&#39;)</code> 向它发送了数据。工作线程接收这个数据，进行处理（这里简化为直接返回），并通过 <code>process.stdout.write()</code> 发回结果。主线程监听 <code>worker.stdout</code> 来接收并打印这个结果。</p><h3 id="总结-11" tabindex="-1"><a class="header-anchor" href="#总结-11"><span>总结</span></a></h3><p><code>worker.stdin</code> 允许主线程以流的形式向工作线程发送数据，这是 Node.js 多线程编程中的一个重要组成部分，尤其适合处理计算密集型或异步任务，而不会阻塞主线程。通过这种方法，你可以有效地利用多核 CPU 的能力，提高应用程序的性能和响应速度。</p><h3 id="worker-stdout" tabindex="-1"><a class="header-anchor" href="#worker-stdout"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerstdout" target="_blank" rel="noopener noreferrer">worker.stdout</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许你在服务器端执行 JavaScript 代码。Node.js 的一个有力特性就是它的多线程能力，通过 <code>worker_threads</code> 模块实现。在多线程环境中，可以创建工作线程来处理任务，以提高应用的性能和响应速度。</p><h3 id="什么是-worker-stdout" tabindex="-1"><a class="header-anchor" href="#什么是-worker-stdout"><span>什么是 worker.stdout？</span></a></h3><p>在 Node.js 的 <code>worker_threads</code> 模块中，<code>worker.stdout</code> 是指向工作线程（Worker）的标准输出流（stdout）的引用。每个 Worker 都有自己的 stdin、stdout 和 stderr 流，这与主 Node.js 进程类似。这些流允许工作线程与主进程或其他工作线程进行数据通信。</p><p>简而言之，<code>worker.stdout</code> 是一个可读流，用于接收来自工作线程的标准输出信息。</p><h3 id="实际运用例子-5" tabindex="-1"><a class="header-anchor" href="#实际运用例子-5"><span>实际运用例子</span></a></h3><p>假设你正在构建一个 Node.js 应用，需要进行大量的数据排序操作。为了不阻塞主事件循环，你决定使用工作线程来处理排序任务，并希望将排序结果从工作线程输出到主进程。</p><h4 id="步骤-1-创建一个工作线程文件-sort-worker-js" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建一个工作线程文件-sort-worker-js"><span>步骤 1: 创建一个工作线程文件 <code>sort-worker.js</code></span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 接收主线程发送的数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 对数据进行排序</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> sortedData</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> data</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">sort</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">a</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> b</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#D8DEE9;"> a</span><span style="color:#81A1C1;"> -</span><span style="color:#D8DEE9;"> b</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 将排序结果输出（通过标准输出）</span></span>\n<span class="line"><span style="color:#D8DEE9;">  process</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdout</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">write</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">JSON</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">stringify</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">sortedData</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="步骤-2-在主程序中创建并使用该工作线程" tabindex="-1"><a class="header-anchor" href="#步骤-2-在主程序中创建并使用该工作线程"><span>步骤 2: 在主程序中创建并使用该工作线程</span></a></h4><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建工作线程并指向上面的 sort-worker.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./sort-worker.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 准备一些需要排序的数据</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> numbers</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9FF;"> [</span><span style="color:#B48EAD;">42</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 23</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 16</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 15</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 8</span><span style="color:#ECEFF4;">,</span><span style="color:#B48EAD;"> 4</span><span style="color:#D8DEE9FF;">]</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 向工作线程发送数据</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">numbers</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 监听工作线程的标准输出</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">stdout</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">data</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">排序结果: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">data</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">toString</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 处理错误</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">error</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> console</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">error</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 当工作线程结束时执行的操作</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;"> !==</span><span style="color:#B48EAD;"> 0</span><span style="color:#D8DEE9FF;">) </span><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#81A1C1;">new</span><span style="color:#88C0D0;"> Error</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">工作线程停止，退出码 </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">code</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">))</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个工作线程 <code>sort-worker.js</code> 来处理数据排序任务。主程序创建工作线程，通过 <code>postMessage</code> 方法发送待排序的数组。工作线程接收数据，进行排序，并通过 <code>process.stdout.write</code> 将排序结果输出。回到主程序，我们通过监听 <code>worker.stdout</code> 上的 <code>data</code> 事件来获取工作线程的输出结果。</p><p>这样，即使排序任务非常复杂和耗时，它也不会直接阻塞主事件循环，使得应用可以继续处理其他任务或响应用户输入。</p><h3 id="worker-terminate" tabindex="-1"><a class="header-anchor" href="#worker-terminate"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerterminate" target="_blank" rel="noopener noreferrer">worker.terminate()</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许在服务端运行 JavaScript 代码。这意味着借助 Node.js，你可以编写能够处理网络请求、文件 I/O 操作等后端任务的 JavaScript 代码。</p><p>在 Node.js 中，有一个模块叫作<code>worker_threads</code>，这个模块允许 Node.js 运行的程序内部可以创建多个线程，从而执行多任务或者在不同核心上并行处理计算密集型任务。这是实现多线程并发处理的一种方式。</p><h3 id="worker-terminate-1" tabindex="-1"><a class="header-anchor" href="#worker-terminate-1"><span><code>worker.terminate()</code></span></a></h3><p>当你使用<code>worker_threads</code>模块创建了一个新的线程（也称为 Worker）来执行某些任务时，可能会遇到需要提前终止这个 Worker 的情况。这时，你可以使用<code>worker.terminate()</code>方法来停止 Worker。</p><p><code>worker.terminate()</code>方法会异步地终止 Worker，这意味着它将立即返回，但 Worker 可能需要一些时间来停止所有正在运行的操作。一旦 Worker 被终止，它就无法再次使用或启动。</p><h4 id="实际应用示例-9" tabindex="-1"><a class="header-anchor" href="#实际应用示例-9"><span>实际应用示例</span></a></h4><p>假设你正在开发一个 Web 服务器，该服务器接收来自用户的图片处理请求。图片处理是一个计算密集型任务，因此你决定使用<code>worker_threads</code>模块来在后台线程中处理图片，以避免阻塞主线程。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 创建一个Worker线程来处理图片</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">./path/to/image-processing-task.js</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">// 假设在某个时间点，由于某种原因（比如用户取消了请求），你需要停止图片处理任务</span></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">terminate</span><span style="color:#D8DEE9FF;">()</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">then</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Worker terminated</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们首先导入了<code>worker_threads</code>模块，并创建了一个 Worker 来执行图片处理任务。如果出现需要提前终止 Worker 的情况，我们调用<code>worker.terminate()</code>方法来停止 Worker。使用<code>.then()</code>方法是因为<code>terminate()</code>返回一个 Promise，这样我们可以在 Worker 成功终止后执行一些清理工作或给出提示信息。</p><p>请注意，<code>worker.terminate()</code>方法应当谨慎使用，因为它会立刻中断 Worker 的执行，可能会导致一些正在进行的操作未能正确完成或资源没有得到释放。因此，在终止 Worker 之前，如果可能的话，最好先通过其他方式（例如发送消息给 Worker）通知 Worker 准备停止，并尝试正常结束正在执行的任务。</p><h3 id="worker-threadid-2" tabindex="-1"><a class="header-anchor" href="#worker-threadid-2"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid_1" target="_blank" rel="noopener noreferrer">worker.threadId</a></span></a></h3><p>Node.js 是一个让 JavaScript 运行在服务器端的平台。它非常适合处理多个并发连接和执行高性能的后台任务，而不会对系统造成过大负担。为了实现这一点，Node.js 提供了很多工具和模块，其中之一就是 <code>worker_threads</code> 模块。</p><h3 id="什么是-worker-threads-2" tabindex="-1"><a class="header-anchor" href="#什么是-worker-threads-2"><span>什么是 <code>worker_threads</code>?</span></a></h3><p><code>worker_threads</code> 模块允许你运行 JavaScript 代码在 Node.js 的多个线程中。在传统的单线程 JavaScript 运行环境中，所有任务都是按顺序执行的。如果你有一个非常耗时的任务，它会阻塞其他任务的执行，从而导致整个应用程序的响应速度变慢。通过使用 <code>worker_threads</code>，你可以将这些耗时的任务放在不同的线程中并行处理，这样主线程就不会被阻塞，能够继续快速响应其他任务。</p><h3 id="什么是-worker-threadid" tabindex="-1"><a class="header-anchor" href="#什么是-worker-threadid"><span>什么是 <code>worker.threadId</code>？</span></a></h3><p>在 <code>worker_threads</code> 模块中，每个 Worker 线程都有一个唯一的标识符，这就是 <code>threadId</code>。你可以通过 <code>worker.threadId</code> 访问这个标识符。这个标识符对于调试和跟踪执行中的不同 Worker 线程非常有用。</p><h3 id="实际运用示例-8" tabindex="-1"><a class="header-anchor" href="#实际运用示例-8"><span>实际运用示例：</span></a></h3><p>假设你正在开发一个 Web 应用程序，需要处理用户上传的大量图片。图片处理（如压缩、格式转换等）是一个非常耗时的任务。如果你直接在主线程中处理所有图片，那么应用程序的响应时间会大大增加，用户体验会受到严重影响。</p><p>下面是一个使用 <code>worker_threads</code> 来处理图片的简化示例：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">  // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">主线程: 创建了一个 Worker 线程，线程ID是 </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">主线程: 接收到来自线程 </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">threadId</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;"> 的消息: </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">result</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">开始处理图片...</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // Worker 线程代码</span></span>\n<span class="line"><span style="color:#D8DEE9;">  parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Worker 线程: 收到消息 &#39;</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">&#39;</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#616E88;">    // 假装我们在这里进行复杂的图片处理...</span></span>\n<span class="line"><span style="color:#81A1C1;">    let</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">图片处理完成</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">{</span><span style="color:#88C0D0;"> result</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> result</span><span style="color:#ECEFF4;">,</span><span style="color:#88C0D0;"> threadId</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9;"> worker</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">threadId</span><span style="color:#ECEFF4;"> }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中：</p><ol><li>主线程创建了一个 Worker 线程来处理图片。</li><li>Worker 线程接收到任务消息后，模拟图片处理过程，并将处理结果发送回主线程。</li><li>使用 <code>worker.threadId</code>，我们可以轻松地跟踪是哪个 Worker 线程完成了任务。</li></ol><p>通过这种方式，即使图片处理是一个非常耗时的任务，主线程也不会被阻塞，它仍然可以快速响应其他请求。这对于提高应用程序的性能和用户体验至关重要。</p><h3 id="worker-unref" tabindex="-1"><a class="header-anchor" href="#worker-unref"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#workerunref" target="_blank" rel="noopener noreferrer">worker.unref()</a></span></a></h3><p>了解<code>worker.unref()</code>之前，我们得先简单了解一下在 Node.js 中工作线程（Worker Threads）的概念。</p><h3 id="工作线程-worker-threads-简介" tabindex="-1"><a class="header-anchor" href="#工作线程-worker-threads-简介"><span>工作线程（Worker Threads）简介</span></a></h3><p>Node.js 是单线程的，这意味着所有的 JavaScript 代码都在同一个线程中执行。但是，有些操作如文件读写、网络请求等是可以异步进行的，允许 Node.js 可以同时处理多个任务而不会互相干扰。然而，在处理大量计算密集型任务时，单线程就可能成为瓶颈。</p><p>为了解决这个问题，Node.js 引入了“工作线程”（Worker Threads）。通过使用工作线程，我们可以创建额外的线程去并行处理任务，这样主线程（通常是我们的脚本直接运行的地方）就不会被阻塞，能继续处理其他任务。</p><h3 id="worker-unref-方法" tabindex="-1"><a class="header-anchor" href="#worker-unref-方法"><span><code>worker.unref()</code>方法</span></a></h3><p>当你创建一个工作线程去执行某些任务时，默认情况下，Node.js 进程会等到所有工作线程都完成它们的任务后才会退出。但有时候，我们可能希望即使这些附加的工作线程还没完成任务，主进程也能正常结束，不被迫等待。这就是<code>worker.unref()</code>发挥作用的时候。</p><p>调用<code>worker.unref()</code>方法后，该工作线程不再要求主进程保持活动状态。这意味着如果主线程完成了它的任务，它可以正常退出，即使那个<code>unref</code>的工作线程还没有完成它的任务。如果所有的工作线程都被<code>unref</code>，那么主进程完成其任务后将会退出。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><p>假设我们有一个需要进行密集计算的任务，此任务我们希望在一个工作线程中执行，以避免阻塞主线程。</p><ol><li><strong>创建工作线程执行任务</strong>：</li></ol><p>首先，假设我们的任务是计算斐波那契数列的第 N 项，这是一个典型的计算密集型任务。我们将这个任务放在一个工作线程里面执行。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> isMainThread</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> parentPort</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">isMainThread</span><span style="color:#D8DEE9FF;">) </span><span style="color:#ECEFF4;">{</span></span>\n<span class="line"><span style="color:#616E88;">    // 主线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">    const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">__filename</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">        console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">收到：</span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">msg</span><span style="color:#81A1C1;">}</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">    worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">unref</span><span style="color:#D8DEE9FF;">()</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 不阻止主线程退出</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">    // 工作线程代码</span></span>\n<span class="line"><span style="color:#81A1C1;">    let</span><span style="color:#D8DEE9;"> result</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> fib</span><span style="color:#D8DEE9FF;">(</span><span style="color:#B48EAD;">10</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // 假设fib是计算斐波那契数的函数</span></span>\n<span class="line"><span style="color:#D8DEE9;">    parentPort</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">result</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">function</span><span style="color:#88C0D0;"> fib</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#D8DEE9FF;"> (</span><span style="color:#D8DEE9;">n</span><span style="color:#ECEFF4;"> `</span><span style="color:#A3BE8C;">&lt;</span><span style="color:#ECEFF4;">`</span><span style="color:#81A1C1;">=</span><span style="color:#B48EAD;"> 1</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">return</span><span style="color:#D8DEE9;"> n</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#81A1C1;">    return</span><span style="color:#88C0D0;"> fib</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;"> -</span><span style="color:#B48EAD;"> 1</span><span style="color:#D8DEE9FF;">) </span><span style="color:#81A1C1;">+</span><span style="color:#88C0D0;"> fib</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">n</span><span style="color:#81A1C1;"> -</span><span style="color:#B48EAD;"> 2</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个工作线程来计算斐波那契数列的第 10 项，并通过<code>worker.unref()</code>告诉 Node.js 主线程不需要等待这个工作线程完成。这样，即使工作线程的计算任务还在进行中，主线程的任务（如果有的话）完成后，整个程序也能立即退出。</p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h3><p><code>worker.unref()</code>提供了一种灵活控制 Node.js 程序生命周期的方式，特别是在涉及到后台任务或者不希望阻塞应用退出的场景中非常有用。通过合理利用工作线程和<code>unref</code>方法，可以显著提升 Node.js 应用的性能和用户体验。</p><h2 id="notes" tabindex="-1"><a class="header-anchor" href="#notes"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#notes" target="_blank" rel="noopener noreferrer">Notes</a></span></a></h2><p>理解 Node.js 和它的工作线程（Worker Threads）模块是进阶 Node.js 开发的关键一步。假设你已经对 JavaScript 有基本了解，这会使得学习过程更加直观。</p><h3 id="什么是-node-js" tabindex="-1"><a class="header-anchor" href="#什么是-node-js"><span>什么是 Node.js？</span></a></h3><p>Node.js 是一个开源、跨平台的 JavaScript 运行时环境，让你可以在服务器端运行 JavaScript。Node.js 的设计哲学是轻量级和高效，特别适合处理数据密集型的实时应用程序。它使用事件驱动、非阻塞 I/O 模型，使其既轻巧又有效。</p><h3 id="为什么需要工作线程-worker-threads" tabindex="-1"><a class="header-anchor" href="#为什么需要工作线程-worker-threads"><span>为什么需要工作线程（Worker Threads）？</span></a></h3><p>默认情况下，Node.js 是单线程的。这意味着所有操作（文件读写、网络请求等）都在同一个线程上执行，使得处理大量并发操作变得高效。然而，当要执行计算密集型任务时，如图像或视频处理、大数据分析等，单线程可能成为瓶颈，因为这些任务会阻塞线程，导致性能问题。</p><p>这就是为什么 Node.js 引入了“工作线程”（Worker Threads）。这个功能允许 Node.js 应用创建多个线程来处理这些密集型任务，从而避免主线程被阻塞，并提高了应用程序的整体性能和可靠性。</p><h3 id="实际运用示例-9" tabindex="-1"><a class="header-anchor" href="#实际运用示例-9"><span>实际运用示例</span></a></h3><p>假设我们正在开发一个服务，该服务需要处理大量图片的压缩。如果我们只使用 Node.js 的单个主线程来执行这项任务，那么在处理这些耗时的操作时，我们的应用将无法同时处理其他任何事情（如响应用户请求）。这会导致用户体验非常差，尤其是在高负载时。</p><h4 id="使用工作线程处理图片压缩" tabindex="-1"><a class="header-anchor" href="#使用工作线程处理图片压缩"><span>使用工作线程处理图片压缩：</span></a></h4><ol><li><strong>不使用 Worker Threads</strong>:</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#88C0D0;"> compressImage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">imagePath</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#616E88;">  // 假设这是一个耗时的图片压缩操作</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">`</span><span style="color:#A3BE8C;">Compressing image at </span><span style="color:#81A1C1;">${</span><span style="color:#D8DEE9;">imagePath</span><span style="color:#81A1C1;">}</span><span style="color:#A3BE8C;">...</span><span style="color:#ECEFF4;">`</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#616E88;">  // 图片处理完成</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#88C0D0;">compressImage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">/path/to/image.jpg</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">This message has to wait until the image is compressed.</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>console.log(&#39;This message...&#39;)</code> 需要等待 <code>compressImage</code> 完成才能执行，这会导致阻塞。</p><ol start="2"><li><strong>使用 Worker Threads</strong>:</li></ol><p>首先，你需要在你的项目中安装 <code>worker_threads</code> 模块。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#88C0D0;"> compressImage</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">imagePath</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#81A1C1;">  const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">    `</span></span>\n<span class="line"><span style="color:#A3BE8C;">        const { parentPort } = require(&#39;worker_threads&#39;);</span></span>\n<span class="line"><span style="color:#A3BE8C;">        parentPort.postMessage(&#39;Compressing image...&#39;);</span></span>\n<span class="line"><span style="color:#A3BE8C;">        // 放置图片压缩逻辑</span></span>\n<span class="line"><span style="color:#ECEFF4;">    `</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">    {</span><span style="color:#88C0D0;"> eval</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> true</span><span style="color:#ECEFF4;"> }</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">  )</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">message</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#D8DEE9;">message</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> // &quot;Compressing image...&quot;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">  worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">exit</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> ()</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">    console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Compression task completed.</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">  }</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88C0D0;">compressImage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">/path/to/image.jpg</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#D8DEE9;">console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">  &quot;</span><span style="color:#A3BE8C;">This message does not have to wait for the image to be compressed.</span><span style="color:#ECEFF4;">&quot;</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个新的工作线程来处理图片压缩任务。这样，即使图片压缩任务正在进行，主线程也可以继续执行其他操作，比如立即打印出 &#39;This message does not have to wait...&#39;。这就是利用 Worker Threads 来提升 Node.js 应用性能和响应能力的一个实际例子。</p><h3 id="总结-12" tabindex="-1"><a class="header-anchor" href="#总结-12"><span>总结</span></a></h3><p>工作线程（Worker Threads）是 Node.js 提供的一个强大功能，允许应用程序通过创建额外线程来处理计算密集型任务，从而避免阻塞主线程，提高应用性能。虽然 Worker Threads 的概念初看起来可能有点复杂，但理解并开始利用它们可以极大地提升你的 Node.js 应用的能力。</p><h3 id="synchronous-blocking-of-stdio" tabindex="-1"><a class="header-anchor" href="#synchronous-blocking-of-stdio"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#synchronous-blocking-of-stdio" target="_blank" rel="noopener noreferrer">Synchronous blocking of stdio</a></span></a></h3><p>在 Node.js 中，<code>stdio</code>（标准输入输出）是用来和运行中的程序进行交互的一种方式。通常，<code>stdio</code>包括标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。这三者在编程中非常常见，用于读取输入、打印输出到控制台和报告错误信息。</p><p>在 Node.js v21.7.1 的文档中提到的“Synchronous blocking of stdio”指的是，在使用 worker threads（工作线程）时，标准输入输出的同步阻塞问题。简单来说，当你在 Node.js 中使用多线程（通过 worker threads 模块实现）时，主线程和工作线程之间的数据交换通常是异步的，但是，对于<code>stdio</code>的操作，默认情况下在工作线程中是同步阻塞的。这意味着，当一个工作线程在进行标准输入输出操作时，它会阻塞其他操作，直到该输入输出操作完成。</p><h3 id="实际运用例子-6" tabindex="-1"><a class="header-anchor" href="#实际运用例子-6"><span>实际运用例子</span></a></h3><ol><li><p><strong>日志记录</strong>：假设你的应用程序在多个工作线程中运行复杂的数据处理任务，而你想要记录每个线程处理的进度信息。使用同步阻塞的<code>stdout</code>来输出日志信息可以确保日志消息不会因为多线程的并发输出而交错混乱，每条日志消息按顺序完整地输出。</p></li><li><p><strong>读取配置文件</strong>：如果你的 Node.js 应用在启动时需要从标准输入读取配置信息，当使用工作线程时，可以通过同步阻塞的方式确保在主线程或工作线程中正确序列化地读取配置数据，防止因异步操作导致的读取顺序问题。</p></li><li><p><strong>错误报告</strong>：在多线程应用中，当某个工作线程遇到异常需要立即报告时，可以使用同步阻塞的<code>stderr</code>来输出错误信息。这样做可以确保错误报告立即得到处理，而不是被排在其他异步操作的后面。</p></li></ol><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><p>虽然同步阻塞的<code>stdio</code>在某些情况下是有益的，它也可能导致性能问题，尤其是在高并发环境下。因为当一个工作线程等待<code>stdio</code>操作完成时，它不能执行其他任务，这可能会导致资源利用率下降。因此，在设计应用时，要根据实际需求合理选择使用同步或异步的<code>stdio</code>操作。</p><h3 id="launching-worker-threads-from-preload-scripts" tabindex="-1"><a class="header-anchor" href="#launching-worker-threads-from-preload-scripts"><span><a href="https://nodejs.org/docs/latest/api/worker_threads.html#launching-worker-threads-from-preload-scripts" target="_blank" rel="noopener noreferrer">Launching worker threads from preload scripts</a></span></a></h3><p>在 Node.js 中，工作线程（Worker Threads）是用来执行 CPU 密集型任务的一种方式，以避免阻塞主线程，进而影响应用的性能。从 v21.7.1 版本开始，Node.js 允许在 preload 脚本中启动工作线程。这里我会先解释一下什么是 preload 脚本，然后再详细介绍如何从 preload 脚本中启动工作线程，以及这项功能的一些实际应用。</p><h3 id="什么是-preload-脚本" tabindex="-1"><a class="header-anchor" href="#什么是-preload-脚本"><span>什么是 Preload 脚本？</span></a></h3><p>Preload 脚本是在 Node.js 应用的主模块加载之前执行的脚本。这使得你可以预先加载一些必要的设置或者钩子（hooks），在应用的其他部分开始执行之前。你可以通过在命令行中使用 <code>--require</code>（或 <code>-r</code>）标志来指定 preload 脚本，比如：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#88C0D0;">node</span><span style="color:#A3BE8C;"> --require</span><span style="color:#A3BE8C;"> ./my-preload-script.js</span><span style="color:#A3BE8C;"> my-app.js</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这会先执行 <code>my-preload-script.js</code> 中的代码，然后执行 <code>my-app.js</code>。</p><h3 id="从-preload-脚本中启动工作线程" tabindex="-1"><a class="header-anchor" href="#从-preload-脚本中启动工作线程"><span>从 Preload 脚本中启动工作线程</span></a></h3><p>在 v21.7.1 版本以前，preload 脚本中通常不能启动工作线程，因为工作线程需要在应用的主逻辑中被创建和管理。但是，从这个版本开始，Node.js 允许在 preload 脚本中启动工作线程，这为应用的初始化和预处理提供了更大的灵活性。</p><p>例如，假设你有一个 CPU 密集型的任务，如图像处理或大数据计算，你可以在应用启动之初就在一个独立的线程中开始这项任务，而不会阻塞主线程。下面是一个简单的例子，展示了如何在 preload 脚本中启动一个工作线程：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="background-color:#2e3440ff;color:#d8dee9ff;"><pre class="shiki nord vp-code"><code><span class="line"><span style="color:#616E88;">// preload-script.js</span></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9;"> Worker</span><span style="color:#ECEFF4;"> }</span><span style="color:#81A1C1;"> =</span><span style="color:#88C0D0;"> require</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">worker_threads</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#81A1C1;">const</span><span style="color:#D8DEE9;"> worker</span><span style="color:#81A1C1;"> =</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> Worker</span><span style="color:#D8DEE9FF;">(</span></span>\n<span class="line"><span style="color:#ECEFF4;">  `</span></span>\n<span class="line"><span style="color:#A3BE8C;">  const { parentPort } = require(&#39;worker_threads&#39;);</span></span>\n<span class="line"><span style="color:#A3BE8C;">  parentPort.on(&#39;message&#39;, (msg) =&gt; {</span></span>\n<span class="line"><span style="color:#A3BE8C;">    console.log(&#39;Received in worker:&#39;, msg);</span></span>\n<span class="line"><span style="color:#A3BE8C;">    parentPort.postMessage(msg.toUpperCase());</span></span>\n<span class="line"><span style="color:#A3BE8C;">  });</span></span>\n<span class="line"><span style="color:#ECEFF4;">`</span><span style="color:#ECEFF4;">,</span></span>\n<span class="line"><span style="color:#ECEFF4;">  {</span><span style="color:#88C0D0;"> eval</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> true</span><span style="color:#ECEFF4;"> }</span></span>\n<span class="line"><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">on</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">message</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9;">msg</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;"> =&gt;</span><span style="color:#ECEFF4;"> {</span></span>\n<span class="line"><span style="color:#D8DEE9;">  console</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">log</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">Received in main thread:</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9;"> msg</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"><span style="color:#ECEFF4;">}</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#D8DEE9;">worker</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">postMessage</span><span style="color:#D8DEE9FF;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">hello world</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#D8DEE9FF;">)</span><span style="color:#81A1C1;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个工作线程来处理简单的字符串转换任务。这个工作线程在接收到主线程发送的消息后，将其转换为大写并发送回主线程。使用 preload 脚本启动工作线程意味着这个转换过程可以在你的应用执行任何其他逻辑之前开始，提高了效率。</p><h3 id="实际应用示例-10" tabindex="-1"><a class="header-anchor" href="#实际应用示例-10"><span>实际应用示例</span></a></h3><ol><li><p><strong>初始化预热</strong>：在应用启动时，可能需要加载大量数据到内存中，或者预先计算一些数据。通过在 preload 脚本中使用工作线程，可以并行地完成这些任务，而不会延迟应用的启动时间。</p></li><li><p><strong>性能监控</strong>：你可以在 preload 脚本中启动一个工作线程来监控应用性能，比如内存使用情况、CPU 使用率等，从而不影响主线程的性能。</p></li><li><p><strong>安全沙盒</strong>：如果你想在应用启动前先在一个隔离环境中运行一些代码（例如第三方库的代码审计），使用工作线程是一个很好的选择。</p></li></ol><p>通过在 preload 脚本中启动工作线程，Node.js 应用的开发者现在有了更多的灵活性来优化应用的启动性能和响应能力。这是 Node.js 不断进化，提供更多高级特性给开发者的一个例证。</p>',818)],o={},p=(0,a(8538).A)(o,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,l)}]]),r=JSON.parse('{"path":"/document/node-doc/Worker%20threads.html","title":"Worker threads","lang":"zh-CN","frontmatter":{"article":false,"description":"Worker threads 理解 Node.js 中的 Worker Threads（工作线程）对于提升你的编程技能是非常重要的，特别是当涉及到在单个 Node.js 进程中执行多任务并行处理时。我将尽量用简单易懂的语言给你解释这个概念，并通过一些实际的例子来帮助你更好地理解。 什么是 Worker Threads？ 首先，让我们了解 Node.js...","head":[["meta",{"property":"og:url","content":"https://hanekawa.top/document/node-doc/Worker%20threads.html"}],["meta",{"property":"og:site_name","content":"hanekawa-shiki"}],["meta",{"property":"og:title","content":"Worker threads"}],["meta",{"property":"og:description","content":"Worker threads 理解 Node.js 中的 Worker Threads（工作线程）对于提升你的编程技能是非常重要的，特别是当涉及到在单个 Node.js 进程中执行多任务并行处理时。我将尽量用简单易懂的语言给你解释这个概念，并通过一些实际的例子来帮助你更好地理解。 什么是 Worker Threads？ 首先，让我们了解 Node.js..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T09:46:17.000Z"}],["meta",{"property":"article:author","content":"hanekawa-shiki"}],["meta",{"property":"article:modified_time","content":"2024-06-21T09:46:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Worker threads\\",\\"description\\":\\"Worker threads 理解 Node.js 中的 Worker Threads（工作线程）对于提升你的编程技能是非常重要的，特别是当涉及到在单个 Node.js 进程中执行多任务并行处理时。我将尽量用简单易懂的语言给你解释这个概念，并通过一些实际的例子来帮助你更好地理解。 什么是 Worker Threads？ 首先，让我们了解 Node.js...\\"}"]]},"headers":[{"level":3,"title":"什么是 Worker Threads？","slug":"什么是-worker-threads","link":"#什么是-worker-threads","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例","link":"#实际运用示例","children":[]},{"level":3,"title":"结论","slug":"结论","link":"#结论","children":[]},{"level":2,"title":"worker.getEnvironmentData(key)","slug":"worker-getenvironmentdata-key","link":"#worker-getenvironmentdata-key","children":[{"level":3,"title":"实际运用","slug":"实际运用","link":"#实际运用","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"worker.isMainThread","slug":"worker-ismainthread","link":"#worker-ismainthread","children":[{"level":3,"title":"worker.isMainThread","slug":"worker-ismainthread-1","link":"#worker-ismainthread-1","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例","link":"#实际应用示例","children":[]}]},{"level":2,"title":"worker.markAsUntransferable(object)","slug":"worker-markasuntransferable-object","link":"#worker-markasuntransferable-object","children":[{"level":3,"title":"什么是 worker.markAsUntransferable(object)？","slug":"什么是-worker-markasuntransferable-object","link":"#什么是-worker-markasuntransferable-object","children":[]},{"level":3,"title":"为什么要使用 worker.markAsUntransferable(object)？","slug":"为什么要使用-worker-markasuntransferable-object","link":"#为什么要使用-worker-markasuntransferable-object","children":[]},{"level":3,"title":"实际例子","slug":"实际例子","link":"#实际例子","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]}]},{"level":2,"title":"worker.isMarkedAsUntransferable(object)","slug":"worker-ismarkedasuntransferable-object","link":"#worker-ismarkedasuntransferable-object","children":[{"level":3,"title":"实际应用例子","slug":"实际应用例子","link":"#实际应用例子","children":[]}]},{"level":2,"title":"worker.moveMessagePortToContext(port, contextifiedSandbox)","slug":"worker-movemessageporttocontext-port-contextifiedsandbox","link":"#worker-movemessageporttocontext-port-contextifiedsandbox","children":[{"level":3,"title":"实际应用示例","slug":"实际应用示例-1","link":"#实际应用示例-1","children":[]}]},{"level":2,"title":"worker.parentPort","slug":"worker-parentport","link":"#worker-parentport","children":[{"level":3,"title":"什么是 Worker 线程？","slug":"什么是-worker-线程","link":"#什么是-worker-线程","children":[]},{"level":3,"title":"worker.parentPort 是什么？","slug":"worker-parentport-是什么","link":"#worker-parentport-是什么","children":[]},{"level":3,"title":"如何使用 worker.parentPort？","slug":"如何使用-worker-parentport","link":"#如何使用-worker-parentport","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"worker.receiveMessageOnPort(port)","slug":"worker-receivemessageonport-port","link":"#worker-receivemessageonport-port","children":[{"level":3,"title":"多线程与 worker_threads 模块","slug":"多线程与-worker-threads-模块","link":"#多线程与-worker-threads-模块","children":[]},{"level":3,"title":"worker.receiveMessageOnPort(port)","slug":"worker-receivemessageonport-port-1","link":"#worker-receivemessageonport-port-1","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-1","link":"#实际运用示例-1","children":[]}]},{"level":2,"title":"worker.resourceLimits","slug":"worker-resourcelimits","link":"#worker-resourcelimits","children":[{"level":3,"title":"工作线程（Worker Threads）","slug":"工作线程-worker-threads","link":"#工作线程-worker-threads","children":[]},{"level":3,"title":"为什么需要资源限制","slug":"为什么需要资源限制","link":"#为什么需要资源限制","children":[]},{"level":3,"title":"worker.resourceLimits","slug":"worker-resourcelimits-1","link":"#worker-resourcelimits-1","children":[]}]},{"level":2,"title":"worker.SHARE_ENV","slug":"worker-share-env","link":"#worker-share-env","children":[{"level":3,"title":"基础知识","slug":"基础知识","link":"#基础知识","children":[]},{"level":3,"title":"worker.SHARE_ENV","slug":"worker-share-env-1","link":"#worker-share-env-1","children":[]},{"level":3,"title":"实例说明","slug":"实例说明","link":"#实例说明","children":[]}]},{"level":2,"title":"worker.setEnvironmentData(key[, value])","slug":"worker-setenvironmentdata-key-value","link":"#worker-setenvironmentdata-key-value","children":[{"level":3,"title":"1. Node.js 简介","slug":"_1-node-js-简介","link":"#_1-node-js-简介","children":[]},{"level":3,"title":"2. Worker 线程","slug":"_2-worker-线程","link":"#_2-worker-线程","children":[]},{"level":3,"title":"3. 环境数据（Environment Data）","slug":"_3-环境数据-environment-data","link":"#_3-环境数据-environment-data","children":[]},{"level":3,"title":"worker.setEnvironmentData(key[, value]) 方法","slug":"worker-setenvironmentdata-key-value-方法","link":"#worker-setenvironmentdata-key-value-方法","children":[]},{"level":3,"title":"总结","slug":"总结-3","link":"#总结-3","children":[]}]},{"level":2,"title":"worker.threadId","slug":"worker-threadid","link":"#worker-threadid","children":[{"level":3,"title":"worker.threadId","slug":"worker-threadid-1","link":"#worker-threadid-1","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子","link":"#实际运用例子","children":[]}]},{"level":2,"title":"worker.workerData","slug":"worker-workerdata","link":"#worker-workerdata","children":[{"level":3,"title":"Worker Threads 简介","slug":"worker-threads-简介","link":"#worker-threads-简介","children":[]},{"level":3,"title":"worker.workerData","slug":"worker-workerdata-1","link":"#worker-workerdata-1","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-1","link":"#实际运用例子-1","children":[]}]},{"level":2,"title":"Class: BroadcastChannel extends EventTarget","slug":"class-broadcastchannel-extends-eventtarget","link":"#class-broadcastchannel-extends-eventtarget","children":[{"level":3,"title":"什么是BroadcastChannel？","slug":"什么是broadcastchannel","link":"#什么是broadcastchannel","children":[]},{"level":3,"title":"如何工作？","slug":"如何工作","link":"#如何工作","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-2","link":"#实际运用示例-2","children":[]},{"level":3,"title":"总结","slug":"总结-4","link":"#总结-4","children":[]},{"level":3,"title":"new BroadcastChannel(name)","slug":"new-broadcastchannel-name","link":"#new-broadcastchannel-name","children":[]},{"level":3,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":3,"title":"如何使用","slug":"如何使用","link":"#如何使用","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-3","link":"#实际运用示例-3","children":[]},{"level":3,"title":"总结","slug":"总结-5","link":"#总结-5","children":[]},{"level":3,"title":"broadcastChannel.close()","slug":"broadcastchannel-close","link":"#broadcastchannel-close","children":[]},{"level":3,"title":"理解 BroadcastChannel","slug":"理解-broadcastchannel","link":"#理解-broadcastchannel","children":[]},{"level":3,"title":"使用 broadcastChannel.close()","slug":"使用-broadcastchannel-close","link":"#使用-broadcastchannel-close","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-1","link":"#实际运用的例子-1","children":[]},{"level":3,"title":"总结","slug":"总结-6","link":"#总结-6","children":[]},{"level":3,"title":"broadcastChannel.onmessage","slug":"broadcastchannel-onmessage","link":"#broadcastchannel-onmessage","children":[]},{"level":3,"title":"什么是 BroadcastChannel？","slug":"什么是-broadcastchannel","link":"#什么是-broadcastchannel","children":[]},{"level":3,"title":"如何使用 broadcastChannel.onmessage？","slug":"如何使用-broadcastchannel-onmessage","link":"#如何使用-broadcastchannel-onmessage","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-2","link":"#实际运用的例子-2","children":[]},{"level":3,"title":"broadcastChannel.onmessageerror","slug":"broadcastchannel-onmessageerror","link":"#broadcastchannel-onmessageerror","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-1","link":"#实际应用例子-1","children":[]},{"level":3,"title":"broadcastChannel.postMessage(message)","slug":"broadcastchannel-postmessage-message","link":"#broadcastchannel-postmessage-message","children":[]},{"level":3,"title":"Node.js 简介","slug":"node-js-简介","link":"#node-js-简介","children":[]},{"level":3,"title":"Worker Threads","slug":"worker-threads-1","link":"#worker-threads-1","children":[]},{"level":3,"title":"BroadcastChannel","slug":"broadcastchannel","link":"#broadcastchannel","children":[]},{"level":3,"title":"broadcastChannel.postMessage(message)","slug":"broadcastchannel-postmessage-message-1","link":"#broadcastchannel-postmessage-message-1","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-4","link":"#实际运用示例-4","children":[]},{"level":3,"title":"broadcastChannel.ref()","slug":"broadcastchannel-ref","link":"#broadcastchannel-ref","children":[]},{"level":3,"title":"broadcastChannel.ref()","slug":"broadcastchannel-ref-1","link":"#broadcastchannel-ref-1","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-2","link":"#实际应用示例-2","children":[]},{"level":3,"title":"broadcastChannel.unref()","slug":"broadcastchannel-unref","link":"#broadcastchannel-unref","children":[]},{"level":3,"title":"1. 什么是 BroadcastChannel？","slug":"_1-什么是-broadcastchannel","link":"#_1-什么是-broadcastchannel","children":[]},{"level":3,"title":"2. ref 和 unref 是什么？","slug":"_2-ref-和-unref-是什么","link":"#_2-ref-和-unref-是什么","children":[]},{"level":3,"title":"3. broadcastChannel.unref() 的作用","slug":"_3-broadcastchannel-unref-的作用","link":"#_3-broadcastchannel-unref-的作用","children":[]},{"level":3,"title":"实际运用的例子：","slug":"实际运用的例子-3","link":"#实际运用的例子-3","children":[]}]},{"level":2,"title":"Class: MessageChannel","slug":"class-messagechannel","link":"#class-messagechannel","children":[{"level":3,"title":"MessageChannel 简介","slug":"messagechannel-简介","link":"#messagechannel-简介","children":[]},{"level":3,"title":"MessageChannel 结构","slug":"messagechannel-结构","link":"#messagechannel-结构","children":[]},{"level":3,"title":"如何使用","slug":"如何使用-1","link":"#如何使用-1","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-3","link":"#实际应用示例-3","children":[]}]},{"level":2,"title":"Class: MessagePort","slug":"class-messageport","link":"#class-messageport","children":[{"level":3,"title":"MessagePort 简介","slug":"messageport-简介","link":"#messageport-简介","children":[]},{"level":3,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-2","link":"#实际运用例子-2","children":[]},{"level":3,"title":"Event: \'close\'","slug":"event-close","link":"#event-close","children":[]},{"level":3,"title":"Event: \'close\'","slug":"event-close-1","link":"#event-close-1","children":[]},{"level":3,"title":"Event: \'message\'","slug":"event-message","link":"#event-message","children":[]},{"level":3,"title":"如何使用 \'message\' 事件","slug":"如何使用-message-事件","link":"#如何使用-message-事件","children":[]},{"level":3,"title":"实际应用场景","slug":"实际应用场景","link":"#实际应用场景","children":[]},{"level":3,"title":"Event: \'messageerror\'","slug":"event-messageerror","link":"#event-messageerror","children":[]},{"level":3,"title":"什么是 worker_threads？","slug":"什么是-worker-threads-1","link":"#什么是-worker-threads-1","children":[]},{"level":3,"title":"Event: \'messageerror\'","slug":"event-messageerror-1","link":"#event-messageerror-1","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-2","link":"#实际应用例子-2","children":[]},{"level":3,"title":"port.close()","slug":"port-close","link":"#port-close","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-3","link":"#实际运用例子-3","children":[]},{"level":3,"title":"port.postMessage(value[, transferList])","slug":"port-postmessage-value-transferlist","link":"#port-postmessage-value-transferlist","children":[]},{"level":3,"title":"基础概念","slug":"基础概念","link":"#基础概念","children":[]},{"level":3,"title":"解析 port.postMessage(value[, transferList])","slug":"解析-port-postmessage-value-transferlist","link":"#解析-port-postmessage-value-transferlist","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-3","link":"#实际应用例子-3","children":[]},{"level":3,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":3,"title":"传输 VS. 共享","slug":"传输-vs-共享","link":"#传输-vs-共享","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-4","link":"#实际应用例子-4","children":[]},{"level":3,"title":"结论","slug":"结论-1","link":"#结论-1","children":[]},{"level":3,"title":"原型和类实例","slug":"原型和类实例","link":"#原型和类实例","children":[]},{"level":3,"title":"访问器属性（Getter/Setter）","slug":"访问器属性-getter-setter","link":"#访问器属性-getter-setter","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-4","link":"#实际运用的例子-4","children":[]},{"level":3,"title":"结论","slug":"结论-2","link":"#结论-2","children":[]},{"level":3,"title":"port.hasRef()","slug":"port-hasref","link":"#port-hasref","children":[]},{"level":3,"title":"port.hasRef()","slug":"port-hasref-1","link":"#port-hasref-1","children":[]},{"level":3,"title":"port.ref()","slug":"port-ref","link":"#port-ref","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-5","link":"#实际应用示例-5","children":[]},{"level":3,"title":"port.start()","slug":"port-start","link":"#port-start","children":[]},{"level":3,"title":"理解 port.start()","slug":"理解-port-start","link":"#理解-port-start","children":[]},{"level":3,"title":"使用 port.start()","slug":"使用-port-start","link":"#使用-port-start","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-6","link":"#实际应用示例-6","children":[]},{"level":3,"title":"总结","slug":"总结-7","link":"#总结-7","children":[]},{"level":3,"title":"port.unref()","slug":"port-unref","link":"#port-unref","children":[]},{"level":3,"title":"什么是 port.unref()?","slug":"什么是-port-unref","link":"#什么是-port-unref","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-5","link":"#实际运用的例子-5","children":[]},{"level":3,"title":"总结","slug":"总结-8","link":"#总结-8","children":[]}]},{"level":2,"title":"Class: Worker","slug":"class-worker","link":"#class-worker","children":[{"level":3,"title":"如何工作？","slug":"如何工作-1","link":"#如何工作-1","children":[]},{"level":3,"title":"基本用法示例：","slug":"基本用法示例","link":"#基本用法示例","children":[]},{"level":3,"title":"实际应用场景","slug":"实际应用场景-1","link":"#实际应用场景-1","children":[]},{"level":3,"title":"new Worker(filename[, options])","slug":"new-worker-filename-options","link":"#new-worker-filename-options","children":[]},{"level":3,"title":"基本概念","slug":"基本概念-1","link":"#基本概念-1","children":[]},{"level":3,"title":"实际例子","slug":"实际例子-1","link":"#实际例子-1","children":[]},{"level":3,"title":"Event: \'error\'","slug":"event-error","link":"#event-error","children":[]},{"level":3,"title":"例子解释","slug":"例子解释","link":"#例子解释","children":[]},{"level":3,"title":"Event: \'exit\'","slug":"event-exit","link":"#event-exit","children":[]},{"level":3,"title":"什么是 Event: \'exit\'？","slug":"什么是-event-exit","link":"#什么是-event-exit","children":[]},{"level":3,"title":"为什么需要关注 \'exit\' 事件？","slug":"为什么需要关注-exit-事件","link":"#为什么需要关注-exit-事件","children":[]},{"level":3,"title":"如何使用 \'exit\' 事件？","slug":"如何使用-exit-事件","link":"#如何使用-exit-事件","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-6","link":"#实际运用的例子-6","children":[]},{"level":3,"title":"Event: \'message\'","slug":"event-message-1","link":"#event-message-1","children":[]},{"level":3,"title":"Node.js 简介","slug":"node-js-简介-1","link":"#node-js-简介-1","children":[]},{"level":3,"title":"事件（Events）","slug":"事件-events","link":"#事件-events","children":[]},{"level":3,"title":"工作线程（Worker Threads）","slug":"工作线程-worker-threads-1","link":"#工作线程-worker-threads-1","children":[]},{"level":3,"title":"Event: \'message\'","slug":"event-message-2","link":"#event-message-2","children":[]},{"level":3,"title":"Event: \'messageerror\'","slug":"event-messageerror-2","link":"#event-messageerror-2","children":[]},{"level":3,"title":"背景：Worker Threads","slug":"背景-worker-threads","link":"#背景-worker-threads","children":[]},{"level":3,"title":"Event: \'messageerror\'","slug":"event-messageerror-3","link":"#event-messageerror-3","children":[]},{"level":3,"title":"实际运用的例子","slug":"实际运用的例子-7","link":"#实际运用的例子-7","children":[]},{"level":3,"title":"Event: \'online\'","slug":"event-online","link":"#event-online","children":[]},{"level":3,"title":"Event: \'online\'","slug":"event-online-1","link":"#event-online-1","children":[]},{"level":3,"title":"worker.getHeapSnapshot([options])","slug":"worker-getheapsnapshot-options","link":"#worker-getheapsnapshot-options","children":[]},{"level":3,"title":"解释 worker.getHeapSnapshot([options])","slug":"解释-worker-getheapsnapshot-options","link":"#解释-worker-getheapsnapshot-options","children":[]},{"level":3,"title":"worker.performance","slug":"worker-performance","link":"#worker-performance","children":[]},{"level":3,"title":"Node.js 简介","slug":"node-js-简介-2","link":"#node-js-简介-2","children":[]},{"level":3,"title":"Worker 线程","slug":"worker-线程","link":"#worker-线程","children":[]},{"level":3,"title":"worker.performance","slug":"worker-performance-1","link":"#worker-performance-1","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-5","link":"#实际应用例子-5","children":[]},{"level":3,"title":"总结","slug":"总结-9","link":"#总结-9","children":[]},{"level":3,"title":"什么是 Event Loop（事件循环）？","slug":"什么是-event-loop-事件循环","link":"#什么是-event-loop-事件循环","children":[]},{"level":3,"title":"Event Loop Utilization（事件循环利用率）","slug":"event-loop-utilization-事件循环利用率","link":"#event-loop-utilization-事件循环利用率","children":[]},{"level":3,"title":"performance.eventLoopUtilization() 方法","slug":"performance-eventlooputilization-方法","link":"#performance-eventlooputilization-方法","children":[]},{"level":3,"title":"实际例子","slug":"实际例子-2","link":"#实际例子-2","children":[]},{"level":3,"title":"总结","slug":"总结-10","link":"#总结-10","children":[]},{"level":3,"title":"worker.postMessage(value[, transferList])","slug":"worker-postmessage-value-transferlist","link":"#worker-postmessage-value-transferlist","children":[]},{"level":3,"title":"什么是 worker.postMessage(value[, transferList])?","slug":"什么是-worker-postmessage-value-transferlist","link":"#什么是-worker-postmessage-value-transferlist","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-4","link":"#实际运用例子-4","children":[]},{"level":3,"title":"worker.ref()","slug":"worker-ref","link":"#worker-ref","children":[]},{"level":3,"title":"worker.ref()","slug":"worker-ref-1","link":"#worker-ref-1","children":[]},{"level":3,"title":"实际例子","slug":"实际例子-3","link":"#实际例子-3","children":[]},{"level":3,"title":"worker.resourceLimits","slug":"worker-resourcelimits-2","link":"#worker-resourcelimits-2","children":[]},{"level":3,"title":"什么是 worker.resourceLimits?","slug":"什么是-worker-resourcelimits","link":"#什么是-worker-resourcelimits","children":[]},{"level":3,"title":"worker.resourceLimits 包含哪些限制？","slug":"worker-resourcelimits-包含哪些限制","link":"#worker-resourcelimits-包含哪些限制","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-8","link":"#实际应用示例-8","children":[]},{"level":3,"title":"结语","slug":"结语","link":"#结语","children":[]},{"level":3,"title":"worker.stderr","slug":"worker-stderr","link":"#worker-stderr","children":[]},{"level":3,"title":"什么是 worker.stderr？","slug":"什么是-worker-stderr","link":"#什么是-worker-stderr","children":[]},{"level":3,"title":"实际应用例子","slug":"实际应用例子-6","link":"#实际应用例子-6","children":[]},{"level":3,"title":"worker.stdin","slug":"worker-stdin","link":"#worker-stdin","children":[]},{"level":3,"title":"worker.stdin 简介","slug":"worker-stdin-简介","link":"#worker-stdin-简介","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-7","link":"#实际运用示例-7","children":[]},{"level":3,"title":"总结","slug":"总结-11","link":"#总结-11","children":[]},{"level":3,"title":"worker.stdout","slug":"worker-stdout","link":"#worker-stdout","children":[]},{"level":3,"title":"什么是 worker.stdout？","slug":"什么是-worker-stdout","link":"#什么是-worker-stdout","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-5","link":"#实际运用例子-5","children":[]},{"level":3,"title":"worker.terminate()","slug":"worker-terminate","link":"#worker-terminate","children":[]},{"level":3,"title":"worker.terminate()","slug":"worker-terminate-1","link":"#worker-terminate-1","children":[]},{"level":3,"title":"worker.threadId","slug":"worker-threadid-2","link":"#worker-threadid-2","children":[]},{"level":3,"title":"什么是 worker_threads?","slug":"什么是-worker-threads-2","link":"#什么是-worker-threads-2","children":[]},{"level":3,"title":"什么是 worker.threadId？","slug":"什么是-worker-threadid","link":"#什么是-worker-threadid","children":[]},{"level":3,"title":"实际运用示例：","slug":"实际运用示例-8","link":"#实际运用示例-8","children":[]},{"level":3,"title":"worker.unref()","slug":"worker-unref","link":"#worker-unref","children":[]},{"level":3,"title":"工作线程（Worker Threads）简介","slug":"工作线程-worker-threads-简介","link":"#工作线程-worker-threads-简介","children":[]},{"level":3,"title":"worker.unref()方法","slug":"worker-unref-方法","link":"#worker-unref-方法","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"Notes","slug":"notes","link":"#notes","children":[{"level":3,"title":"什么是 Node.js？","slug":"什么是-node-js","link":"#什么是-node-js","children":[]},{"level":3,"title":"为什么需要工作线程（Worker Threads）？","slug":"为什么需要工作线程-worker-threads","link":"#为什么需要工作线程-worker-threads","children":[]},{"level":3,"title":"实际运用示例","slug":"实际运用示例-9","link":"#实际运用示例-9","children":[]},{"level":3,"title":"总结","slug":"总结-12","link":"#总结-12","children":[]},{"level":3,"title":"Synchronous blocking of stdio","slug":"synchronous-blocking-of-stdio","link":"#synchronous-blocking-of-stdio","children":[]},{"level":3,"title":"实际运用例子","slug":"实际运用例子-6","link":"#实际运用例子-6","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]},{"level":3,"title":"Launching worker threads from preload scripts","slug":"launching-worker-threads-from-preload-scripts","link":"#launching-worker-threads-from-preload-scripts","children":[]},{"level":3,"title":"什么是 Preload 脚本？","slug":"什么是-preload-脚本","link":"#什么是-preload-脚本","children":[]},{"level":3,"title":"从 Preload 脚本中启动工作线程","slug":"从-preload-脚本中启动工作线程","link":"#从-preload-脚本中启动工作线程","children":[]},{"level":3,"title":"实际应用示例","slug":"实际应用示例-10","link":"#实际应用示例-10","children":[]}]}],"git":{"createdTime":1718963177000,"updatedTime":1718963177000,"contributors":[{"name":"kamishima-kaede","email":"kamiacgxu@gmail.com","commits":1}]},"readingTime":{"minutes":132.34,"words":39701},"filePathRelative":"document/node-doc/Worker threads.md","localizedDate":"2024年6月21日","excerpt":"\\n<p>理解 Node.js 中的 Worker Threads（工作线程）对于提升你的编程技能是非常重要的，特别是当涉及到在单个 Node.js 进程中执行多任务并行处理时。我将尽量用简单易懂的语言给你解释这个概念，并通过一些实际的例子来帮助你更好地理解。</p>\\n<h3>什么是 Worker Threads？</h3>\\n<p>首先，让我们了解 Node.js 的基础。Node.js 是单线程的，这意味着默认情况下，所有你的代码都在一个主线程上顺序执行。对于 IO 密集型的操作（如读写文件、网络请求等），这种模型效率很高，因为它们是异步非阻塞的，可以在等待 IO 操作完成时执行其他脚本代码。但对于 CPU 密集型的任务（如大量计算），这可能会导致应用性能下降，因为这些计算会阻塞主线程，直到完成为止。</p>","autoDesc":true}')},8538:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}}}]);