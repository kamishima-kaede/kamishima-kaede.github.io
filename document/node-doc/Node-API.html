<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.50" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://hanekawa.top/document/node-doc/Node-API.html"><meta property="og:site_name" content="hanekawa-shiki"><meta property="og:title" content="Node-API"><meta property="og:description" content="Node-API Node-API（以前称为 N-API）是 Node.js 提供的一个 API 层，它允许你用 C 或 C++编写插件。之所以使用 Node-API，主要是因为它提供了一种与底层 JavaScript 引擎（如 V8）解耦的方式来构建原生扩展。这意味着当 Node.js 更新其内部引擎时，使用 Node-API 构建的插件不需要重写来..."><meta property="og:type" content="website"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-06-21T09:46:17.000Z"><meta property="article:author" content="hanekawa-shiki"><meta property="article:modified_time" content="2024-06-21T09:46:17.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","name":"Node-API","description":"Node-API Node-API（以前称为 N-API）是 Node.js 提供的一个 API 层，它允许你用 C 或 C++编写插件。之所以使用 Node-API，主要是因为它提供了一种与底层 JavaScript 引擎（如 V8）解耦的方式来构建原生扩展。这意味着当 Node.js 更新其内部引擎时，使用 Node-API 构建的插件不需要重写来..."}</script><meta name="keywords" content="JavaScript,HTML,CSS"><link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icons/chrome-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icons/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icons/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icons/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#5c92d1"><link rel="apple-touch-icon" href="/assets/icons/apple-touch-icon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><title>Node-API | hanekawa-shiki</title><meta name="description" content="Node-API Node-API（以前称为 N-API）是 Node.js 提供的一个 API 层，它允许你用 C 或 C++编写插件。之所以使用 Node-API，主要是因为它提供了一种与底层 JavaScript 引擎（如 V8）解耦的方式来构建原生扩展。这意味着当 Node.js 更新其内部引擎时，使用 Node-API 构建的插件不需要重写来...">
    <link rel="stylesheet" href="/assets/css/styles.6fad2577.css">
    <link rel="preload" href="/assets/js/runtime~app.2cf91084.js" as="script"><link rel="preload" href="/assets/css/styles.6fad2577.css" as="style"><link rel="preload" href="/assets/js/7531.f2f134c8.js" as="script"><link rel="preload" href="/assets/js/app.a2d0f323.js" as="script">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo light" src="/assets/svg/logo.svg" alt><img class="vp-nav-logo dark" src="/assets/svg/logo.svg" alt><span class="vp-site-name hide-in-pad">hanekawa-shiki</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="博客主页"><!--[--><span class="font-icon icon home" style=""></span><!--]-->博客主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="学习笔记"><!--[--><span class="font-icon icon framework" style=""></span>学习笔记<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">前端框架</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/framework_front/vue3/" aria-label="Vue3笔记"><!--[--><span class="font-icon icon vue" style=""></span><!--]-->Vue3笔记<!----></a></li><li class="vp-dropdown-subitem"><a class="route-link auto-link" href="/framework_front/react/" aria-label="React笔记"><!--[--><span class="font-icon icon react" style=""></span><!--]-->React笔记<!----></a></li></ul></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="文档"><!--[--><span class="font-icon icon framework" style=""></span>文档<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><h4 class="vp-dropdown-subtitle">搬运</h4><ul class="vp-dropdown-subitems"><li class="vp-dropdown-subitem"><a class="route-link route-link-active auto-link" href="/document/node-doc/" aria-label="Node.js文档"><!--[--><span class="font-icon icon circle-info" style=""></span><!--]-->Node.js文档<!----></a></li></ul></li></ul></button></div></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/hanekawa-shiki/hanekawa-shiki.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/" aria-label="Node.js文档"><!--[--><span class="font-icon icon circle-info" style=""></span><!--]-->Node.js文档<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Assert.html" aria-label="Assert"><!---->Assert<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Async%20hooks.html" aria-label="Async hooks"><!---->Async hooks<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Asynchronous%20context%20tracking.html" aria-label="Asynchronous context tracking"><!---->Asynchronous context tracking<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Buffer.html" aria-label="Buffer"><!---->Buffer<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/C__%20addons.html" aria-label="C++ addons"><!---->C++ addons<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/C__%20embedder%20API.html" aria-label="C++ embedder API"><!---->C++ embedder API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Child%20process.html" aria-label="Child process"><!---->Child process<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Cluster.html" aria-label="Cluster"><!---->Cluster<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Command-line%20API.html" aria-label="Command-line API"><!---->Command-line API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Console.html" aria-label="Console"><!---->Console<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Corepack.html" aria-label="Corepack"><!---->Corepack<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Crypto.html" aria-label="Crypto"><!---->Crypto<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Debugger.html" aria-label="Debugger"><!---->Debugger<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Deprecated%20APIs.html" aria-label="Deprecated APIs"><!---->Deprecated APIs<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Diagnostic%20report.html" aria-label="Diagnostic report"><!---->Diagnostic report<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Diagnostics%20Channel.html" aria-label="Diagnostics Channel"><!---->Diagnostics Channel<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/DNS.html" aria-label="DNS"><!---->DNS<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Domain.html" aria-label="Domain"><!---->Domain<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Errors.html" aria-label="Errors"><!---->Errors<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Events.html" aria-label="Events"><!---->Events<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/File%20system.html" aria-label="File system"><!---->File system<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Global%20objects.html" aria-label="Global objects"><!---->Global objects<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/HTTP.html" aria-label="HTTP"><!---->HTTP<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/HTTPS.html" aria-label="HTTPS"><!---->HTTPS<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Inspector.html" aria-label="Inspector"><!---->Inspector<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Internationalization%20support.html" aria-label="Internationalization support"><!---->Internationalization support<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Modules-CommonJS%20modules.html" aria-label="Modules: CommonJS modules"><!---->Modules: CommonJS modules<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Modules-ECMAScript%20modules.html" aria-label="Modules: ECMAScript modules"><!---->Modules: ECMAScript modules<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Modules-node%20module%20API.html" aria-label="Modules: node:module API"><!---->Modules: node:module API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Modules-Packages.html" aria-label="Modules: Packages"><!---->Modules: Packages<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Net.html" aria-label="Net"><!---->Net<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/document/node-doc/Node-API.html" aria-label="Node-API"><!---->Node-API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/OS.html" aria-label="OS"><!---->OS<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Path.html" aria-label="Path"><!---->Path<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Performance%20measurement%20APIs.html" aria-label="Performance measurement APIs"><!---->Performance measurement APIs<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Permissions.html" aria-label="Permissions"><!---->Permissions<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Process.html" aria-label="Process"><!---->Process<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Punycode.html" aria-label="Punycode"><!---->Punycode<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Query%20string.html" aria-label="Query string"><!---->Query string<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Readline.html" aria-label="Readline"><!---->Readline<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/REPL.html" aria-label="REPL"><!---->REPL<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Stream.html" aria-label="Stream"><!---->Stream<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/String%20decoder.html" aria-label="String decoder"><!---->String decoder<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Test%20runner.html" aria-label="Test runner"><!---->Test runner<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Timers.html" aria-label="Timers"><!---->Timers<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/TLS%20(SSL).html" aria-label="TLS (SSL)"><!---->TLS (SSL)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Trace%20events.html" aria-label="Trace events"><!---->Trace events<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/TTY.html" aria-label="TTY"><!---->TTY<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/URL.html" aria-label="URL"><!---->URL<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Util.html" aria-label="Util"><!---->Util<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/V8.html" aria-label="V8"><!---->V8<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/VM%20(executing%20JavaScript).html" aria-label="VM (executing JavaScript)"><!---->VM (executing JavaScript)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Web%20Crypto%20API.html" aria-label="Web Crypto API"><!---->Web Crypto API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Web%20Streams%20API.html" aria-label="Web Streams API"><!---->Web Streams API<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/WebAssembly%20System%20Interface%20(WASI).html" aria-label="WebAssembly System Interface (WASI)"><!---->WebAssembly System Interface (WASI)<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Worker%20threads.html" aria-label="Worker threads"><!---->Worker threads<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/document/node-doc/Zlib.html" aria-label="Zlib"><!---->Zlib<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Node-API</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://hanekawa.top" target="_blank" rel="noopener noreferrer">hanekawa-shiki</a></span><span property="author" content="hanekawa-shiki"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-06-21T09:46:17.000Z"></span><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 546 分钟</span><meta property="timeRequired" content="PT546M"></span><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon" name="word"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 163717 字</span><meta property="wordCount" content="163717"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#implications-of-abi-stability">Implications of ABI stability</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#abi-稳定性的影响">ABI 稳定性的影响</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子">实际运用的例子：</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#building">Building</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#构建原生模块的步骤">构建原生模块的步骤</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#build-tools">Build tools</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#uploading-precompiled-binaries">Uploading precompiled binaries</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#为什么需要-node-pre-gyp">为什么需要 node-pre-gyp？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用例子">实际运用例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何使用-node-pre-gyp">如何使用 node-pre-gyp</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#prebuildify-使用">prebuildify 使用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-1">实际例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#usage">Usage</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#node-api-version-matrix">Node-API version matrix</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#environment-life-cycle-apis">Environment life cycle APIs</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-创建和销毁环境">1. 创建和销毁环境</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-环境数据管理">2. 环境数据管理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用举例">实际应用举例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-set-instance-data">napi_set_instance_data</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-instance-data">napi_get_instance_data</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景举例">使用场景举例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例代码片段">示例代码片段</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#basic-node-api-data-types">Basic Node-API data types</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-status">napi_status</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-1">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-extended-error-info">napi_extended_error_info</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-extended-error-info-1">napi_extended_error_info</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-env">napi_env</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-nogc-env">node_api_nogc_env</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#什么是-n-api">什么是 N-API？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#垃圾回收器-gc-是什么">垃圾回收器（GC）是什么？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-nogc-env-的作用">node_api_nogc_env 的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-value">napi_value</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-value-1">napi_value</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-threadsafe-function">napi_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-threadsafe-function-使用场景和例子">napi_threadsafe_function 使用场景和例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-threadsafe-function-release-mode">napi_threadsafe_function_release_mode</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-threadsafe-function-call-mode">napi_threadsafe_function_call_mode</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-2">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-memory-management-types">Node-API memory management types</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-callback-types">Node-API callback types</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例理解-napi-callback-info">示例理解 napi_callback_info</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用例子-2">实际运用例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#概念">概念</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用例子">使用例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#error-handling">Error handling</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#return-values">Return values</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-1-创建一个新的-javascript-字符串">示例 1：创建一个新的 JavaScript 字符串</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-2-从函数中返回数值">示例 2：从函数中返回数值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用-napi-get-last-error-info-的步骤">使用 napi_get_last_error_info 的步骤：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-last-error-info-的实际例子">napi_get_last_error_info 的实际例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#exceptions">Exceptions</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#抛出一个异常">抛出一个异常</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#捕获并处理异常">捕获并处理异常</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用示例">实际运用示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名">函数签名：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值">返回值：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用示例-1">实际运用示例：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-error-1">napi_is_error</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-3">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#什么是-napi-create-error">什么是 napi_create_error？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-create-error-函数参数和返回值">napi_create_error 函数参数和返回值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何使用-napi-create-error">如何使用 napi_create_error</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#总结">总结</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用-napi-create-type-error">使用 napi_create_type_error</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#总结-1">总结</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-1-创建一个简单的-syntaxerror">例子 1: 创建一个简单的 SyntaxError</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-2-在检测到无效输入时使用-syntaxerror">例子 2: 在检测到无效输入时使用 SyntaxError</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#fatal-errors">Fatal errors</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#fatal-errors-1">Fatal errors</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#object-lifetime-management">Object lifetime management</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#引用-reference">引用 (Reference)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-4">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注意事项">注意事项</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#making-handle-lifespan-shorter-than-that-of-the-native-method">Making handle lifespan shorter than that of the native method</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例">示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#references-to-values-with-a-lifespan-longer-than-that-of-the-native-method">References to values with a lifespan longer than that of the native method</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#引用与寿命">引用与寿命</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用示例-2">实际运用示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-3">实际运用的例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用步骤">使用步骤</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-2">函数签名</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数返回值">函数返回值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-1">示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注意事项-1">注意事项</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#cleanup-on-exit-of-the-current-node-js-environment">Cleanup on exit of the current Node.js environment</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#finalization-on-the-exit-of-the-node-js-environment">Finalization on the exit of the Node.js environment</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#module-registration">Module registration</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#步骤-1-创建原生模块源文件">步骤 1: 创建原生模块源文件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#步骤-2-编译原生模块">步骤 2: 编译原生模块</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#步骤-3-加载和使用模块">步骤 3: 加载和使用模块</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-4">实际运用的例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#working-with-javascript-values">Working with JavaScript values</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#enum-types">Enum types</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-valuetype-枚举">napi_valuetype 枚举</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-5">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#object-creation-functions">Object creation functions</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-创建一个新的空对象">1. 创建一个新的空对象</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-创建一个具有属性的对象">2. 创建一个具有属性的对象</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-创建数组">3. 创建数组</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子">例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#关键概念">关键概念：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-symbol-for-函数的作用和运用">node_api_symbol_for 函数的作用和运用:</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景总结">使用场景总结：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#functions-to-convert-from-c-types-to-node-api">Functions to convert from C types to Node-API</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-3">函数签名</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-5">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型">函数原型：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景">使用场景：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-6">实际例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#功能">功能</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#参数">参数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景举例-1">使用场景举例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注意事项-2">注意事项</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#解释-napi-create-string-utf8">解释 napi_create_string_utf8</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#参数-1">参数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值-2">返回值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#代码示例">代码示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#functions-to-convert-from-node-api-to-c-types">Functions to convert from Node-API to C types</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-1-转换数字">示例 1：转换数字</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-2-转换字符串">示例 2：转换字符串</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-3-转换函数-回调">示例 3：转换函数（回调）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实战例子">实战例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数声明">函数声明</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-2">示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-c-c-侧">示例 - C/C++侧</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-javascript-侧">示例 - JavaScript 侧</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-重新获取-c-c-数据">示例 - 重新获取 C/C++数据</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景-1">使用场景</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型-1">函数原型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值-3">返回值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实例代码">实例代码</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-js-中的-napi-get-value-int64">Node.js 中的 napi_get_value_int64</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-value-string-utf8-1">napi_get_value_string_utf8</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-1">例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#functions-to-get-global-instances">Functions to get global instances</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-global">napi_get_global</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-constructor">napi_get_constructor</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#应用例子">应用例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#working-with-javascript-values-and-abstract-operations">Working with JavaScript values and abstract operations</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#javascript-值-values">JavaScript 值 (Values)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#抽象操作-abstract-operations">抽象操作 (Abstract Operations)</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-coerce-to-bool">napi_coerce_to_bool</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何理解-bool">如何理解 bool</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-coerce-to-bool-的作用">napi_coerce_to_bool 的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用-napi-coerce-to-bool">使用 napi_coerce_to_bool</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用示例-3">实际运用示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-coerce-to-number">napi_coerce_to_number</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-coerce-to-object">napi_coerce_to_object</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实例-1-将数字转换为对象">实例 1：将数字转换为对象</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实例-2-将字符串转换为对象">实例 2：将字符串转换为对象</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-coerce-to-string">napi_coerce_to_string</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-typeof">napi_typeof</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-instanceof">napi_instanceof</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-array">napi_is_array</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用-napi-is-array-函数的步骤">使用 napi_is_array 函数的步骤</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-6">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-arraybuffer">napi_is_arraybuffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-buffer">napi_is_buffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-date">napi_is_date</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-error-2">napi_is_error</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#参数解释">参数解释</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景举例-2">使用场景举例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-typedarray">napi_is_typedarray</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-typedarray-1">napi_is_typedarray</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-dataview">napi_is_dataview</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-dataview-1">napi_is_dataview</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-strict-equals">napi_strict_equals</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-detach-arraybuffer">napi_detach_arraybuffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#arraybuffer-简介">ArrayBuffer 简介</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#n-api-简介">N-API 简介</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-detach-arraybuffer-1">napi_detach_arraybuffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-7">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-detached-arraybuffer">napi_is_detached_arraybuffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-8">实际运用的例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#working-with-javascript-properties">Working with JavaScript properties</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#创建属性">创建属性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#获取属性值">获取属性值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#设置属性值">设置属性值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#操作对象的属性">操作对象的属性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#structures">Structures</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#functions">Functions</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-创建原生对象">1. 创建原生对象</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-调用-javascript-函数">2. 调用 JavaScript 函数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-4">函数签名</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#参数解释-1">参数解释</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用示例">实际应用示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用例子-3">实际运用例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-delete-property-1">napi_delete_property</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用例子-4">实际运用例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景解释">使用场景解释：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-5">函数签名：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值-7">返回值：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-8">实际例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-6">函数签名</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-9">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型-2">函数原型：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值-8">返回值：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际使用例子">实际使用例子：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数签名-7">函数签名</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#返回值-9">返回值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#举例说明">举例说明</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#working-with-javascript-functions">Working with JavaScript functions</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#调用-javascript-函数">调用 JavaScript 函数：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#创建新的-javascript-函数">创建新的 JavaScript 函数：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#传递参数给-javascript-函数">传递参数给 JavaScript 函数：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-call-function">napi_call_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-create-function">napi_create_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#基本使用">基本使用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-9">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-cb-info">napi_get_cb_info</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-new-target">napi_get_new_target</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-new-instance">napi_new_instance</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-new-instance-1">napi_new_instance</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#object-wrap">Object wrap</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#object-wrap-的基本原理">Object Wrap 的基本原理：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#举例说明-1">举例说明：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-define-class">napi_define_class</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-wrap">napi_wrap</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型-3">函数原型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景-2">使用场景</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-unwrap">napi_unwrap</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-remove-wrap">napi_remove_wrap</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-3">例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-type-tag-object">napi_type_tag_object</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-check-object-type-tag">napi_check_object_type_tag</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型-4">函数原型：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景-3">使用场景：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-add-finalizer">napi_add_finalizer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#作用">作用:</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景示例">使用场景示例:</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注意事项-3">注意事项:</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#simple-asynchronous-operations">Simple asynchronous operations</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-create-async-work">napi_create_async_work</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何使用-napi-create-async-work">如何使用 napi_create_async_work</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-delete-async-work">napi_delete_async_work</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-queue-async-work">napi_queue_async_work</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-cancel-async-work">napi_cancel_async_work</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#custom-asynchronous-operations">Custom asynchronous operations</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用例子-1">实际应用例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-async-init">napi_async_init</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-async-init-1">napi_async_init</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景和例子">使用场景和例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-async-destroy">napi_async_destroy</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-async-destroy-的作用">napi_async_destroy 的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用场景举例-3">使用场景举例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-make-callback">napi_make_callback</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-open-callback-scope">napi_open_callback_scope</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-close-callback-scope">napi_close_callback_scope</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#version-management">Version management</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-node-version">napi_get_node_version</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-version">napi_get_version</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#memory-management">Memory management</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-buffer-和-typedarray">1. Buffer 和 TypedArray</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-垃圾回收-garbage-collection">2. 垃圾回收（Garbage Collection）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-n-api-中的内存管理函数">3. N-API 中的内存管理函数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用的例子-创建一个外部-buffer">实际应用的例子 - 创建一个外部 Buffer</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-adjust-external-memory">napi_adjust_external_memory</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#promises">Promises</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-1-读取文件">例子 1：读取文件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-2-网络请求">例子 2：网络请求</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-3-链式操作">例子 3：链式操作</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-create-promise">napi_create_promise</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-resolve-deferred">napi_resolve_deferred</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-reject-deferred">napi_reject_deferred</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实践示例">实践示例</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-is-promise">napi_is_promise</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#script-execution">Script execution</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-1-执行简单脚本">示例 1: 执行简单脚本</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-2-使用-n-api-执行脚本">示例 2: 使用 N-API 执行脚本</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-run-script">napi_run_script</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#函数原型-5">函数原型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何使用">如何使用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-10">实际例子</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#libuv-event-loop">libuv event loop</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-1-文件读取">例子 1：文件读取</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-2-网络请求-1">例子 2：网络请求</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-3-实时聊天应用">例子 3：实时聊天应用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-uv-event-loop">napi_get_uv_event_loop</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#用途">用途</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#示例-3">示例</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#asynchronous-thread-safe-function-calls">Asynchronous thread-safe function calls</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#thread-safe-function">Thread-safe function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用例子-2">实际应用例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#calling-a-thread-safe-function">Calling a thread-safe function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#reference-counting-of-thread-safe-functions">Reference counting of thread-safe functions</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#reference-counting-of-thread-safe-functions-1">Reference Counting of Thread-Safe Functions</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#deciding-whether-to-keep-the-process-running">Deciding whether to keep the process running</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-1-启动后台任务">例子 1：启动后台任务</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子-2-停止后台任务">例子 2：停止后台任务</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-create-threadsafe-function">napi_create_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#基本概念">基本概念</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#工作机制">工作机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际例子-11">实际例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-get-threadsafe-function-context">napi_get_threadsafe_function_context</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-call-threadsafe-function">napi_call_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-acquire-threadsafe-function">napi_acquire_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#解释">解释</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#使用步骤-1">使用步骤</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-10">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-release-threadsafe-function">napi_release_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-ref-threadsafe-function">napi_ref_threadsafe_function</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#什么是-threadsafe-function">什么是 Threadsafe Function？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-ref-threadsafe-function-功能">napi_ref_threadsafe_function 功能</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#为什么需要引用-threadsafe-function">为什么需要引用 threadsafe function？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际运用的例子-11">实际运用的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#napi-unref-threadsafe-function">napi_unref_threadsafe_function</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#miscellaneous-utilities">Miscellaneous utilities</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#node-api-get-module-file-name">node_api_get_module_file_name</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#什么是-node-api-get-module-file-name">什么是 node_api_get_module_file_name?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#如何使用它">如何使用它？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#实际应用例子-4">实际应用例子</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><h1 id="node-api" tabindex="-1"><a class="header-anchor" href="#node-api"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-api" target="_blank" rel="noopener noreferrer">Node-API</a></span></a></h1><p>Node-API（以前称为 N-API）是 Node.js 提供的一个 API 层，它允许你用 C 或 C++编写插件。之所以使用 Node-API，主要是因为它提供了一种与底层 JavaScript 引擎（如 V8）解耦的方式来构建原生扩展。这意味着当 Node.js 更新其内部引擎时，使用 Node-API 构建的插件不需要重写来适应新版本，从而增加了扩展的稳定性和兼容性。</p><p>在实际应用中，Node-API 可以用于多种情况，比如：</p><ol><li><p><strong>性能密集型任务</strong>：如果你的 Node.js 应用需要处理大量计算，可能会由于 JavaScript 的性能限制而变慢。通过 Node-API，你可以用 C 或 C++编写这些计算密集型的任务，然后在 Node.js 中调用，利用 C/C++的高效率来提升整体性能。</p></li><li><p><strong>使用现有的 C/C++库</strong>：如果有一个功能强大的 C/C++库并且你希望在你的 Node.js 应用中使用它，那么你可以通过 Node-API 创建一个绑定(binding)，让 JavaScript 代码能够调用这个库。</p></li><li><p><strong>系统级操作</strong>：当需要进行底层操作系统交互（如直接与硬件通信）时，Node-API 可以使得 Node.js 拥有调用系统 API 的能力。</p></li></ol><p>例如，假设我们有一个 C++函数用来计算斐波那契数列的第 N 项，因为这是一个 CPU 密集型任务，所以我们期望在速度上有所提升：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// fibonacci.cpp</span></span>
<span class="line"><span>##include `&lt;`napi.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int Fibonacci(int n) {</span></span>
<span class="line"><span>  if (n `&lt;`= 1) {</span></span>
<span class="line"><span>    return n;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return Fibonacci(n - 1) + Fibonacci(n - 2);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Number FibonacciWrapped(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>  Napi::Env env = info.Env();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (info.Length() `&lt;` 1 || !info[0].IsNumber()) {</span></span>
<span class="line"><span>    Napi::TypeError::New(env, &quot;Number expected&quot;).ThrowAsJavaScriptException();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Napi::Number first = info[0].As`&lt;`Napi::Number&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  int result = Fibonacci(first.Int32Value());</span></span>
<span class="line"><span>  return Napi::Number::New(env, result);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Object Init(Napi::Env env, Napi::Object exports) {</span></span>
<span class="line"><span>  exports.Set(</span></span>
<span class="line"><span>    Napi::String::New(env, &quot;fibonacci&quot;),</span></span>
<span class="line"><span>    Napi::Function::New(env, FibonacciWrapped)</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NODE_API_MODULE(fibonacci, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码首先包括了 Node-API 必需的头文件，然后定义了一个 <code>Fibonacci</code> 函数用来递归计算斐波那契数列。我们还定义了一个 <code>FibonacciWrapped</code> 函数来作为 Node-API 的接口，它将 JavaScript 传入的参数转化为 C++类型，并调用纯 C++的 <code>Fibonacci</code> 函数。最后，<code>Init</code> 函数注册了 <code>FibonacciWrapped</code> 函数，使其在 Node.js 模块中以 <code>fibonacci</code> 名称被导出。</p><p>安装完必要的 Node.js 和 C++ 构建工具后，你可以编译这个扩展然后在 Node.js 代码中这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/fibonacci&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">fibonacci</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出斐波那契数列的第10项</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个简单的例子中，我们看到 Node-API 如何连接 Node.js 和 C++代码，允许 JavaScript 调用原生 C++函数，以此来实现更优的性能。这只是 Node-API 功能的冰山一角，但它非常清楚地展示了 Node-API 如何被用来提升 Node.js 应用的能力。</p><h2 id="implications-of-abi-stability" tabindex="-1"><a class="header-anchor" href="#implications-of-abi-stability"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#implications-of-abi-stability" target="_blank" rel="noopener noreferrer">Implications of ABI stability</a></span></a></h2><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行时环境，允许你在服务器端运行 JavaScript 代码。在 Node.js 中，“ABI”是“应用程序二进制接口”的缩写，它定义了应用程序（这里指 Node.js 的模块或插件）与操作系统之间或不同应用程序组件之间如何相互交互的详细规范。</p><p>当我们谈论到 ABI 稳定性时，我们主要关注的是编译过的 Node.js 模块（通常使用 C 或 C++ 编写的扩展）是否可以在不同版本的 Node.js 中无需重新编译而直接使用。这意味着一个模块的二进制版本可以适配多个版本的 Node.js，这对于开发者来说非常方便，因为模块的兼容性得到了增强。</p><h3 id="abi-稳定性的影响" tabindex="-1"><a class="header-anchor" href="#abi-稳定性的影响"><span>ABI 稳定性的影响</span></a></h3><p><strong>1. 模块开发者：</strong><br> 如果 ABI 是稳定的，则模块开发者不需要为每个新版本的 Node.js 重新编译他们的模块。这减少了维护工作量，并使得模块更容易被广泛使用。例如，如果你创建了一个用于图像处理的 Node.js 模块，并且该模块采用 C++ 编写，那么你的用户就可以在多个 Node.js 版本中使用这个模块，而不需要等待你发布特定于每个版本的预编译二进制文件。</p><p><strong>2. 应用开发者：</strong><br> 应用开发者可以更有信心地升级他们的 Node.js 运行时，因为他们知道依赖的模块很可能仍然能够正常工作。在实践中，这意味着如果你的项目使用了某些依赖库，比如用于数据库连接的 <code>node-oracledb</code>，即使在 Node.js 更新后，通常也无需更改任何代码或等待库的更新。</p><p><strong>3. Node.js 社区：</strong><br> 整个 Node.js 生态系统受益于 ABI 稳定性，因为它降低了各种版本间的兼容性问题，促进了模块共享和复用。</p><h3 id="实际运用的例子" tabindex="-1"><a class="header-anchor" href="#实际运用的例子"><span>实际运用的例子：</span></a></h3><ul><li><p><strong>原生模块兼容性：</strong> 如果你安装了一个用于性能监控的原生 Node.js 模块，比如 <code>v8-profiler</code>，并且 Node.js 有一个新版本发布了。由于 ABI 稳定性，理想情况下，你可以直接在新版本的 Node.js 上运行你的应用程序，而不必担心 <code>v8-profiler</code> 模块会因为新版本而不兼容。</p></li><li><p><strong>升级 Node.js 版本：</strong> 当团队决定将项目从 Node.js v20 升级到 Node.js v21 时，他们检查了所有依赖项以确保兼容性。如果所有关键模块都支持跨版本的 ABI 稳定性，这个升级过程会变得简单快捷，因为团队不必担心这些模块需要重新编译。</p></li><li><p><strong>跨平台模块：</strong> 开发者可能创建了一个用于读取系统信息的模块，并且希望它能在 Windows、macOS 和 Linux 上运行。如果这个模块遵循 ABI 稳定性的标准，它将能够在不同的操作系统上，以及在每个操作系统上的不同 Node.js 版本中运行，而无需进行任何特别的适配工作。</p></li></ul><p>总结来说，ABI 稳定性在 Node.js 中是一个重要特性，它极大地提高了模块跨版本和跨平台的兼容性，对于开发者和最终用户而言都是一个巨大的利好。</p><h2 id="building" tabindex="-1"><a class="header-anchor" href="#building"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#building" target="_blank" rel="noopener noreferrer">Building</a></span></a></h2><p>Node.js 是一个运行时环境，它能让你使用 JavaScript 来编写服务器端的应用。其中一个特性是 N-API，这是一个构建原生模块的 API。在 Node.js 中，原生模块通常是用 C 或者 C++ 写的插件，它们可以直接和操作系统层进行交互。</p><p>在 Node.js v21.7.1 的文档中，“Building”这一部分专门介绍了如何构建一个使用 N-API 的原生模块。以下是这一过程的简单解释和实例：</p><h3 id="构建原生模块的步骤" tabindex="-1"><a class="header-anchor" href="#构建原生模块的步骤"><span>构建原生模块的步骤</span></a></h3><ol><li><p><strong>配置 <code>binding.gyp</code> 文件</strong>：<br> 为了构建原生模块，首先你需要创建一个叫做 <code>binding.gyp</code> 的文件，这个文件包含了描述模块如何被构建的配置信息。这个文件的格式基于 Python 的 GYP（Generate Your Projects）工具，即使你不熟悉 Python 也没关系，因为格式相对直观。</p></li><li><p><strong>编写 C/C++ 代码</strong>：<br> 接下来，你将编写实际的 C 或 C++ 代码。这些代码会使用 N-API 提供的函数来与 JavaScript 层的代码进行交互。</p></li><li><p><strong>编译和链接</strong>：<br> 当你有了 <code>binding.gyp</code> 和 C/C++ 源码文件后，你可以使用 <code>node-gyp</code> 命令行工具来编译你的原生模块。<code>node-gyp</code> 会读取 <code>binding.gyp</code> 文件，执行必要的编译和链接步骤生成二进制文件。</p></li></ol><h3 id="实际例子" tabindex="-1"><a class="header-anchor" href="#实际例子"><span>实际例子</span></a></h3><ol><li><p><strong>创建 <code>binding.gyp</code> 文件</strong>：<br> 假设我们正在创建一个叫做 &quot;awesome&quot; 的原生模块，你可能会有一个像这样的 <code>binding.gyp</code> 文件：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;target_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;awesome&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;sources&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;src/awesome.cc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;include_dirs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">        &quot;`&lt;`!@(node -p </span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">require(&#39;node-addon-api&#39;).include</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">)&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      ],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;`&lt;`!(node -p </span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">require(&#39;node-addon-api&#39;).gyp</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;defines&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;NAPI_DISABLE_CPP_EXCEPTIONS&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里指定了编译目标、源文件、包含目录、依赖关系及宏定义。</p></li><li><p><strong>编写 <code>awesome.cc</code> 源文件</strong>：<br> 在 C++源文件中，你会使用 N-API 定义的函数和宏。比如，你可能会写一个简单的函数来返回字符串 &quot;hello world&quot;:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`napi.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::String HelloMethod(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>  Napi::Env env = info.Env();</span></span>
<span class="line"><span>  return Napi::String::New(env, &quot;hello world&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Object Init(Napi::Env env, Napi::Object exports) {</span></span>
<span class="line"><span>  exports.Set(&quot;hello&quot;, Napi::Function::New(env, HelloMethod));</span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NODE_API_MODULE(awesome, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里定义了一个名为 <code>HelloMethod</code> 的函数，并在模块初始化时把它暴露出来。</p></li><li><p><strong>编译模块</strong>：<br> 最后，你需要在命令行中运行 <code>node-gyp configure</code> 和 <code>node-gyp build</code>。这些命令会分别配置和编译你的模块。</p></li></ol><p>经过上述步骤，你就成功构建了一个原生模块。然后你可以通过 <code>require</code> 在你的 Node.js 代码中载入并使用这个模块。例如，在 JavaScript 中，你可以这样使用刚才构建的 &quot;awesome&quot; 模块:</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> awesomeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/awesome&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">awesomeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: hello world</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>希望以上解释清楚了 Node.js 中构建原生模块的过程和一些基本概念。如果你想深入学习，建议阅读官方文档以及涉及 <code>node-gyp</code> 和 N-API 的相关资料。</p><h3 id="build-tools" tabindex="-1"><a class="header-anchor" href="#build-tools"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#build-tools" target="_blank" rel="noopener noreferrer">Build tools</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行时环境，使得你可以在服务器端运行 JavaScript。这里我们聚焦于 Node.js 中的一个特定功能：N-API。</p><p>N-API 是 Node.js 提供的一组 C API，它是用来构建原生插件的。所谓的原生插件，就是使用像 C 或 C++这样的系统编程语言编写的模块，这些模块可以直接和 Node.js 二进制接口交互，无需通过 JavaScript。原生插件通常用于性能敏感的操作或者调用已有的系統级别库。</p><p>想要构建这些原生插件，你需要一些构建工具。而在 Node.js v21.7.1 的上下文中提到的 &quot;Build tools&quot; 很可能是指那些用来编译和链接原生模块的工具，比如 node-gyp、cmake-js 等。</p><p><strong>node-gyp</strong> 是一个跨平台的命令行工具，它使用 Python 和 GYP（Generate Your Projects）来为 Node.js 原生插件生成必要的项目构建文件，适用于多种系统。</p><p>例如，如果你正在开发一个原生插件来加速图像处理，你会编写一些 C++ 代码来处理图像数据，然后使用 node-gyp 来编译这段代码，使其变成 Node.js 可以加载并使用的本地模块。</p><p>安装 node-gyp 的步骤大致如下：</p><ol><li>安装 Node.js，它自带 npm（node package manager），npm 用来管理 Node.js 模块。</li><li>使用 npm 全局安装 node-gyp：<code>npm install -g node-gyp</code></li><li>你需要确保你的电脑上安装了所有必要的构建工具和配置。对于 Windows, 你可能需要安装 windows-build-tools；对于 macOS 或 Linux，你需要安装 python 和 make 工具链等。</li></ol><p>一个简单的 node-gyp 配置示例（binding.gyp 文件）:</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;targets&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;target_name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;myaddon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">      &quot;sources&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;src/myaddon.cc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个配置定义了一个目标（你的插件），以及源代码的位置。当你在终端执行 <code>node-gyp configure</code> 和 <code>node-gyp build</code> 时，node-gyp 将会读取这个文件，并且根据当前平台生成相应的构建文件，然后编译源代码。</p><p>总结一下，对于 Node.js v21.7.1 中提及的 Build tools，这主要指的是用于构建 N-API 原生插件的工具集，它们能够帮助开发者编译和链接他们用 C/C++ 编写的代码，使之成为 Node.js 可以利用的原生扩展。最常见的这类工具就是 node-gyp。</p><h4 id="node-gyp" tabindex="-1"><a class="header-anchor" href="#node-gyp"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-gyp" target="_blank" rel="noopener noreferrer">node-gyp</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它让开发者可以使用 JavaScript 来编写服务器端的软件。而 <code>node-gyp</code> 并不是 Node.js 核心功能的一部分，而是一个第三方的工具，用来编译 Node.js 的 C++ 扩展模块。</p><p>在 Node.js 中，大多数模块都是用 JavaScript 写的，但有些情况下，为了性能或访问系统资源等原因，需要用 C 或 C++ 来编写扩展。这些扩展就是通过 <code>node-gyp</code> 构建的。</p><p><code>node-gyp</code> 是一个跨平台的命令行工具，它需要 Python 和一个合适的 C/C++ 编译器（例如，在 Windows 上可能是 Visual Studio 的构建工具）。<code>node-gyp</code> 使用 GYP（Generate Your Projects）项目生成所需的构建文件（比如 makefile 或者 Visual Studio 的 .vcxproj 文件），然后编译和链接 C++ 代码生成对应的二进制模块。</p><p>举几个实际运用的例子：</p><ol><li><p><strong>数据库绑定</strong>：比如说，Node.js 与 MySQL 的通信可以使用纯 JavaScript 写的模块，但也可以使用像 <code>mysql2</code> 这样的模块，后者使用 <code>node-gyp</code> 编译性能更高的 C++ 代码来加速数据库操作。</p></li><li><p><strong>性能密集型计算</strong>：如果你在做图像处理或者执行复杂的数学运算，可能会选择用 C++ 来编写这部分逻辑以获得更好的性能，再通过 <code>node-gyp</code> 编译成 Node.js 模块提供给 JavaScript 调用。</p></li><li><p><strong>系统级别的操作</strong>：当你需要进行低级文件操作、网络通信或直接与操作系统对话时，可能会借助 <code>node-gyp</code> 编译一些 C++ 模块以便直接调用系统 API。</p></li></ol><p>要安装和使用 <code>node-gyp</code>，通常会先用 npm（Node.js 的包管理器）来安装它：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> node-gyp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，如果你下载了一个需要编译的 Node.js 模块，一般在模块的目录下运行以下命令来编译模块：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">node-gyp</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> configure</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">node-gyp</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> build</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>configure</code> 命令会根据当前平台生成构建文件，<code>build</code> 命令实际上会进行编译。</p><p>总的来说，<code>node-gyp</code> 是一个非常强大的工具，可以帮助开发者将 C/C++ 代码集成到 Node.js 应用中，这在需要特殊处理或优化性能的场景下非常有用。</p><h4 id="cmake-js" tabindex="-1"><a class="header-anchor" href="#cmake-js"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#cmakejs" target="_blank" rel="noopener noreferrer">CMake.js</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它允许你使用 JavaScript 编写服务器端代码。CMake.js 则是为了简化在 Node.js 中编译和构建本地（native）模块的扩展工具。</p><p>通常情况下，当你想要在 Node.js 中使用一些需要编译的 C++代码时，你会用到一个名叫 node-gyp 的工具。node-gyp 使用 Python 和 gyp 来构建这些本地模块。然而，并不是所有的人都熟悉 Python 或者想要安装 Python 只为了构建一个项目。因此，CMake.js 就被创建出来作为 node-gyp 的替代品。</p><p>CMake.js 利用 CMake 来构建本地模块。CMake 是一个非常流行的跨平台自动化构建工具，它能够生成本地构建环境（例如 makefile 或者 Visual Studio 的项目文件）。</p><p>使用 CMake.js 的步骤大致如下：</p><ol><li><p><strong>安装 CMake.js</strong>：首先，你需要在你的项目中安装 CMake.js。你可以通过 npm 命令来安装它：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> --save-dev</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> cmake-js</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>配置 CMakeLists.txt 文件</strong>：在你的项目根目录中创建一个<code>CMakeLists.txt</code>文件。这个文件告诉 CMake 怎样去构建你的本地模块。例如：</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" data-title="cmake" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>cmake_minimum_required(VERSION 3.7)</span></span>
<span class="line"><span>project(MyModule)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>add_library(MyModule SHARED</span></span>
<span class="line"><span>    src/my_module.cpp</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>set_target_properties(MyModule PROPERTIES PREFIX &quot;&quot; SUFFIX &quot;.node&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>编译本地模块</strong>：通过 CMake.js 提供的命令行工具或者集成到 npm 脚本中来构建你的模块。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">cmake-js</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> compile</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者在<code>package.json</code>中添加一个脚本:</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">    &quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;cmake-js compile&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你可以用 npm run build 来构建你的模块。</p></li><li><p><strong>在 Node.js 中使用你的模块</strong>：构建完成后，你就可以像其他任何 npm 模块一样在你的 JavaScript 代码中引入并使用你的本地模块了。</p></li></ol><p>实际应用例子：</p><p>假设你有一段复杂的数学计算，这段计算在 C++中实现会比 JavaScript 快很多。你可以将这部分逻辑写在<code>my_math.cpp</code>文件中，然后用 CMake.js 来编译这个 C++代码为 Node.js 可加载的本地模块。 Node.js 代码可以直接调用这个模块，以获得更好的性能。</p><p>请记住，CMake.js 主要是面向已经有 C++背景，并且希望能有效地将这些代码与 Node.js 结合起来的开发人员。对于编程新手来说，如果没有必要处理 C++代码，开始时可能不需要深入学习 CMake.js。</p><h3 id="uploading-precompiled-binaries" tabindex="-1"><a class="header-anchor" href="#uploading-precompiled-binaries"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#uploading-precompiled-binaries" target="_blank" rel="noopener noreferrer">Uploading precompiled binaries</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建本地插件的 API，它提供了一套稳定的在各个 Node 版本间通用的函数，这意味着如果你使用 N-API 编写的插件或者模块，则可以在不同版本的 Node.js 中运行而不需要重新编译。</p><p>当开发者创建了一个原生模块（也就是用 C 或者 C++书写的直接和 Node.js 交互的模块）后，他们通常会希望用户安装时能够直接下载预编译好的二进制文件，而不是从源代码开始编译。这样可以节省用户的时间，特别是对那些不熟悉本地编译环境的用户来说更加友好。</p><p>上传预编译的二进制文件通常是通过使用一些第三方服务和工具完成的，例如：</p><ol><li><p><strong><code>node-pre-gyp</code></strong>: 这是一个让你能够发布和安装 Node.js C++插件预编译版本的工具。在你的项目中，你可以配置<code>node-pre-gyp</code>来指定哪些平台和 Node.js 版本的预编译文件应该被上传到存储服务器上（比如 Amazon S3、GitHub Releases 等）。当用户安装你的模块时，<code>node-pre-gyp</code>会查找匹配用户平台和 Node.js 版本的预编译二进制文件，并尝试下载它来安装。</p></li><li><p><strong><code>prebuild</code> / <code>prebuild-install</code></strong>: 这是另一组工具，工作方式类似于<code>node-pre-gyp</code>，但有其特定的配置和特性。<code>prebuild</code>负责创建预编译的二进制文件，并可以将它们上传到 GitHub Releases 上。而<code>prebuild-install</code>则被用于在用户安装你的模块时下载并安装这些预编译的二进制文件。</p></li></ol><p>实际运用的例子:<br> 假设你创建了一个名为&quot;awesome-native-module&quot;的 Node.js 原生模块，它提供了一些用 C++编写的功能。你想要让用户在安装你的模块时能够轻松获得预编译的二进制文件。</p><p>这里是怎么做的大致步骤：</p><ol><li><p>在你的模块中加入<code>node-pre-gyp</code>或者<code>prebuild</code>作为依赖项，并且配置它们的路径，指向你想要上传二进制文件的地点。</p></li><li><p>设置 CI/CD 流程（比如 GitHub Actions），在每次你推送代码更新或者创建一个新的发布时自动运行构建过程，并且触发<code>node-pre-gyp</code>或<code>prebuild</code>去创建和上传新的预编译二进制文件。</p></li><li><p>当用户执行<code>npm install awesome-native-module</code>时，<code>node-pre-gyp</code>或<code>prebuild-install</code>会被调用。它们会检查用户的系统和 Node 版本，尝试去下载对应的预编译二进制文件进行安装。如果没有找到匹配的预编译文件，它们会退回到从源码编译。</p></li></ol><p>通过这种方式，你可以提高用户安装你原生模块的体验，减少他们需要处理编译问题的机会。</p><h4 id="node-pre-gyp" tabindex="-1"><a class="header-anchor" href="#node-pre-gyp"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-pre-gyp" target="_blank" rel="noopener noreferrer">node-pre-gyp</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它让开发者能够使用 JavaScript 来编写服务端代码。Node.js 高效的事件驱动、非阻塞 I/O 模型使其非常适用于构建快速的、可扩展的网络应用。</p><p>在 Node.js 的生态系统中，有很多原生模块（native modules），即用 C 或 C++ 编写的模块，它们可以通过 Node.js 提供的 N-API 接口与 JavaScript 代码交互。这些模块通常是为了提高性能或访问一些底层系统功能，比如文件系统操作、网络通信或图形处理等。</p><p><code>node-pre-gyp</code> 是一个工具和库，它允许开发者为他们的 Node.js 原生模块编译并发布预编译的二进制包。这些二进制包可以针对不同的平台（如 Windows、macOS 和 Linux）以及不同版本的 Node.js 提前编译好，并且可以在安装时直接使用，而无需用户自己编译。</p><h3 id="为什么需要-node-pre-gyp" tabindex="-1"><a class="header-anchor" href="#为什么需要-node-pre-gyp"><span>为什么需要 <code>node-pre-gyp</code>？</span></a></h3><p>当你通过 npm 安装一个包含原生模块的 Node.js 包时，通常需要在本地编译该模块。本地编译需要开发者机器上有编译工具链（如 gcc、clang 或 Visual Studio）。但是，由于以下几个原因，这可能会导致问题：</p><ol><li>用户可能没有必要的编译工具或者对如何安装和使用编译工具不熟悉。</li><li>编译过程可能因为系统配置或依赖项的不同而失败。</li><li>编译原生模块可能会花费相当长的时间。</li></ol><p>为了解决这些问题，<code>node-pre-gyp</code> 允许模块维护者提前为各种环境编译好二进制版本，用户在安装时 npm 能够直接下载和使用这些预编译的版本，从而避免了编译过程中的复杂性和耗时。</p><h3 id="实际运用例子" tabindex="-1"><a class="header-anchor" href="#实际运用例子"><span>实际运用例子</span></a></h3><p>假设你正在使用一个名为 <code>sharp</code> 的 Node.js 包，它是一个用于图片处理的库，其中包含了用 C++ 编写的原生代码。如果没有 <code>node-pre-gyp</code>，每个安装 <code>sharp</code> 的人都需要在他们的机器上编译这个原生模块。这可能导致一些用户因为缺少编译器或其他原因而无法成功安装。</p><p>但是，由于 <code>sharp</code> 使用了 <code>node-pre-gyp</code>，所以在你执行 <code>npm install sharp</code> 的时候，<code>npm</code> 将查看你的操作系统和 Node.js 版本，然后从 <code>sharp</code> 的服务器上下载适合你系统的预编译二进制文件。整个过程对用户来说是透明的，显著提高了安装速度和成功率。</p><h3 id="如何使用-node-pre-gyp" tabindex="-1"><a class="header-anchor" href="#如何使用-node-pre-gyp"><span>如何使用 <code>node-pre-gyp</code></span></a></h3><p>模块维护者通常会在他们的 <code>package.json</code> 文件中添加 <code>node-pre-gyp</code> 相关的配置，并指定好二进制文件的存储位置。在模块安装过程中，<code>npm</code> 或 <code>yarn</code> 会根据这些配置自动调用 <code>node-pre-gyp</code> 来下载或编译原生模块。</p><p>总结起来，<code>node-pre-gyp</code> 是 Node.js 生态系统中一个重要的工具，它通过提供预编译的原生模块二进制文件来简化安装过程，改善最终用户的体验。</p><h4 id="prebuild" tabindex="-1"><a class="header-anchor" href="#prebuild"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#prebuild" target="_blank" rel="noopener noreferrer">prebuild</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许在服务器端运行 JavaScript 代码。N-API 则是 Node.js 提供的一组 C API，使得原生插件（通常用 C 或 C++ 编写）能够在不同版本的 Node.js 中平稳运行，而不需要因为 Node.js 升级后引擎的变化而重新编译。</p><p>那么，“prebuild”这个术语通常与 N-API 和 node-addon-api（一种简化编写原生 Node.js 插件的包装库）有关。&quot;prebuild&quot;指的是事先为不同平台和 Node.js 版本构建好的原生模块（二进制文件）。通过预先构建，模块的安装可以变得更快，因为用户不需要从源代码编译它们。</p><p>例如，如果你正在构建一个性能敏感的应用程序，你可能会使用到一些需要利用更深层系统资源优势的代码。你或许会选择写一个用 C++ 编写的模块来处理图像或进行数学计算，比使用 JavaScript 快得多。当用户想要安装你的模块时，你可以提供预先构建好的二进制文件以减少他们的安装时间和复杂度。</p><p>现在我们假设你已经创建了这样一个模块，并且你希望它能够跨平台（如 Windows, macOS, Linux）和跨 Node.js 版本工作。你就可以使用类似 <code>prebuild</code> 或 <code>node-pre-gyp</code> 这样的工具来为这些不同的组合构建二进制文件。</p><p>这里有一些具体的步骤示例：</p><ol><li><p><strong>开发原生模块</strong>：首先，你要用 C 或 C++ 开发你的原生模块，并且确保它通过 N-API 接口与 JavaScript 交互。</p></li><li><p><strong>配置预构建脚本</strong>：配置一个 <code>prebuild</code> 脚本，在你发布模块之前自动为所有目标平台和 Node.js 版本构建二进制文件。</p></li><li><p><strong>构建和上传</strong>：当你执行 <code>prebuild</code> 脚本时，它会为每个目标平台和 Node.js 版本构建你的模块，并将构建好的二进制文件上传到 GitHub Releases 或其他托管服务上。</p></li><li><p><strong>用户安装模块</strong>：当用户运行 <code>npm install your-module-name</code> 安装你的模块时，<code>npm</code> 或 <code>yarn</code> 会自动检测用户的平台和 Node.js 版本，并尝试下载相应的预构建二进制文件。如果找到匹配的预构建文件，就直接下载和安装，而不需要从源码编译。如果没有找到匹配的预构建文件，则回退到从源码编译。</p></li></ol><p>实际应用的例子包括数据库驱动（例如 <code>node-sqlite3</code>），加密库（例如 <code>bcrypt</code>），或是数学库（例如 <code>mathjax-node</code>），它们都可能提供预构建的二进制文件，以方便用户安装和使用。</p><p>总结来说，“prebuild”在 Node.js 的语境中就是指预先为不同的运行环境编译好的原生模块二进制文件，目的是简化最终用户的安装过程，并提高模块的可移植性和易用性。</p><h4 id="prebuildify" tabindex="-1"><a class="header-anchor" href="#prebuildify"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#prebuildify" target="_blank" rel="noopener noreferrer">prebuildify</a></span></a></h4><p>Node.js 中的 &quot;prebuildify&quot; 并非 Node.js 的官方 API 的一部分，而是一个独立的 npm 包，用于为 Node.js 的原生模块创建预编译的二进制版本。原生模块是使用 C 或 C++ 编写的插件，可以直接调用 Node.js 底层的 API。正常情况下，当你安装一个包含原生模块的节点包时，这些模块需要在本地机器上从源代码编译。Prebuildify 能够帮助开发者先行在不同的平台上编译好这些原生模块，并且随着 npm 包一起发布。</p><h3 id="prebuildify-使用" tabindex="-1"><a class="header-anchor" href="#prebuildify-使用"><span>prebuildify 使用</span></a></h3><p>要使用 prebuildify，通常需要以下步骤：</p><ol><li>确保你有一个需要编译的原生模块项目。</li><li>安装 prebuildify：通过运行 <code>npm install --save-dev prebuildify</code> 将它作为开发依赖添加到你的项目中。</li><li>在 package.json 文件中配置 scripts，增加一个脚本来运行 prebuildify。</li><li>运行配置的脚本以创建预编译的二进制文件。</li><li>发布你的包，这样其他用户在安装时，将会下载相应平台的预编译版本，从而省略了编译过程。</li></ol><h3 id="实际例子-1" tabindex="-1"><a class="header-anchor" href="#实际例子-1"><span>实际例子</span></a></h3><p>假设你正在开发一个名为 &quot;awesome-native-module&quot; 的原生 Node.js 模块。你希望用户在安装时不必从头编译这个模块，以节省时间和避免潜在的编译问题。你可以使用 prebuildify 来实现这一目的。以下是简化的步骤：</p><ol><li>开发你的原生模块，确保它能够在本地编译通过。</li><li>在项目根目录下运行 <code>npm install --save-dev prebuildify</code> 命令，添加 prebuildify 作为开发依赖。</li><li>在 package.json 中添加一个脚本：<div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;prebuild&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;prebuildify --napi&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>运行 <code>npm run prebuild</code>。这将为当前系统生成预编译的二进制文件，并将其存储在 <code>./prebuilds/</code> 目录中。</li><li>现在你可以发布你的包了。例如，运行 <code>npm publish</code>。</li></ol><p>如果一切顺利，当用户运行 <code>npm install awesome-native-module</code> 时，npm 会查找与用户系统匹配的预编译二进制文件。如果找到了，它会下载并使用这个预编译的版本而不是从源代码重新编译。</p><p><strong>注意：</strong> 上述信息可能与 Node.js v21.7.1 版本的具体情况有所差异，因为 Node.js 和相关工具链经常更新。始终建议查阅最新的文档或库说明来获取准确的使用方法。</p><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#usage" target="_blank" rel="noopener noreferrer">Usage</a></span></a></h2><p>Node.js 中的 N-API 是一个用于构建本地插件的 API，它是独立于底层 JavaScript 运行时（例如 V8）的抽象层，目的是保持你的插件在 Node.js 的不同版本之间兼容。这意味着使用 N-API 编写的本地插件不需要针对每个新的 Node.js 版本重新编译。</p><p>简单来说，如果你想让你的 JavaScript 代码调用 C/C++编写的函数或者库，那么 N-API 可以帮助你做到这点，而不需要担心 Node.js 版本升级后插件不兼容的问题。</p><p>以下是使用 N-API 的基本步骤：</p><ol><li><p><strong>包含头文件</strong>：在你的 C 或 C++源文件中，包含<code>&lt;`node_api.h`&gt;</code>头文件，这使得你能够使用 N-API 提供的函数和宏。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>创建函数</strong>：编写你要从 JavaScript 调用的 C/C++函数。这些函数必须遵循 N-API 定义的特定签名。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 函数逻辑</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>注册函数</strong>：使用 N-API 函数注册上面定义的函数，使其可以被 JavaScript 调用。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个napi_value引用，指向我们的原生函数MyFunction</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个函数作为模块导出的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>构建和安装</strong>：使用<code>node-gyp</code>编译你的 C/C++代码并生成一个.node 文件，这个文件可以被 Node.js 作为模块加载。</p></li><li><p><strong>在 Node.js 中使用</strong>：在 Node.js 代码中，使用<code>require</code>加载你的本地插件，并像普通模块一样使用。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用你在C/C++中定义的函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>实际运用例子：</p><ul><li><p><strong>性能密集型任务</strong>：某些操作在 JavaScript 中执行效率低下，比如图像处理或者大规模数值计算，你可以使用 N-API 编写高效的 C/C++代码来处理这些任务，并通过 Node.js 调用它们。</p></li><li><p><strong>系统级操作</strong>：当你需要进行系统调用或访问操作系统层面的功能，比如硬件信息获取或系统调度，你可以通过 N-API 写本地代码来实现。</p></li><li><p><strong>集成第三方库</strong>：如果你想在 Node.js 项目中使用一些只有 C/C++接口的第三方库，如机器学习库或是数据库驱动，你可以通过 N-API 将它们封装为可从 JavaScript 调用的函数。</p></li></ul><p>N-API 是 Node.js 提供的非常强大的功能，它极大地扩展了 Node.js 的应用场景，并且解决了本地插件与 Node.js 版本兼容性的问题。不过，本地插件开发涉及 C/C++知识，因此会有一定的学习难度。如果你刚开始编程，你可能需要先掌握 JavaScript 和 Node.js 的基础，然后再逐渐深入学习 N-API 相关内容。</p><h2 id="node-api-version-matrix" tabindex="-1"><a class="header-anchor" href="#node-api-version-matrix"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-api-version-matrix" target="_blank" rel="noopener noreferrer">Node-API version matrix</a></span></a></h2><p>好的，Node.js 中的 Node-API（之前称为 N-API）是一个让你能够用 C 或 C++ 编写扩展的 API。Node-API 旨在提供一个与 JavaScript 引擎无关的抽象层，这样你就可以编写能在不同版本的 Node.js 上运行的本地插件。</p><p>在 Node.js 的每个新版本中，Node-API 也可能会有更新。这些更新可能包括新的 API 函数、性能改进或者其他变化。每个 Node-API 的版本都与特定的 Node.js 版本相对应。为了弄清楚哪些 Node-API 版本可以在特定的 Node.js 版本上使用，Node.js 提供了一个版本矩阵。</p><p>下面我将解释如何查看和理解 Node-API 版本矩阵：</p><ol><li>打开 Node-API 版本矩阵链接，你将看到一张表格。</li><li>这张表格列出了不同的 Node-API 版本（即 Node-API v1、v2、v3 等）。</li><li>对于每个 Node-API 版本，表格都会显示它首次引入的 Node.js 版本以及它被废弃（如果已经被废弃）的 Node.js 版本。</li></ol><p>例如，假设你查看的版本矩阵如下所示：</p><table><thead><tr><th style="text-align:right;">Node-API</th><th style="text-align:left;">改动</th></tr></thead><tbody><tr><td style="text-align:right;">v8</td><td style="text-align:left;">Added in: v14.0.0, Removed in: <code>&lt;</code>none&gt;</td></tr><tr><td style="text-align:right;">v7</td><td style="text-align:left;">Added in: v13.14.0, Removed in: <code>&lt;</code>none&gt;</td></tr><tr><td style="text-align:right;">v6</td><td style="text-align:left;">Added in: v10.20.0, Removed in: <code>&lt;</code>none&gt;</td></tr></tbody></table><p>这意味着：</p><ul><li>Node-API 版本 8 首次引入于 Node.js 版本 14.0.0，并且目前还没有被移除；</li><li>Node-API 版本 7 首次引入于 Node.js 版本 13.14.0，也尚未被移除；</li><li>Node-API 版本 6 首次引入于 Node.js 版本 10.20.0，同样也没有被移除。</li></ul><p>这样，如果你正在使用 Node.js 版本 14.x，你就可以安全地使用 Node-API 版本 8 或更低的版本来构建你的原生插件。</p><p>实际运用的例子：</p><ol><li><p>比如你想创建一个本地插件来加快你的应用程序的图像处理速度，你的服务器运行的是 Node.js 14.x 版本。根据版本矩阵，你可以使用 Node-API v8 来编写这个插件，因为它可用于 Node.js 14.x。</p></li><li><p>假设你需要用到一个现成的数据库插件，但这个插件是基于 Node-API v6 开发的。如果你的服务器运行的是 Node.js 版本 10.20.0 或更高版本，你可以放心地使用该插件。如果你的服务器运行的是更低版本的 Node.js，则需要升级你的 Node.js 版本，或寻找一个兼容当前版本的类似插件。</p></li></ol><p>总结起来，Node-API 版本矩阵帮助开发者理解哪些 Node-API 版本可以在他们的 Node.js 环境中使用，这样他们就可以选择正确的 API 版本来编写或使用原生插件，以确保最佳的兼容性和稳定性。</p><h2 id="environment-life-cycle-apis" tabindex="-1"><a class="header-anchor" href="#environment-life-cycle-apis"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#environment-life-cycle-apis" target="_blank" rel="noopener noreferrer">Environment life cycle APIs</a></span></a></h2><p>Node.js 中的 Environment Life Cycle APIs 是一组专门的 API，它们被用来管理与 Node.js 应用相关联的环境（environment）。每一个 Node.js 运行实例都有一个与之关联的环境，这个环境包含了当前运行代码所需的所有状态和资源。</p><p>在 Node.js v21.7.1 中，N-API 提供了一些关于环境生命周期的函数，使得原生模块的开发者可以更好地控制模块与 Node.js 环境之间的交互。原生模块是用 C 或 C++ 编写并编译为共享对象，在 Node.js 中直接加载和运行的模块。</p><p>下面我会解释一些关于 Environment Life Cycle 相关的概念，并给出几个简单的例子来说明如何使用这些 API。</p><h3 id="_1-创建和销毁环境" tabindex="-1"><a class="header-anchor" href="#_1-创建和销毁环境"><span>1. 创建和销毁环境</span></a></h3><p>当你创建一个 Node.js 应用时，Node.js 会自动创建一个环境。但是，有时候原生模块需要独立于默认环境创建额外的环境。例如，如果你想在一个单独的线程中执行某些代码，你可能需要创建一个新的环境。</p><p>创建环境的 API 示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_env env;</span></span>
<span class="line"><span>napi_create_environment(..., &amp;env);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>销毁环境的 API 示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_env env;</span></span>
<span class="line"><span>napi_destroy_environment(env);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-环境数据管理" tabindex="-1"><a class="header-anchor" href="#_2-环境数据管理"><span>2. 环境数据管理</span></a></h3><p>在 Node.js 中，一个环境可以存储和管理许多数据，比如回调函数、对象引用等。通过环境生命周期 API，你可以在环境中添加或移除这些数据。</p><p>添加环境数据的 API 示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_env env;</span></span>
<span class="line"><span>void* data = ...; // 指向你的数据的指针</span></span>
<span class="line"><span>napi_add_env_cleanup_hook(env, cleanup_cb, data);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>cleanup_cb</code> 是一个回调函数，它会在环境销毁时被调用，以便清理你添加的数据。</p><p>移除环境数据的 API 示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_env env;</span></span>
<span class="line"><span>void* data = ...; // 指向你的数据的指针</span></span>
<span class="line"><span>napi_remove_env_cleanup_hook(env, cleanup_cb, data);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些函数允许你管理模块的资源，确保它们能够在不需要的时候被适当地释放，防止内存泄漏。</p><h3 id="实际应用举例" tabindex="-1"><a class="header-anchor" href="#实际应用举例"><span>实际应用举例</span></a></h3><p>在大多数情况下，Node.js 的 JavaScript 开发者可能不会直接使用这些环境生命周期 API，因为这些操作通常是由原生模块的作者在底层处理的。但是，了解这些 API 可以帮助你理解原生模块是如何工作的。举一些实际的例子：</p><ul><li>如果你正在开发一个涉及图像处理的原生模块，你可能需要为每个处理任务创建一个新的环境，并在任务完成后销毁该环境，以确保所有的资源都得到释放。</li><li>另一个例子可能是开发数据库连接模块，你可能需要在模块初始化时创建环境，保存数据库连接状态，并在模块卸载时销毁这个环境来关闭所有的数据库连接。</li></ul><p>记住，这些 API 对于普通 JavaScript 用户来说是不可见的，只有在编写或维护 Node.js 原生扩展时你才会直接与它们打交道。</p><h3 id="napi-set-instance-data" tabindex="-1"><a class="header-anchor" href="#napi-set-instance-data"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_set_instance_data" target="_blank" rel="noopener noreferrer">napi_set_instance_data</a></span></a></h3><p><code>napi_set_instance_data</code> 是 Node.js 中的 N-API 功能之一，N-API 是一个 C API，它允许原生插件（通常用 C 或 C++编写）与 Node.js 交互。使用 <code>napi_set_instance_data</code> 函数可以让你在原生模块中储存特定的数据，并且这些数据是与当前 Node.js 实例（通常指的是运行中的 Node.js 应用程序或进程）绑定的。</p><p>现在让我们详细解释一下 <code>napi_set_instance_data</code> 这个函数。</p><p>首先，<code>napi_set_instance_data</code> 可以帮助我们保存一些跨原生方法调用保持不变的数据。比如，如果你的原生模块需要一个配置对象，或者需要一个状态来表示某种资源是否已经初始化，那么你就可以使用这个功能。</p><p>函数签名如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_set_instance_data(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    void* data,</span></span>
<span class="line"><span>    napi_finalize finalize_cb,</span></span>
<span class="line"><span>    void* finalize_hint);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数接受以下参数：</p><ul><li><code>env</code>：是一个代表 Node.js 运行时环境的句柄。</li><li><code>data</code>：是你想要存储的数据的指针。</li><li><code>finalize_cb</code>：当实例销毁或数据不再需要时，将调用的回调函数，可以用于清理资源。</li><li><code>finalize_hint</code>：是一个额外的提示参数，将传递给 <code>finalize_cb</code> 回调函数。</li></ul><p>让我们通过一个简单的例子来说明其用法：</p><p>假设你正在编写一个原生扩展，需要保存一个全局计数器，每次调用一个特定的函数时，都会增加这个计数器。为了存储和访问这个计数器，你可能会选择使用 <code>napi_set_instance_data</code>。</p><ol><li>首先，定义你的计数器和清理函数：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>static int counter = 0; // 假设这是你想要全局保存的数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void cleanup_counter(napi_env env, void* data, void* hint) {</span></span>
<span class="line"><span>    // 因为我们仅仅保存了一个静态整数，所以这里可能不需要执行任何特殊的清理工作</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>然后，在模块初始化的时候设置这个数据：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 设置实例数据</span></span>
<span class="line"><span>    napi_status status = napi_set_instance_data(</span></span>
<span class="line"><span>        env,</span></span>
<span class="line"><span>        &amp;counter,</span></span>
<span class="line"><span>        cleanup_counter,</span></span>
<span class="line"><span>        NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>接着，每次相关函数被调用时，你可以更新计数器：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void IncrementCounter(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 我们本例中不需要获取 instance data</span></span>
<span class="line"><span>    // 因为直接访问静态变量 &#39;counter&#39; 就足够了</span></span>
<span class="line"><span>    counter++;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ...其他代码，可能包括返回新的计数器值给JavaScript</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，无论何时调用 <code>IncrementCounter</code> 函数，同一个 <code>counter</code> 就会被更新，因为它是绑定到 Node.js 实例的。</p><p>记住，<code>napi_set_instance_data</code> 更多使用场景是当你需要在原生模块中存储指向复杂数据结构（例如动态分配的内存、自定义类型的实例等）的指针时。</p><p>此函数适用于需要创建只在单个 Node.js 实例中共享的数据的场景，而不是跨不同加载的模块或不同 Node.js 进程共享。如果你需要跨实例共享数据，则需要寻找其他机制，如使用静态变量或外部存储系统。</p><h3 id="napi-get-instance-data" tabindex="-1"><a class="header-anchor" href="#napi-get-instance-data"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_instance_data" target="_blank" rel="noopener noreferrer">napi_get_instance_data</a></span></a></h3><p>Node.js 中的 N-API（原生 API）是一个用来构建原生插件的接口。原生插件是指使用 C 或 C++ 编写的模块，可直接通过 Node.js 的运行时环境调用。N-API 旨在提供一个与 JavaScript 运行时无关的抽象层，这意味着使用它编写的插件不依赖于特定版本的 Node.js。</p><p><code>napi_get_instance_data</code> 是 N-API 中的一个函数，它允许你从当前的 Node.js 插件实例中获取之前存储的数据。这个功能很有用，因为它能够帮助你维护一些状态信息，而无需将这些信息存储在全局变量中。</p><p>当你创建一个原生插件，并且希望跟踪一些与插件实例相关的数据时，<code>napi_get_instance_data</code> 就非常有用了。这个函数可以帮助你检索先前通过 <code>napi_set_instance_data</code> 函数设置的数据。</p><h3 id="使用场景举例" tabindex="-1"><a class="header-anchor" href="#使用场景举例"><span>使用场景举例</span></a></h3><ol><li><p><strong>计数器插件</strong>：假设你正在编写一个原生插件，该插件维护一个简单的计数器。每次调用插件函数时，计数器都会递增。为了跟踪这个计数器，你可以使用 <code>napi_set_instance_data</code> 在初始化时存储它，并在后续的函数调用中使用 <code>napi_get_instance_data</code> 来获取当前的计数值。</p></li><li><p><strong>数据库连接</strong>：如果你的插件负责管理数据库连接，则可以在插件初始化时创建一个数据库连接，并使用 <code>napi_set_instance_data</code> 存储该连接的引用。随后，每当需要执行数据库操作时，就可以通过 <code>napi_get_instance_data</code> 获取到这个数据库连接，并使用它进行查询或更新操作。</p></li><li><p><strong>配置信息</strong>：如果你的插件需要加载和存储一些配置信息，那么可以在插件启动时读取这些配置，并通过 <code>napi_set_instance_data</code> 存储起来。以后每次插件需要这些配置信息时，都可以通过 <code>napi_get_instance_data</code> 来获取。</p></li></ol><h3 id="示例代码片段" tabindex="-1"><a class="header-anchor" href="#示例代码片段"><span>示例代码片段</span></a></h3><p>以下是一个使用 <code>napi_get_instance_data</code> 的伪代码示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个结构体来保存我们的实例数据</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  int counter; // 用于示例的计数器</span></span>
<span class="line"><span>} MyInstanceData;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 函数用于获取实例数据</span></span>
<span class="line"><span>napi_value GetCounter(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  MyInstanceData* instance_data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 通过 napi_get_instance_data 获取实例数据</span></span>
<span class="line"><span>  napi_status status = napi_get_instance_data(env, (void**)&amp;instance_data);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在你可以访问 instance_data-&gt;counter 并根据需要操作它了</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回计数器的当前值作为 JavaScript 数字</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  status = napi_create_int32(env, instance_data-&gt;counter, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 该函数可能会在插件初始化时被调用，它会设置实例数据</span></span>
<span class="line"><span>void Initialize(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  MyInstanceData* instance_data = malloc(sizeof(MyInstanceData));</span></span>
<span class="line"><span>  instance_data-&gt;counter = 0; // 初始化计数器</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 使用 napi_set_instance_data 存储实例数据</span></span>
<span class="line"><span>  napi_status status = napi_set_instance_data(</span></span>
<span class="line"><span>    env,</span></span>
<span class="line"><span>    instance_data,</span></span>
<span class="line"><span>    NULL, // 这里可以提供一个析构函数，用来在插件卸载时清理资源</span></span>
<span class="line"><span>    NULL</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>  // 确保 status == napi_ok，否则处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码展示了如何使用 <code>napi_get_instance_data</code> 函数在一个原生插件中获取实例数据。记住，为了使代码正常工作，你还需要实现其他一些部分，比如插件的注册逻辑及其它必要的错误处理。</p><h2 id="basic-node-api-data-types" tabindex="-1"><a class="header-anchor" href="#basic-node-api-data-types"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#basic-node-api-data-types" target="_blank" rel="noopener noreferrer">Basic Node-API data types</a></span></a></h2><p>Node-API（以前称为 N-API）是 Node.js 的一个接口层，它允许你使用 C 或 C++ 编写扩展来和 JavaScript 代码交互。Node-API 设计的目标是减少与底层 JavaScript 引擎的直接交互，这样编写的扩展就能够在 Node.js 的不同版本之间保持兼容。</p><p>在 Node-API 中有一些“基本数据类型”，这些数据类型代表了 JavaScript 值和类型在 C/C++ 层面上的等效表示。理解这些基本数据类型对于编写可靠、高效的原生扩展非常重要。</p><p>以下是一些 Node-API 中的基本数据类型及其简单描述：</p><ol><li><code>napi_value</code>: 代表一个 JavaScript 值。无论是个数字、字符串还是对象，在 C/C++ 层面上都用 <code>napi_value</code> 表示。</li><li><code>napi_env</code>: 代表一个 Node-API 调用环境，所有的 Node-API 函数调用都需要这个环境作为参数之一，因为它包含了 Node-API 操作的上下文信息。</li><li><code>napi_callback_info</code>: 当 JavaScript 调用一个由 C/C++ 提供的函数时，会将相关信息打包进一个 <code>napi_callback_info</code> 类型中，比如函数被调用时的参数。</li><li><code>napi_ref</code>: 代表一个对 JavaScript 对象的强引用，这可以防止该对象在它仍然被 C/C++ 扩展使用时被垃圾回收器回收。</li><li><code>napi_handle_scope</code>: 管理局部 <code>napi_value</code> 句柄的生命周期，用于控制内存分配，确保在当前作用域结束时释放局部句柄。</li><li><code>napi_escapable_handle_scope</code>: 类似 <code>napi_handle_scope</code>，但允许一个句柄从一个作用域“逃逸”到父作用域。</li><li><code>napi_callback_scope</code>: 与正在执行的 JavaScript 函数关联的作用域。</li><li><code>napi_async_work</code>: 表示异步工作的句柄，通过这个可以在后台线程上执行任务而不会阻塞 JavaScript 主线程。</li><li><code>napi_deferred</code>: 代表一个延迟的操作，通常与 Promise 结合使用，允许从原生代码中创建可解析或拒绝的 Promise 对象。</li></ol><p>实例运用：</p><p>假设你想在 Node.js 中创建一个原生模块，用来加密字符串。你可能需要编写一个 C 功能来完成加密工作，并且利用 Node-API 把这个功能暴露给 JavaScript。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 实际的加密函数</span></span>
<span class="line"><span>void EncryptString(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 获取函数参数</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 napi_value 转换为 C 字符串</span></span>
<span class="line"><span>    char* originalStr;</span></span>
<span class="line"><span>    size_t str_len;</span></span>
<span class="line"><span>    napi_get_value_string_utf8(env, args[0], NULL, 0, &amp;str_len);</span></span>
<span class="line"><span>    originalStr = (char*) malloc(str_len + 1);</span></span>
<span class="line"><span>    napi_get_value_string_utf8(env, args[0], originalStr, str_len + 1, &amp;str_len);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这里是加密操作（省略实现）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    free(originalStr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建返回值</span></span>
<span class="line"><span>    napi_value returnValue;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;encrypted string&quot;, NAPI_AUTO_LENGTH, &amp;returnValue);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return returnValue;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, EncryptString, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;encrypt&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这段代码中，我们定义了一个名为 <code>EncryptString</code> 的 C 函数作为 Node-API 接口。这个函数通过 <code>napi_get_cb_info</code> 从 JavaScript 世界获取参数，并且将 JavaScript 字符串转换为 C 字符串。之后，我们执行一个假设的加密操作，最后创建一个新的 JavaScript 字符串（加密结果）并返回。</p><p>最终，这个原生模块通过 <code>Init</code> 函数（作为模块初始化入口点）在 Node.js 中注册了 <code>encrypt</code> 函数。JavaScript 开发者就可以像使用普通的 JavaScript 函数一样，使用 <code>require</code> 导入这个模块，并调用其中的 <code>encrypt</code> 函数进行字符串加密。</p><h3 id="napi-status" tabindex="-1"><a class="header-anchor" href="#napi-status"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_status" target="_blank" rel="noopener noreferrer">napi_status</a></span></a></h3><p>Node.js 中的 N-API（Node.js API）是一个用于构建原生插件的稳定级别的 API。它允许你不直接使用 V8 或其他 JavaScript 引擎的 API，而是使用一组固定的 C API 来编写可跨不同版本的 Node.js 运行的原生代码。</p><p>在 N-API 中，<code>napi_status</code> 是一个枚举类型，它代表了 N-API 函数调用的返回状态，即函数执行成功或失败的状态码。每个 N-API 调用都会返回一个 <code>napi_status</code> 值，以指示操作是否成功，以及如有错误，其性质为何。</p><p>以下是一些例子来解释 <code>napi_status</code> 的不同值：</p><ol><li><code>napi_ok</code>: 表示调用成功完成，没有错误发生。</li><li><code>napi_invalid_arg</code>: 表示传递给函数的某个参数无效。</li><li><code>napi_object_expected</code>: 当 API 期望一个对象，但没有收到对象时返回这个状态。</li><li><code>napi_string_expected</code>: 当 API 期望一个字符串，但得到的不是字符串时返回这个状态。</li><li><code>napi_name_already_registered</code>: 当尝试注册已经存在的名称时返回这个状态码。</li><li><code>napi_generic_failure</code>: 表示出现了未分类的通用错误。</li><li><code>napi_pending_exception</code>: 表示 JavaScript 引擎中存在待处理的异常，阻塞了 N-API 调用的正常执行。</li></ol><p>这些状态码对开发者来说很重要，因为它们提供了关于原生插件中发生什么的直接反馈，并可以据此采取相应的错误处理措施。</p><h3 id="实际运用的例子-1" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-1"><span>实际运用的例子</span></a></h3><p>假设我们正在创建一个原生插件，其中包括一个需要从 JavaScript 传入一个字符串进行处理的函数。我们可以检查传入的参数并根据其状态采取行动：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理获取参数时出现的错误</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保传入的是字符串</span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    status = napi_typeof(env, argv[0], &amp;valuetype);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理获取参数类型时出现的错误</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (valuetype != napi_string) {</span></span>
<span class="line"><span>        // 抛出错误: 我们期望一个字符串</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;String was expected&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果一切正常，则继续处理字符串...</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一些结果</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先调用 <code>napi_get_cb_info</code> 来获取从 JavaScript 传递的参数。如果出错，我们可以根据返回的 <code>napi_status</code> 来确定错误的类型并采取相应的措施。然后我们检查传入参数的类型是否为字符串，如果不是，则抛出类型错误。</p><p>通过这样的机制，开发者能够以稳健的方式构建原生扩展，确保正确地处理输入并在出现问题时提供有用的错误信息。</p><h3 id="napi-extended-error-info" tabindex="-1"><a class="header-anchor" href="#napi-extended-error-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_extended_error_info" target="_blank" rel="noopener noreferrer">napi_extended_error_info</a></span></a></h3><p>Node.js 中的 N-API 是一个 C 级别的 API，它允许本地插件（通常用 C 或 C++编写）与 JavaScript 代码通信。N-API 旨在为构建这些本地插件提供稳定和兼容不同版本的 Node.js 的接口。</p><p><code>napi_extended_error_info</code>结构体是 N-API 中的一个重要概念，它提供了关于发生错误的详细信息。当 N-API 函数返回错误时，这个结构体会包含有助于调试和错误处理的附加信息。</p><p>下面我会解释什么是<code>napi_extended_error_info</code>，并举一些可能的应用场景：</p><h3 id="napi-extended-error-info-1" tabindex="-1"><a class="header-anchor" href="#napi-extended-error-info-1"><span><code>napi_extended_error_info</code></span></a></h3><p><code>napi_extended_error_info</code> 是一个结构体（C 语言中的一种数据类型，可以包含多个其他类型的变量），它定义了与 N-API 操作相关的错误详情。这个结构体里通常包含以下字段：</p><ul><li><code>const char* error_message</code>: 这是一个指向错误消息字符串的指针。错误消息提供了问题的描述。</li><li><code>void* engine_reserved</code>: 这是保留给 JavaScript 引擎自身使用的数据；对于插件开发者来说通常是不可见的。</li><li><code>void* engine_error_code</code>: 这是一个指向特定于引擎的错误代码的指针。</li><li><code>uint32_t error_code</code>: 这是 N-API 的错误码，它表示错误的具体类型。</li></ul><h4 id="实际运用例子-1" tabindex="-1"><a class="header-anchor" href="#实际运用例子-1"><span>实际运用例子</span></a></h4><p>假设你正在编写一个本地插件来提高应用程序性能，例如，一个压缩图片的插件。你可能会用 C 或 C++编写一个函数来处理图片文件，并通过 N-API 将其暴露给 Node.js。</p><p>当你在插件内调用一个 N-API 函数时，比如<code>napi_create_string_utf8</code>来创建一个新的 JavaScript 字符串，这个调用可能因为各种原因失败（例如，如果系统内存不足）。如果这个函数返回一个表示失败的状态码，你可以获取<code>napi_extended_error_info</code>结构体来查看错误详情：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>// ... 省略其他必要的头文件和代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateString(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 尝试创建一个新的字符串 &quot;hello&quot;</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  napi_status status = napi_create_string_utf8(env, &quot;hello&quot;, NAPI_AUTO_LENGTH, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查函数是否成功执行</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 获取错误信息</span></span>
<span class="line"><span>    const napi_extended_error_info* error_info;</span></span>
<span class="line"><span>    napi_get_last_error_info(env, &amp;error_info);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 打印错误信息到控制台</span></span>
<span class="line"><span>    printf(&quot;Failed to create string: %s\n&quot;, error_info-&gt;error_message);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 抛出一个JavaScript异常</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, error_info-&gt;error_message);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码示例中，我们首先尝试使用<code>napi_create_string_utf8</code>创建一个节点字符串。如果这个尝试失败了，我们通过<code>napi_get_last_error_info</code>获取关于这个错误的更多信息，然后打印出错误消息，并且抛出一个 JavaScript 异常来告诉 JavaScript 代码发生了错误。</p><p>通过<code>napi_extended_error_info</code>所提供的信息，作为插件作者，你可以更好地理解错误发生的背景，并且提供更多的上下文信息给使用你插件的开发者。这使得调试本地插件和处理错误成为一件更加可控和清晰的工作。</p><h3 id="napi-env" tabindex="-1"><a class="header-anchor" href="#napi-env"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_env" target="_blank" rel="noopener noreferrer">napi_env</a></span></a></h3><p><code>napi_env</code>是一个代表 Node.js 运行环境的抽象概念，它在 Node.js 的 N-API（Native API）中非常重要。N-API 是一种 C 语言级别的 API，允许开发人员编写可以与 Node.js 代码交互的本地插件，这些插件通常是用 C 或 C++写成的，并且可以直接调用 Node.js 提供的各种 API。</p><p><code>napi_env</code> 是一个指向环境相关数据的指针，你可以将其理解为一个包含了当前 Node.js 实例信息的上下文对象。在 N-API 中进行本地插件开发时，几乎所有的函数都需要这个环境指针来确认它们正在操作的是哪一个 Node.js 实例。</p><p>为什么要有 <code>napi_env</code>？</p><ul><li><strong>多线程支持</strong>: Node.js 是单线程的，但通过 worker threads 可以运行多个线程。每个线程都会有自己的<code>napi_env</code>环境，这样就能确保操作不会冲突。</li><li><strong>模块实例化</strong>: 当你有多个模块实例时，每个实例都有自己的<code>napi_env</code>来存储状态和上下文信息。</li></ul><p>以下是几个使用<code>napi_env</code>的简单示例：</p><ol><li><p><strong>创建一个新的 JavaScript Number</strong>:<br> 为了在本地插件中创建一个新的 JavaScript 数字并返回给 JavaScript，你会使用带有<code>napi_env</code>参数的 N-API 函数，如下所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value my_number;</span></span>
<span class="line"><span>status = napi_create_double(env, 123.456, &amp;my_number);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>从 JavaScript 接收参数</strong>:<br> 假设你正在编写一个本地函数，该函数需要从 JavaScript 端获取参数，你会这样使用<code>napi_env</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value function_callback(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value argv[1];</span></span>
<span class="line"><span>  napi_status status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 假设我们知道argv[0]是一个数字</span></span>
<span class="line"><span>  double value;</span></span>
<span class="line"><span>  status = napi_get_value_double(env, argv[0], &amp;value);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在可以使用这个值做一些操作...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>抛出异常</strong>:<br> 如果在本地插件的执行过程中发生错误，你可能需要抛出一个异常，让 JavaScript 端能够捕获到。你将使用<code>napi_env</code>创建一个错误对象并抛出它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_throw_error(env, NULL, &quot;An error occurred!&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p>这些只是<code>napi_env</code>在 N-API 中应用的基础示例，但它们展示了<code>napi_env</code>作为连接 C/C++代码和 Node.js 运行环境的桥梁的基本用途。在实际开发中，<code>napi_env</code>用于确保你的本地插件可以正确地在 Node.js 环境中运行，管理资源，以及处理异步操作等等。</p><h3 id="node-api-nogc-env" tabindex="-1"><a class="header-anchor" href="#node-api-nogc-env"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_nogc_env" target="_blank" rel="noopener noreferrer">node_api_nogc_env</a></span></a></h3><p><code>node_api_nogc_env</code> 是 Node.js 的 N-API 中的一个特性，它允许原生模块的开发者创建一个不会被垃圾回收器（GC）干预的环境。在详细解释之前，我们先来弄明白几个基本概念。</p><h3 id="什么是-n-api" tabindex="-1"><a class="header-anchor" href="#什么是-n-api"><span>什么是 N-API？</span></a></h3><p>N-API 是 Node.js 提供的一套 C 语言 API 接口，它允许你用 C 或 C++编写扩展模块，这些模块可以直接与 Node.js 运行时交互。使用 N-API 编写的模块是与 Node.js 版本无关的，这意味着你编写一次代码，理论上在任何支持 N-API 的 Node.js 版本上都能运行而无需修改。</p><h3 id="垃圾回收器-gc-是什么" tabindex="-1"><a class="header-anchor" href="#垃圾回收器-gc-是什么"><span>垃圾回收器（GC）是什么？</span></a></h3><p>在 JavaScript 中，当变量或者对象不再需要时，垃圾回收器会自动释放那些内存空间。这是自动进行的，通常开发者不需要手动管理内存。不过，在原生模块中，你可能会创建一些由 C/C++ 管理的资源，这些资源不是 JavaScript 垃圾回收器直接管理的。</p><h3 id="node-api-nogc-env-的作用" tabindex="-1"><a class="header-anchor" href="#node-api-nogc-env-的作用"><span><code>node_api_nogc_env</code> 的作用</span></a></h3><p>当使用 N-API 编写原生模块时，某些情况下你可能需要确保在执行某段关键的代码时，垃圾回收器不要运行。因为如果在这些代码执行期间发生了垃圾回收，可能会导致性能问题或者更糟的情况是错误和崩溃。</p><p>使用 <code>node_api_nogc_env</code> 可以创建一个“无 GC 环境”，在这个环境中执行代码时，Node.js 的垃圾回收器会被暂时阻止执行。这对于控制并优化性能非常有用，尤其是在处理实时数据或高性能计算时。</p><p>举个例子：</p><p>假设你正在编写一个需要与硬件设备通信的 Node.js 原生模块。这个通信过程可能涉及精确的时序和快速的数据处理。在这种情况下，如果代码执行期间发生垃圾回收，可能会导致数据丢失或时序问题。所以，在设置通信协议或处理数据的核心代码部分，你可能会希望使用 <code>node_api_nogc_env</code> 来确保此时不会发生垃圾回收。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设的代码示例</span></span>
<span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CommunicateWithDevice(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建一个无GC环境。</span></span>
<span class="line"><span>    napi_env nogc_env;</span></span>
<span class="line"><span>    napi_create_env(env, &amp;nogc_env);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在此环境中执行关键操作...</span></span>
<span class="line"><span>    // 例如：发送指令到硬件设备，处理返回的数据等操作。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 销毁无GC环境</span></span>
<span class="line"><span>    napi_destroy_env(nogc_env);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return nullptr; // 返回值</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, CommunicateWithDevice, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;communicateWithDevice&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这只是一个概念性的示范，实际的 N-API 用法可能会有所不同。</p><p>重要的是要明白，<code>node_api_nogc_env</code> 应该谨慎使用。阻止垃圾回收器运行可能会导致内存使用随时间增加，因为没有清理不再需要的对象。因此，通常只在必须最大化性能，且了解你的内存管理非常好的情况下，才使用这个特性。</p><h3 id="napi-value" tabindex="-1"><a class="header-anchor" href="#napi-value"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_value" target="_blank" rel="noopener noreferrer">napi_value</a></span></a></h3><p><code>napi_value</code> 是 Node.js 中的 N-API（Node API）的一个概念。N-API 是一个 C 语言接口，它提供了一种建立稳定和兼容不同 Node.js 版本的原生插件（native addons）的方法。在解释 <code>napi_value</code> 前，我们需要先了解几个关键点：</p><ol><li><p><strong>原生插件 (Native Addons)</strong>：这些是用 C 或 C++编写的模块，可以直接调用 Node.js 运行时以外的 API，例如直接操作系统底层功能或访问特定硬件。</p></li><li><p><strong>N-API</strong>：为了使原生插件更加稳定并减少与 Node.js 版本更新相关的异变性，Node.js 提供了 N-API，它定义了一套跨版本稳定的 API。</p></li><li><p><strong>JavaScript 值与 C 类型的映射</strong>：由于 N-API 是用 C 编写的，而 Node.js 的运行环境是基于 JavaScript 的，所以必须有一种方式来在 JavaScript 世界和 C 语言世界之间转换数据。</p></li></ol><p>现在，让我们深入 <code>napi_value</code>：</p><h3 id="napi-value-1" tabindex="-1"><a class="header-anchor" href="#napi-value-1"><span><code>napi_value</code></span></a></h3><p>在使用 N-API 编写原生模块时，你会处理很多 JavaScript 值（如数字、字符串、对象等）。<code>napi_value</code> 是一个抽象表示，它代表了一个 JavaScript 值在 C 语言层面的引用或句柄。每当你想在 C/C++代码中操作一个 JavaScript 值时，你实际上是通过 <code>napi_value</code> 这个抽象层来进行操作。</p><p><code>napi_value</code> 只是一个指针（或者说是一个引用），它没有告诉你具体的值是什么，但它可以被传递到其他 N-API 函数中去创建、查询或操作那个 JavaScript 值。</p><h4 id="实际例子-2" tabindex="-1"><a class="header-anchor" href="#实际例子-2"><span>实际例子</span></a></h4><p>假设你想写一个原生插件函数，将两个 JavaScript 数字相加，并返回结果。以下是可能的 C 代码片段：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 函数实现，用于加法操作</span></span>
<span class="line"><span>napi_value Add(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数数量和类型等...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    double value1, value2;</span></span>
<span class="line"><span>    status = napi_get_value_double(env, args[0], &amp;value1);</span></span>
<span class="line"><span>    status = napi_get_value_double(env, args[1], &amp;value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value sum;</span></span>
<span class="line"><span>    status = napi_create_double(env, value1 + value2, &amp;sum);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册Add函数到module.exports</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, Add, NULL, &amp;fn);</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;add&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中：</p><ul><li><code>Add</code> 函数就是我们要用 N-API 暴露给 JavaScript 的 C 函数。</li><li><code>args</code> 数组包含着函数调用时传递进来的 JavaScript 参数。</li><li>每一个 <code>args</code> 元素都是一个 <code>napi_value</code> 类型，表示 JavaScript 传递的值。</li><li>使用 <code>napi_get_value_double</code> 函数从 <code>napi_value</code> 中提取出 C 语言中的 <code>double</code> 类型的数值。</li><li><code>napi_create_double</code> 创建了一个新的 JavaScript Number 值，并返回其 <code>napi_value</code> 表示。</li><li>最后，<code>Add</code> 函数通过返回这个新创建的 <code>napi_value</code> 将结果传回 JavaScript。</li></ul><p>使用以上代码，你在 JavaScript 中就可以像下面这样调用该插件：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/nativeAddon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: 15</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>napi_value</code> 是 N-API 编程中的核心概念，因为它是 JavaScript 世界和 C 世界互动的桥梁。通过理解和使用 <code>napi_value</code>，你可以构建强大的 Node.js 原生扩展，充分发挥 JavaScript 和系统底层能力的结合优势。</p><h3 id="napi-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_threadsafe_function</a></span></a></h3><p>Node.js 中的<code>napi_threadsafe_function</code>是一个非常强大的功能，它允许你从任何线程安全地调用 JavaScript 函数。在了解这个概念之前，我们需要先理解几个基础点：</p><ol><li><p><strong>Node.js 的单线程模型</strong>：Node.js 通常运行在单个线程上，这意味着所有的 JavaScript 代码都在同一个线程（主线程）上执行。但是，有时候我们可能需要执行一些耗时的操作，比如读写文件、网络请求或者其他复杂计算，这些操作如果放在主线程上执行，会阻塞其他代码的执行。</p></li><li><p><strong>异步和事件循环</strong>：为了解决上述问题，Node.js 采用非阻塞 I/O 和事件循环机制来进行异步编程。这样，一些耗时的操作可以在后台执行，执行完毕后通过回调函数来通知主线程。</p></li><li><p><strong>多线程和<code>worker_threads</code></strong>：尽管 Node.js 主要是单线程的，但它也支持使用<code>worker_threads</code>模块创建真正的多线程。这在处理 CPU 密集型任务时非常有用，因为可以创建工作线程来分担计算负荷。</p></li></ol><p>现在，当你在工作线程（或者任何非主线程）中进行操作，并且想要与主线程中的 JavaScript 代码交互时，就需要用到<code>napi_threadsafe_function</code>了。</p><h3 id="napi-threadsafe-function-使用场景和例子" tabindex="-1"><a class="header-anchor" href="#napi-threadsafe-function-使用场景和例子"><span><code>napi_threadsafe_function</code> 使用场景和例子</span></a></h3><p>假设你在一个 Node.js 应用程序中运行了一个工作线程来执行一个耗时的图像处理任务。完成这个任务后，工作线程需要将结果传送回主线程，以便更新用户界面或者发送给客户端。这里就可以使用<code>napi_threadsafe_function</code>来实现安全的通信。</p><p><strong>例子 1：</strong></p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">isMainThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">parentPort</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;worker_threads&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">isMainThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 主线程代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">__filename</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 接收工作线程发来的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;收到:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;error&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;exit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">code</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">code</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> !==</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`工作线程停止，退出码: </span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">${</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">code</span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 工作线程代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  parentPort</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;工作线程发送的数据&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个简化的例子中，我们没有直接使用<code>napi_threadsafe_function</code>，因为<code>worker_threads</code>模块已经对其进行了封装。工作线程通过<code>parentPort.postMessage</code>发送消息，主线程通过监听<code>message</code>事件来接受消息。</p><p><strong>例子 2：使用<code>napi_threadsafe_function</code>的原生扩展</strong></p><p>如果你正在编写一个需要在 C++中创建新线程，并且需要和 JS 通信的 Node.js 原生扩展，那么你就需要直接使用<code>napi_create_threadsafe_function</code>。</p><p>由于这涉及到较复杂的 C++代码和 Node.js 的 N-API 接口，以下只提供一个高层次的概念介绍：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// C++ 线程执行的函数</span></span>
<span class="line"><span>void MyThreadFunction(napi_threadsafe_function tsfn) {</span></span>
<span class="line"><span>    // 执行一些任务...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 JavaScript 函数</span></span>
<span class="line"><span>    napi_call_threadsafe_function(tsfn, ...);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 任务完成，释放函数</span></span>
<span class="line"><span>    napi_release_threadsafe_function(tsfn, napi_tsfn_release);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化 threadsafe function 并创建线程</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value js_func;</span></span>
<span class="line"><span>    // 获取 JavaScript 函数参数...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 threadsafe function</span></span>
<span class="line"><span>    napi_create_threadsafe_function(env, js_func, ..., MyThreadFunction, ..., &amp;tsfn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建并启动一个新线程...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>napi_create_threadsafe_function</code>用于创建一个可以跨线程安全调用的 JavaScript 函数。C++线程可以使用这个函数来安全地回调 JavaScript 函数，而不会造成并发问题。</p><p>总结起来，<code>napi_threadsafe_function</code>是 Native Addons 在多线程环境下与 JavaScript 代码交互的桥梁。对于纯 JavaScript 开发者而言，通常不需要直接使用它，因为<code>worker_threads</code>模块已经提供了更高级别的抽象。</p><h3 id="napi-threadsafe-function-release-mode" tabindex="-1"><a class="header-anchor" href="#napi-threadsafe-function-release-mode"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_threadsafe_function_release_mode" target="_blank" rel="noopener noreferrer">napi_threadsafe_function_release_mode</a></span></a></h3><p><code>napi_threadsafe_function_release_mode</code> 是 Node.js 中 N-API 的一部分，N-API 是一个用于构建原生插件的 API。在深入理解 <code>napi_threadsafe_function_release_mode</code> 之前，让我们先了解一些基础概念。</p><p><strong>什么是 N-API？</strong></p><p>N-API 是 Node.js 提供的一个抽象层，允许你使用 C 或 C++ 编写可以和 JavaScript 代码交互的原生插件。这样，你就能够在本地代码中执行高性能或系统级别操作，然后通过 JavaScript 在 Node.js 环境中调用这些操作。</p><p><strong>什么是 Thread-safe Function（线程安全函数）？</strong></p><p>在多线程编程中，&quot;线程安全&quot;意味着在多个线程同时访问同一资源时，程序能够正确地管理对该资源的访问，以避免不可预料的结果或崩溃。当你从原生线程访问 Node.js 运行时或者想要在原生线程中调用 JavaScript 函数时，你会需要这种线程安全机制。</p><p><strong><code>napi_threadsafe_function_release_mode</code> 的作用：</strong></p><p><code>napi_threadsafe_function_release_mode</code> 是一个枚举值，它描述了在释放（结束）一个线程安全函数时应该采取的行为模式。当你完成了对线程安全函数的使用，并且想要清理资源，通知 Node.js 这个函数不再被原生代码使用时，你会调用相关的 N-API 函数来释放这个线程安全函数。</p><p>Node.js 提供了两种释放模式：</p><ol><li><p><code>napi_tsfn_release</code>：这是默认的释放模式。当你调用这个选项时，Node.js 将等待所有已经提交给线程安全函数的任务都完成才会销毁这个函数。</p></li><li><p><code>napi_tsfn_abort</code>：如果你选择这个模式，Node.js 将立即停止接受新的任务，并尽可能快地销毁这个函数。这个模式适合于那些由于某些原因需要立即终止的情况。</p></li></ol><p><strong>实际运用例子：</strong></p><p>假设你正在开发一个 Node.js 应用程序，该程序需要处理图像。</p><ol><li><p><strong>普通模式 (napi_tsfn_release)</strong>：</p><ul><li>你创建了一个线程安全函数，让其调用一个 C++ 函数来处理图像。</li><li>随着用户上传更多的图片，你的应用程序将这些图片推送到原生队列中。</li><li>最终用户停止上传图片，你决定关闭应用程序。</li><li>在关闭前，你使用 <code>napi_tsfn_release</code> 模式释放线程安全函数，确保所有排队的图像都得到处理，然后再关闭。</li></ul></li><li><p><strong>中止模式 (napi_tsfn_abort)</strong>：</p><ul><li>同样的情况，但突然间你的应用程序需要紧急关闭（可能是因为内存泄露或其他关键错误）。</li><li>在这种场景下，你不能等待所有的图片都处理完成，因此你使用 <code>napi_tsfn_abort</code> 来快速释放线程安全函数，然后关闭应用程序。</li></ul></li></ol><p>通过使用合适的释放模式，你可以更好地控制如何安全地结束与 JavaScript 运行时的交互，无论是有序地完成所有任务还是紧急中断。</p><h3 id="napi-threadsafe-function-call-mode" tabindex="-1"><a class="header-anchor" href="#napi-threadsafe-function-call-mode"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_threadsafe_function_call_mode" target="_blank" rel="noopener noreferrer">napi_threadsafe_function_call_mode</a></span></a></h3><p><code>napi_threadsafe_function_call_mode</code> 是 Node.js 中 N-API 的一个枚举类型，它用于指定调用线程安全函数时的行为模式。在解释这个概念之前，让我们先了解一些背景知识。</p><p>Node.js 是单线程的，这意味着它默认情况下只使用一个线程来执行所有的 JavaScript 代码。然而，在某些情况下，你可能需要执行一些耗时的任务，比如读取大文件、进行复杂计算或者访问数据库等。在这种情况下，如果在主线程中执行这些耗时的操作，会造成应用响应缓慢，影响用户体验。</p><p>为了解决这个问题，Node.js 提供了 Worker 线程（通过 <code>worker_threads</code> 模块），允许你创建额外的线程来处理这些耗时任务，而不会阻塞主线程。</p><p>然而，当你想要从这些新创建的 Worker 线程与主线程（或者其他 Worker 线程）通信时，你需要一个安全的方式来交换数据和发送消息。这就是 <code>napi_threadsafe_function</code> 函数发挥作用的地方：它允许你创建一个可以从任何线程安全地调用的 JavaScript 函数。</p><p>现在，让我们回到 <code>napi_threadsafe_function_call_mode</code>。这个枚举有两个值，它们控制当你尝试调用线程安全函数时的行为：</p><ol><li><code>napi_tsfn_blocking</code>: 如果队列已满，该模式会使调用者阻塞（等待），直到队列有空位让调用者插入它的请求。</li><li><code>napi_tsfn_nonblocking</code>: 如果队列已满，该模式会直接返回一个错误，不会阻塞调用者。</li></ol><h3 id="实际运用的例子-2" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-2"><span>实际运用的例子</span></a></h3><p>假设你正在编写一个 Node.js 应用，需要从多个网络资源下载数据。每个下载可能会花费较长时间，所以你决定在 Worker 线程中执行下载任务。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">isMainThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">parentPort</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;worker_threads&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">isMainThread</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 主线程代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">__filename</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 监听来自 Worker 的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  worker</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Received from worker:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // Worker 线程代码</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 模拟一些耗时的操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    parentPort</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Download complete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面这个例子中，我们创建了一个 Worker 线程来模拟一个耗时的下载操作。然后，当下载完成后，Worker 发送一个消息回主线程。</p><p>现在，让我们改进这个例子，假设我们的下载函数是一个原生的 C++ 插件，并使用 N-API 创建线程安全函数来从 Worker 线程中通知主线程下载完成。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设这是一个 C++ 插件的代码片段</span></span>
<span class="line"><span>napi_value DownloadComplete(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 获取线程安全函数对象，并调用它</span></span>
<span class="line"><span>  napi_status status = napi_call_threadsafe_function(my_tsfn, &quot;Download complete&quot;, napi_tsfn_blocking);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return nullptr;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个 C++ 代码片段中，<code>my_tsfn</code> 是之前创建的线程安全函数对象。我们尝试用 <code>napi_call_threadsafe_function</code> 调用它，并传递 <code>&quot;Download complete&quot;</code> 字符串作为消息。我们使用 <code>napi_tsfn_blocking</code> 模式，因为我们希望在队列满时等待，直到有空间可以发送消息。</p><p>如果我们想要非阻塞行为，我们可以选择 <code>napi_tsfn_nonblocking</code> 模式，这样如果队列满了，函数将立即返回一个错误，我们可以据此决定是否重试或采取其他措施。</p><h3 id="node-api-memory-management-types" tabindex="-1"><a class="header-anchor" href="#node-api-memory-management-types"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-api-memory-management-types" target="_blank" rel="noopener noreferrer">Node-API memory management types</a></span></a></h3><p>Node-API（之前称为 N-API）是 Node.js 的一个部分，它提供了一个稳定且独立于 JavaScript 运行时的 API，使得我们可以构建原生模块。这些原生模块是用 C 或 C++编写的，并且可以被 Node.js 直接调用。Node-API 保证了跨不同版本的 Node.js 二进制兼容性，这意味着原生模块不需要针对每个新版本的 Node.js 重新编译。</p><p>让我们来谈谈在 Node-API 中涉及内存管理的类型。在 Node-API 中，你会遇到几种与内存管理相关的类型和方法，这些都是为了确保资源有效地使用，防止内存泄漏。以下是其中一些主要的概念：</p><ol><li><p><strong><code>napi_value</code></strong>: 这是一个表示 JavaScript 值的抽象类型，在 Node-API 函数中经常使用。当你创建一个新的 JavaScript 对象、字符串或任何其他 JS 值时，Node-API 通常会返回一个<code>napi_value</code>。</p></li><li><p><strong>引用（Reference）</strong>: 在 Node-API 中，引用是一个指向<code>napi_value</code>的指针，它确保了即使在本地代码执行完成后，该值仍然不会被垃圾回收器回收。在 Node-API 中，你可以创建弱引用或强引用。</p><ul><li><p><strong>强引用</strong>：保持了对<code>napi_value</code>的一个活跃的引用，这意味着只要引用存在，垃圾回收器就不会释放该值。这在你需要长期持有一个值时非常有用。</p></li><li><p><strong>弱引用</strong>：不保证<code>napi_value</code>的生命周期。垃圾回收器可以随时释放掉相关联的值。这对于允许内存释放，同时依然能够偶尔访问值的场景很有用。</p></li></ul></li><li><p><strong><code>napi_finalize</code></strong>: 这是一个回调函数，当一个与<code>napi_value</code>相关联的对象被垃圾回收器回收时，这个函数会被调用。它允许你进行清理操作，比如释放在原生层分配的内存。</p></li></ol><p>现在，让我们举一个例子来说明这些概念：</p><p>假设你正在创建一个 Node.js 原生模块，该模块包含了一个原生 C++对象。你想要在 JavaScript 层次上暴露这个对象，并且想要在该对象不再需要时自动清理它所占用的资源。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的C++对象</span></span>
<span class="line"><span>class MyObject {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    MyObject() { /* 构造函数逻辑 */ }</span></span>
<span class="line"><span>    ~MyObject() { /* 析构函数逻辑，例如释放分配的内存 */ }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是当JS对象被垃圾回收器回收时，将被调用的回调函数</span></span>
<span class="line"><span>void FinalizeCallback(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    // 将finalize_data转型回MyObject指针并删除它</span></span>
<span class="line"><span>    MyObject* obj = static_cast`&lt;`MyObject*&gt;(finalize_data);</span></span>
<span class="line"><span>    delete obj;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是一个Node-API函数，它创建并返回一个新的MyObject实例的封装</span></span>
<span class="line"><span>napi_value CreateMyObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建一个新的C++ MyObject实例</span></span>
<span class="line"><span>    MyObject* obj = new MyObject();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的空JS对象</span></span>
<span class="line"><span>    napi_value js_obj;</span></span>
<span class="line"><span>    napi_create_object(env, &amp;js_obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将C++对象与JS对象关联，并设置FinalizeCallback作为析构回调</span></span>
<span class="line"><span>    napi_wrap(env, js_obj, obj, FinalizeCallback, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的JS对象</span></span>
<span class="line"><span>    return js_obj;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 你需要将CreateMyObject函数暴露给JavaScript，这样你就可以在JS代码中调用它</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，你创建了一个 C++对象，并通过 Node-API 将其封装在一个 JavaScript 对象中。你还设置了一个<code>FinalizeCallback</code>回调，当 JavaScript 对象被垃圾回收时，这个回调会被触发以清理 C++对象。这样，你就实现了在原生模块和 JavaScript 之间的桥梁，同时确保了良好的内存管理。</p><h4 id="napi-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_handle_scope" target="_blank" rel="noopener noreferrer">napi_handle_scope</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。在 Node.js 中，JavaScript 通常运行在 V8 引擎上，而 N-API 允许开发者使用 C 或 C++ 代码与 JavaScript 进行交互。</p><p><code>napi_handle_scope</code> 是 N-API 中的一个概念，它和垃圾回收机制有关。在 JavaScript 中，当你创建了很多对象（比如字符串、数组、对象等）以后，这些对象会占用内存。为了释放不再需要的对象所占用的内存，V8 引擎会定期执行垃圾回收。</p><p>当你在使用 N-API 编写原生模块时，可能会创建很多和 JavaScript 交互的对象。<code>napi_handle_scope</code> 就是用来管理这些对象的生命周期。每个 <code>napi_handle_scope</code> 都是一系列 N-API 对象的上下文环境，N-API 会负责跟踪在这个作用域中创建的所有对象，并在这个作用域结束时，确保这些对象能够被垃圾回收器正确地处理。</p><p>使用 <code>napi_handle_scope</code> 的实际例子：</p><p>假设你正在编写一个 Node.js 的原生模块，这个模块需要创建一个新的 JavaScript 数组，并在这个数组中填充一些数字。你可以这样做：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数是用来创建并返回一个新的 JavaScript 数组，数组中包含了从0到9的数字。</span></span>
<span class="line"><span>napi_value CreateArrayWithNumbers(napi_env env) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的 handle scope</span></span>
<span class="line"><span>    napi_handle_scope scope;</span></span>
<span class="line"><span>    status = napi_open_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的 JavaScript 数组</span></span>
<span class="line"><span>    napi_value array;</span></span>
<span class="line"><span>    status = napi_create_array_with_length(env, 10, &amp;array);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 填充数组</span></span>
<span class="line"><span>    for (int i = 0; i `&lt;` 10; ++i) {</span></span>
<span class="line"><span>        napi_value num;</span></span>
<span class="line"><span>        status = napi_create_int32(env, i, &amp;num);</span></span>
<span class="line"><span>        if (status != napi_ok) {</span></span>
<span class="line"><span>            // 处理错误...</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 把数字设置到数组对应的索引上</span></span>
<span class="line"><span>        status = napi_set_element(env, array, i, num);</span></span>
<span class="line"><span>        if (status != napi_ok) {</span></span>
<span class="line"><span>            // 处理错误...</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 关闭 handle scope，在这之后，我们创建的所有本地对象都可以被垃圾回收了</span></span>
<span class="line"><span>    status = napi_close_handle_scope(env, scope);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return array;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们首先打开了一个 <code>napi_handle_scope</code>，然后执行了创建数组和填充数组的操作。在操作完成后，我们关闭了 <code>napi_handle_scope</code>。关闭操作告诉 N-API，我们在这个作用域中创建的所有对象在这之后都不再需要了，因此它们可以被垃圾回收机制回收。</p><p>简而言之，<code>napi_handle_scope</code> 被用于在编写原生模块时管理对象的生命周期，确保它们能在合适的时候被垃圾回收，以此避免内存泄露。</p><h4 id="napi-escapable-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-escapable-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_escapable_handle_scope" target="_blank" rel="noopener noreferrer">napi_escapable_handle_scope</a></span></a></h4><p>当然，我会用尽可能简单的语言来解释 <code>napi_escapable_handle_scope</code>。</p><p>首先，要了解 <code>napi_escapable_handle_scope</code> 的概念，我们需要先理解 Node.js 中的 N-API 以及它为何存在。</p><p><strong>N-API 是什么？</strong><br> N-API 是 Node.js 提供的一个稳定的原生（C/C++）API 层。它允许原生模块（native modules）开发者编写与 Node.js 版本无关的代码，这就意味着一旦你编写了使用 N-API 的原生模块，它可以在未来的 Node.js 版本中运行，而不需要重新编译。</p><p><strong>什么是 Handle Scope？</strong><br> 在 Node.js 中，JavaScript 和原生代码（比如 C/C++ 代码）之间有一个桥梁，那就是 V8 引擎。在 V8 中，所有的 JavaScript 对象都被表示为 &quot;handles&quot;（句柄）。Handle Scopes 是 V8 提供的一种管理内存的机制，它可以确保对象（handles）不会泄漏，并且在合适的时候得到清理。</p><p><strong>那么 napi_escapable_handle_scope 是什么？</strong><br><code>napi_escapable_handle_scope</code> 是一个特殊类型的 handle scope，它允许一个从其中创建的句柄“逃逸”出来，变成可以在父级作用域中使用的句柄。</p><p>在 N-API 中，通常我们会创建一个 <code>napi_handle_scope</code> 来管理我们创建的句柄，这样可以避免内存泄露。而当我们想要将某个句柄传递给另外一个作用域使用时，普通的 <code>napi_handle_scope</code> 是做不到的，这时我们就需要用到 <code>napi_escapable_handle_scope</code>。</p><p><strong>实际运用例子：</strong><br> 让我们假设你正在编写一个原生模块，该模块需要创建一个新的 JavaScript 对象并返回给调用者。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_escapable_handle_scope scope;</span></span>
<span class="line"><span>    napi_value object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 escapable handle scope</span></span>
<span class="line"><span>    status = napi_open_escapable_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的 JavaScript 对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;object);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_close_escapable_handle_scope(env, scope);</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这里可以设置对象的属性等</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // &quot;逃逸&quot;这个对象出去，使它能在函数外部使用</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_escape_handle(env, scope, object, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_close_escapable_handle_scope(env, scope);</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 关闭 handle scope</span></span>
<span class="line"><span>    status = napi_close_escapable_handle_scope(env, scope);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result; // 返回逃逸后的对象</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先打开了一个 escapable handle scope，这允许我们稍后通过 <code>napi_escape_handle</code> 函数将创建的 JavaScript 对象传递到这个作用域之外。然后我们创建了一个新的对象，并通过 <code>napi_escape_handle</code> &quot;逃逸&quot; 这个对象。最后，我们关闭了 handle scope 并返回了逃逸的对象。</p><p>这就是 <code>napi_escapable_handle_scope</code> 的基本用法，它在编写涉及跨作用域传递 JavaScript 对象的原生模块时非常有用。</p><h4 id="napi-ref" tabindex="-1"><a class="header-anchor" href="#napi-ref"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_ref" target="_blank" rel="noopener noreferrer">napi_ref</a></span></a></h4><p>好的，首先我会简单介绍一下 Node.js 和 N-API 是什么，然后再详细解释 napi_ref，并给出实际的例子。</p><p><strong>Node.js 简介</strong>：<br> Node.js 是一个用于构建服务器端和网络应用程序的开源跨平台 JavaScript 运行时环境。它允许你使用 JavaScript 编写服务器端代码，这是一种通常仅用于编写网页前端代码的语言。</p><p><strong>N-API 简介</strong>：<br> N-API 是 Node.js 提供的一个 C API，它旨在减少 Node.js 原生插件与不同版本的 V8 引擎（Node.js 的底层 JavaScript 引擎）之间的兼容性问题。简而言之，N-API 让开发者可以编写只需要编译一次就能在多个版本的 Node.js 上运行的原生插件。</p><p><strong>napi_ref 是什么</strong>：<br><code>napi_ref</code> 是 N-API 中的一个数据类型，代表一个对 JavaScript 对象的引用。在 Node.js 的原生插件中，当你想要保持对某个 JavaScript 对象的引用，以便在将来的本地函数调用中使用它时，你会用到 <code>napi_ref</code>。</p><p>如果没有 <code>napi_ref</code>，JavaScript 对象可能会因为垃圾回收而被销毁，特别是当对象不再被任何变量引用时。通过创建一个 <code>napi_ref</code>，你可以确保该对象在本地代码中仍然有效，直到你主动删除该引用。</p><p><strong>实际的例子</strong>：</p><p>假设你正在编写一个 Node.js 原生插件，该插件需要在本地代码中保存一个 JavaScript 函数，以便稍后调用它。你可以使用 <code>napi_create_reference</code> 创建一个 <code>napi_ref</code> 来存储对该函数的引用。</p><p>以下是如何在 N-API 中创建和使用 <code>napi_ref</code> 的简单示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义一个全局变量来存储引用</span></span>
<span class="line"><span>static napi_ref myFunctionRef;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个初始化函数，它接受一个 JavaScript 函数并保存它的引用</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 获取传入的参数（我们假定是一个函数）</span></span>
<span class="line"><span>  napi_value myFunction;</span></span>
<span class="line"><span>  napi_get_cb_info(env, args, &amp;myFunction, NULL, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个引用</span></span>
<span class="line"><span>  napi_create_reference(env, myFunction, 1, &amp;myFunctionRef);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个调用保存的 JavaScript 函数的函数</span></span>
<span class="line"><span>void CallMyFunction(napi_env env) {</span></span>
<span class="line"><span>  napi_value myFunction;</span></span>
<span class="line"><span>  napi_get_reference_value(env, myFunctionRef, &amp;myFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用该函数</span></span>
<span class="line"><span>  napi_value global;</span></span>
<span class="line"><span>  napi_get_global(env, &amp;global);</span></span>
<span class="line"><span>  napi_call_function(env, global, myFunction, 0, NULL, NULL);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 删除引用</span></span>
<span class="line"><span>void DeleteReference(napi_env env) {</span></span>
<span class="line"><span>  napi_delete_reference(env, myFunctionRef);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们定义了一个名为 <code>Init</code> 的初始化函数，它创建了一个引用来保存 JavaScript 环境中传递进来的函数。然后，在 <code>CallMyFunction</code> 函数中，我们通过这个引用获取函数对象并调用它。最后，我们可以使用 <code>DeleteReference</code> 函数来删除这个引用，以允许 JavaScript 对象被垃圾回收。</p><p>请注意，这里的例子非常简单，实际应用中需要更多的错误检查和资源管理机制。</p><h4 id="napi-type-tag" tabindex="-1"><a class="header-anchor" href="#napi-type-tag"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_type_tag" target="_blank" rel="noopener noreferrer">napi_type_tag</a></span></a></h4><p>N-API 是 Node.js 的一个 API，它提供了一个抽象层，使得你可以在不同版本的 Node.js 运行时中编写原生插件，而不用担心底层的变化。<code>napi_type_tag</code>是 N-API 中的一个功能，旨在帮助你确保你在 JavaScript 和 C 之间传递的对象是正确的类型。</p><p>要理解<code>napi_type_tag</code>的作用，我们先得知道类型标记（type tagging）是什么。类型标记是一种技术，用于标识特定的对象，以便能够验证对象是否为预期的类型。当你在 C 和 JavaScript 之间传递对象时，有时你需要确保接收到的对象正是你发送的对象的类型，这样才能安全地进行操作。</p><p>使用<code>napi_type_tag</code>，你可以给一个自定义的对象指定一个独一无二的&quot;标签&quot;（即<code>napi_type_tag</code>结构）。然后，每次该对象通过 N-API 接口从 C 传到 JavaScript 或从 JavaScript 传回 C 时，N-API 都会检查这个标签确保它匹配，如果不匹配，就会报错。</p><p>举例说明：</p><p>假设你正在编写一个 Node.js 原生模块，该模块提供了一个名为“MyObject”的自定义对象，并且你想确保只有“MyObject”实例可以被用于某些特定的函数调用。</p><ol><li>首先，你会创建一个全局的<code>napi_type_tag</code>变量来代表&quot;MyObject&quot;类型：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_type_tag my_object_type_tag = { 0 }; // 初始化一个空的type tag</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>当你在 C 代码里创建一个新的&quot;MyObject&quot;实例时，你会使用<code>napi_type_tag_instance()</code>函数来将这个新对象与<code>my_object_type_tag</code>关联起来：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_my_object(napi_env env) {</span></span>
<span class="line"><span>    napi_value my_object;</span></span>
<span class="line"><span>    // ... 创建my_object的代码 ...</span></span>
<span class="line"><span>    napi_status status = napi_type_tag_instance(env, my_object, &amp;my_object_type_tag);</span></span>
<span class="line"><span>    // 检查并处理status是否成功...</span></span>
<span class="line"><span>    return my_object;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>如果你有一个函数，它的输入参数应该是&quot;MyObject&quot;类型的对象，你可以在这个函数中使用<code>napi_check_object_type_tag()</code>来验证传入的对象是否真的带有正确的标签：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value use_my_object(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 从info中获取JavaScript传入的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查传入的对象是否是MyObject类型</span></span>
<span class="line"><span>    bool is_my_object;</span></span>
<span class="line"><span>    napi_status status = napi_check_object_type_tag(env, args[0], &amp;my_object_type_tag, &amp;is_my_object);</span></span>
<span class="line"><span>    // 检查并处理status是否成功...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (!is_my_object) {</span></span>
<span class="line"><span>        // 抛出错误，因为传入的不是MyObject类型</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Argument is not a MyObject type.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在这里执行其他操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return some_result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，你就可以确保在原生模块中的函数只接收和操作正确类型的对象，从而避免潜在的类型混淆和运行时错误。这对于在原生模块中维护类型安全非常重要，尤其是当涉及到内存管理时，错误的类型操作可能导致程序崩溃或者安全漏洞。</p><h4 id="napi-async-cleanup-hook-handle" tabindex="-1"><a class="header-anchor" href="#napi-async-cleanup-hook-handle"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_cleanup_hook_handle" target="_blank" rel="noopener noreferrer">napi_async_cleanup_hook_handle</a></span></a></h4><p><code>napi_async_cleanup_hook_handle</code> 是 Node.js 中的一个特性，它属于 N-API（Node API），这是一个用于构建原生插件的 API。在理解 <code>napi_async_cleanup_hook_handle</code> 之前，需要了解几个基本概念：</p><ol><li><p><strong>N-API</strong>：这是一个 C 语言级别的 API，让开发者可以不依赖于 V8 引擎直接与 Node.js 进行交互。它的好处是使得原生插件不受特定版本的 Node.js 限制，增加了跨版本兼容性。</p></li><li><p><strong>原生插件</strong>：通常用 C 或 C++编写，它们可以直接使用操作系统底层能力或其他本地库，为 Node.js 提供额外功能。</p></li><li><p><strong>异步清理钩子</strong>：在 Node.js 中，当你创建异步资源时（例如，开始一个新的操作系统线程或者分配一些需要在未来某个时间点释放的内存），可能需要在这些资源不再需要时进行清理。异步清理钩子就是在 Node.js 环境即将关闭时确保这些资源被正确清理的机制。</p></li></ol><p>现在，讲解一下 <code>napi_async_cleanup_hook_handle</code>：</p><ul><li>当你使用 N-API 创建原生插件，并在其中创建了异步资源时，你可能希望在 Node.js 退出前执行一些清理工作。</li><li><code>napi_async_cleanup_hook_handle</code> 就是这样一个机制。具体来说，它是一种类型，代表了一个清理钩子的“句柄”（handle）。</li><li>你可以通过调用 <code>napi_add_async_cleanup_hook</code> 函数来注册一个清理函数，这个函数会在适当的时候被调用，以便进行资源清理。</li><li>注册清理函数时，你会获得一个 <code>napi_async_cleanup_hook_handle</code> 实例，你可以使用它来移除注册的钩子（如果在某个时间点你决定不再需要它）。</li></ul><p>实际应用示例：<br> 假设你正在编写一个原生插件，该插件需要在背后运行一个计时器。当 Node.js 进程结束时，你需要确保这个计时器被停止并且相关资源被释放。你可以这样做：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void cleanup_timer(void* arg) {</span></span>
<span class="line"><span>  // 假设arg是指向你的计时器资源的指针</span></span>
<span class="line"><span>  // 在这里写上停止计时器和释放资源的代码</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // ... 初始化代码，比如创建计时器等</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 注册清理钩子</span></span>
<span class="line"><span>  napi_async_cleanup_hook_handle handle;</span></span>
<span class="line"><span>  napi_status status = napi_add_async_cleanup_hook(env, cleanup_timer, /*arg=*/timer, &amp;handle);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个 <code>cleanup_timer</code> 函数，当 Node.js 进程退出时，这个函数会被调用来清理计时器。然后，在模块的初始化函数 <code>Init</code> 中，我们使用 <code>napi_add_async_cleanup_hook</code> 来注册这个清理函数，并传递计时器作为参数。</p><p>总结起来，<code>napi_async_cleanup_hook_handle</code> 是一种确保原生插件的异步资源在 Node.js 环境关闭前得到合适处理的机制。通过注册清理钩子，可以帮助开发者管理资源的生命周期，避免内存泄漏等问题。</p><h3 id="node-api-callback-types" tabindex="-1"><a class="header-anchor" href="#node-api-callback-types"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node-api-callback-types" target="_blank" rel="noopener noreferrer">Node-API callback types</a></span></a></h3><p>Node-API（之前称为 N-API）是 Node.js 的一个 API 层，它允许你编写能够在不同版本的 Node.js 上运行的本机插件。本机插件是使用 C 或 C++编写的模块，它们可以直接与 Node.js 的 V8 引擎交互，这使得它们在执行速度上非常高效。但是，这些代码通常需要针对不同版本的 Node.js 进行修改，因为内部的 V8 API 可能会有变化。Node-API 旨在提供一个稳定、版本无关的 API，使得本机插件开发者不必担心这些问题。</p><p>在 Node-API 中，&quot;回调类型&quot;指的是当你创建一个原生函数时，可以传递给 Node-API 的不同种类的函数签名。这些回调类型定义了你的函数应该如何与 JavaScript 代码互动。下面分别解释一下这些类型，并提供一些实际的例子。</p><ol><li><p><code>napi_callback</code>: 这是最基本的回调类型。它表示一个本机函数，该函数可以被 JavaScript 代码调用。它通常用于执行某些操作，然后返回结果给 JavaScript。</p><p>例子:<br> 假设我们想要创建一个本机函数，它接收两个数值参数，返回它们的和。我们会定义一个<code>napi_callback</code>函数，像这样：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value Add(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value argv[2];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查传入参数的数量和类型等...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    double value1, value2;</span></span>
<span class="line"><span>    status = napi_get_value_double(env, argv[0], &amp;value1);</span></span>
<span class="line"><span>    status = napi_get_value_double(env, argv[1], &amp;value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value sum;</span></span>
<span class="line"><span>    status = napi_create_double(env, value1 + value2, &amp;sum);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 中，你可以像调用普通函数那样调用这个<code>Add</code>函数。</p></li><li><p><code>napi_threadsafe_function</code>: 当你需要从任何线程安全地调用 JavaScript 函数时，就会用到这个类型。例如，如果你创建了一个工作线程，在工作完成后想要通知 JavaScript 主线程，则可以使用这个类型。</p><p>例子:<br> 假设我们有一个执行耗时计算的工作线程，我们想在完成后将结果回传给 JavaScript。你可以创建一个<code>napi_threadsafe_function</code>并在工作线程中调用它。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void CallJs(napi_env env, napi_value js_callback, void* context, void* data) {</span></span>
<span class="line"><span>    // 从数据中获取计算的结果，并通过回调函数传递给JavaScript</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 其他代码会设置工作线程，并在适当的时候调用CallJs</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 JavaScript 中，你可以提供一个回调函数来接收和处理结果。</p></li><li><p><code>napi_async_execute_callback</code> 和 <code>napi_async_complete_callback</code>: 这两个类型用于异步操作。第一个用于在独立的线程中执行长时间运行的任务，而第二个用于在任务完成时在主事件循环中执行回调。</p><p>例子:<br> 如果我们想读取一个大文件而不阻塞主事件循环，我们可以创建一个异步操作。使用这两个回调，我们可以在单独的线程中读取文件内容（<code>napi_async_execute_callback</code>），然后在读取完成时通知 JavaScript 主线程（<code>napi_async_complete_callback</code>）。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void ExecuteReadFile(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 在此处执行文件读取操作</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CompleteReadFile(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 处理完成后的回调，例如将读取的内容传递给JavaScript</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用napi_create_async_work创建异步工作，然后使用napi_queue_async_work将其加入事件循环</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>通过使用这些回调类型，你可以将复杂的、耗时的或需要跨线程操作的任务从 JavaScript 移至更底层的 C/C++代码中处理，同时保证 JavaScript 侧的事件循环不会被阻塞。这样做的好处是可以极大地提升性能，特别是在 CPU 密集型或 IO 密集型的场景下。</p><h4 id="napi-callback-info" tabindex="-1"><a class="header-anchor" href="#napi-callback-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_callback_info" target="_blank" rel="noopener noreferrer">napi_callback_info</a></span></a></h4><p>Node.js 的 N-API 是一个用于构建原生插件的 API。原生插件是用 C 或 C++ 编写的模块，可以被 Node.js 直接调用。<code>napi_callback_info</code> 是 N-API 中的一个概念，它代表了一次从 JavaScript 到原生函数的调用的上下文信息。</p><p>当你在 JavaScript 中调用一个原生模块里的函数时，这个函数实际上是用 C 或 C++ 实现的。JavaScript 代码和原生代码之间需要一个“桥梁”来传递信息。这个“桥梁”就是由 <code>napi_callback_info</code> 提供的。</p><h3 id="示例理解-napi-callback-info" tabindex="-1"><a class="header-anchor" href="#示例理解-napi-callback-info"><span>示例理解 <code>napi_callback_info</code></span></a></h3><p>假设我们有一个简单的 Node.js 原生模块，它提供了一个函数 <code>sayHello</code>，当你从 JavaScript 调用这个函数时，它将返回 &quot;Hello, World!&quot; 字符串。</p><p>JavaScript 调用：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: Hello, World!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在原生模块中，使用 C 语言实现 <code>sayHello</code> 函数可能如下所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value SayHello(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value greeting;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个字符串 &#39;Hello, World!&#39; 返回给 JavaScript</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;Hello, World!&quot;, NAPI_AUTO_LENGTH, &amp;greeting);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return greeting;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册 `sayHello`</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value sayHelloFn;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, SayHello, NULL, &amp;sayHelloFn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;sayHello&quot;, sayHelloFn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>SayHello</code> 函数是我们要给 JavaScript 调用的原生函数。这个函数接受两个参数：<code>env</code> 和 <code>info</code>。</p><ul><li><code>env</code> 是一个表示当前执行环境的变量。</li><li><code>info</code> 就是我们讨论的 <code>napi_callback_info</code>。它包含了调用这个函数时所有重要的上下文信息，比如调用的参数、<code>this</code> 的值等等。</li></ul><p>在 <code>SayHello</code> 函数内部，我们不直接处理 JavaScript 传入的参数，而是通过 <code>napi_callback_info</code> 来获取这些信息。例如，如果我们想知道调用时传递了多少个参数，我们可以使用 <code>napi_get_cb_info</code> 函数（这是 N-API 提供的函数之一）来从 <code>info</code> 中获取这些信息。</p><p>实际应用中，<code>napi_callback_info</code> 更多地被用于获取参数、处理不同数量的参数、获取 <code>this</code> 对象引用等高级操作。但基本思路是将 JavaScript 中的调用信息映射到 C/C++ 的世界中，然后在原生代码层面处理这些信息。</p><p>总结起来，<code>napi_callback_info</code> 是原生模块中非常重要的一个组件，因为它使得 JavaScript 和 C/C++ 之间的交互成为可能，并且管理着这种交互过程中所有必要的上下文信息。</p><h4 id="napi-callback" tabindex="-1"><a class="header-anchor" href="#napi-callback"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_callback" target="_blank" rel="noopener noreferrer">napi_callback</a></span></a></h4><p>Node.js 中的 N-API 是一个为了构建原生插件（也就是用类似 C 或 C++这样的低级语言编写的模块）而设计的稳定的 API 层。它的目的是让你能够不受 Node.js 版本更迭的影响，编写能够在多个版本上运行的插件。</p><p><code>napi_callback</code> 是这个 N-API 的一部分，它是一个函数指针类型，你在创建原生插件时会使用这种类型的变量来引用你的 C 或 C++ 代码中的函数。当 JavaScript 代码调用这些原生函数时，底层的 Node.js 引擎会通过这个 <code>napi_callback</code> 指向的函数来执行相应的 C/C++ 代码。</p><p>通俗地说，<code>napi_callback</code> 就像是一个桥梁，连接了 JavaScript 的世界和 C/C++ 的世界。你可以把它想象成一个电话号码，JavaScript 代码通过这个号码“打电话”给 C/C++ 函数，然后那边的代码接听并处理请求，最终将结果返回给 JavaScript。</p><h3 id="实际运用例子-2" tabindex="-1"><a class="header-anchor" href="#实际运用例子-2"><span>实际运用例子：</span></a></h3><p>假设你想要在 Node.js 中使用某个 C 库中的功能，例如处理图像的库。这个库提供了一个函数叫做 <code>process_image</code>，你想通过 Node.js 调用这个函数。</p><p>首先，你需要在 C 代码中定义一个符合 <code>napi_callback</code> 类型签名的函数，我们可以叫它 <code>ProcessImageWrapper</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是那个图像处理库提供的函数</span></span>
<span class="line"><span>void process_image(const char* image_path);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是你定义的 napi_callback 对应的函数</span></span>
<span class="line"><span>napi_value ProcessImageWrapper(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 从 JavaScript 获取参数，调用 process_image 函数等逻辑</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回处理结果给 JavaScript</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，你需要注册这个函数到 Node.js 环境中，让 JavaScript 能够找到并调用它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数对象ProcessImageWrapper，暴露给JavaScript</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, ProcessImageWrapper, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置函数名称为 &#39;processImage&#39;，并把它作为导出的模块的属性</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;processImage&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，在 JavaScript 代码中，你可以这样调用这个函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设这里 &#39;./image.png&#39; 是你想要处理的图片路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">processImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./image.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Image processing failed:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Image processed successfully:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，JavaScript 代码通过 <code>napi_callback</code> 指定的 <code>ProcessImageWrapper</code> 函数调用了 C 代码，从而实现了与原生图像处理库的交互。这只是一个简化示例，实际的错误处理和数据转换会更复杂，但它展示了如何使用 <code>napi_callback</code> 在 Node.js 中创建和使用原生扩展的基本概念。</p><h4 id="node-api-nogc-finalize" tabindex="-1"><a class="header-anchor" href="#node-api-nogc-finalize"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_nogc_finalize" target="_blank" rel="noopener noreferrer">node_api_nogc_finalize</a></span></a></h4><p><code>node_api_nogc_finalize</code> 是 Node.js 中的一个 N-API 函数，它允许你设置一个对象在被垃圾回收（GC）之前不会调用其终结器（finalizer）。这个函数主要用于性能优化。</p><p>在 Node.js 中，N-API 提供了一套用于构建原生扩展的 C API。当使用 N-API 创建原生资源时（例如在 C/C++ 模块中分配内存），通常需要指定当 JavaScript 对象被垃圾回收时应该如何清理这些资源。这是通过为该对象设置一个终结器来实现的。</p><p>然而，在某些情况下，我们完全知道该资源将在某个特定时间点之前不需要被清理，或者希望手动管理资源的生命周期，以避免与垃圾回收器的潜在性能开销。在这种情况下，可以使用 <code>node_api_nogc_finalize</code> 函数来告诉 N-API 不要在垃圾回收时调用对象的终结器。</p><p>以下是一个使用 <code>node_api_nogc_finalize</code> 的简单例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是我们的一些原生资源</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  int some_resource;</span></span>
<span class="line"><span>} MyResource;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是正常的清理函数，如果设置了，通常会在对象被垃圾回收时调用</span></span>
<span class="line"><span>void Finalize(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>  MyResource* my_resource = (MyResource*)finalize_data;</span></span>
<span class="line"><span>  // 在这里释放资源</span></span>
<span class="line"><span>  free(my_resource);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数可以在适当的时候手动调用以清理资源</span></span>
<span class="line"><span>void ManualCleanup(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 获取之前关联到 JavaScript 对象的原生资源</span></span>
<span class="line"><span>  MyResource* my_resource;</span></span>
<span class="line"><span>  napi_get_instance_data(env, &amp;my_resource);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 清理资源</span></span>
<span class="line"><span>  free(my_resource);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 设置 instance data 为 NULL，避免重复清理</span></span>
<span class="line"><span>  napi_set_instance_data(env, NULL, NULL, NULL);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，创建和设置实例数据</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  MyResource* my_resource = malloc(sizeof(MyResource));</span></span>
<span class="line"><span>  my_resource-&gt;some_resource = 42; // 例子中的假资源</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将资源与 JavaScript 对象关联，并告诉 N-API 不要在垃圾回收时调用终结器</span></span>
<span class="line"><span>  napi_set_instance_data(env, my_resource, NULL /* 使用NULL代替Finalize */, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ... 这里可能会有更多代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>Init</code> 函数用于初始化一个原生模块，并且使用 <code>napi_set_instance_data</code> 来关联一个原生资源，但是我们传递了 <code>NULL</code> 而不是 <code>Finalize</code> 函数。这样，当垃圾回收器尝试清理相关的 JavaScript 对象时，它不会尝试调用终结器函数来清理 <code>MyResource</code>。因此，必须确保在合适的时候手动调用 <code>ManualCleanup</code> 函数来清理资源，否则就会发生内存泄漏。</p><p>请注意，以上代码仅为说明使用 <code>node_api_nogc_finalize</code> 的场景，并非一个可直接运行的例子。在实际项目中使用时，你需要根据你的具体需求和资源类型进行适当的修改。</p><h4 id="napi-finalize" tabindex="-1"><a class="header-anchor" href="#napi-finalize"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_finalize" target="_blank" rel="noopener noreferrer">napi_finalize</a></span></a></h4><p><code>napi_finalize</code> 是 Node.js 中 N-API（原生 API）的一部分。N-API 是 Node.js 提供给 C 和 C++ 插件开发者的一个稳定的 API 集合，它允许开发者编写可以与不同版本的 Node.js 兼容的本地插件。</p><p>在详细解释 <code>napi_finalize</code> 之前，需要知道几个背景信息：</p><ol><li><p><strong>垃圾回收(Garbage Collection，GC)</strong>：JavaScript 在运行过程中会创建和使用很多对象。当这些对象不再被需要时，JavaScript 的垃圾回收器会自动释放这些对象所占用的内存。但是，如果你在本地插件中创建了一些非 JavaScript 资源（比如在 C/C++ 中分配的内存、打开的文件描述符或者其他系统资源），JavaScript 的垃圾回收器并不知道如何处理这些资源。</p></li><li><p><strong>引用计数(Reference Counting)</strong>：这是一种确保资源正确管理的技术。每当你创建一个对象，并把它赋值给某个变量，这个对象的引用计数就会增加。相反，当这个对象的引用减少到零时，意味着没有任何变量是指向这个对象的，这时候资源就可以被清理了。</p></li></ol><p>现在，让我们深入了解 <code>napi_finalize</code>：</p><p><code>napi_finalize</code> 是一个回调函数，你作为插件开发者在创建一个能够通过 JavaScript 访问的本地资源时提供给 N-API 的。这个回调函数的目的是在相关 JavaScript 对象被垃圾回收器回收时，你可以有机会去清理那些由本地代码创建的非 JavaScript 资源。</p><p>当你通过 N-API 函数 <code>napi_wrap</code> 将一个本地资源与一个新的或现有的 JavaScript 对象关联时，你可以指定一个 <code>napi_finalize</code> 回调函数。这样，当这个 JavaScript 对象被垃圾回收时，<code>napi_finalize</code> 所指定的函数就会被调用，这时你可以在这个函数内部执行必要的清理工作。</p><p>举个例子来说：</p><p>假设你正在编写一个 Node.js 本地插件来读取操作系统的系统信息。你可能会在 C++ 中创建一个类 <code>SystemInfo</code> 来处理与系统交互的具体细节，并且想要在 JavaScript 中也能够使用这个类。在这种情况下，你会：</p><ol><li>使用 <code>napi_create_object</code> 创建一个新的 JS 对象。</li><li>使用 <code>napi_wrap</code> 将这个 JS 对象与一个 <code>SystemInfo</code> 类的实例关联起来。</li><li>当 JS 对象即将被垃圾回收时，你需要清理 <code>SystemInfo</code> 实例所占用的资源，比如关闭文件句柄等。这就是你需要提供一个 <code>napi_finalize</code> 回调函数的地方。</li></ol><p>示例代码片段：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的系统信息类</span></span>
<span class="line"><span>class SystemInfo {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    SystemInfo() {</span></span>
<span class="line"><span>        // 初始化代码</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ~SystemInfo() {</span></span>
<span class="line"><span>        // 清理代码，例如关闭文件句柄等</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他方法...</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是 napi_finalize 回调函数</span></span>
<span class="line"><span>void FinalizeSystemInfo(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    // 在这里释放 SystemInfo 实例</span></span>
<span class="line"><span>    SystemInfo* sys_info = reinterpret_cast`&lt;`SystemInfo*&gt;(finalize_data);</span></span>
<span class="line"><span>    delete sys_info;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是 N-API 暴露给 JS 的方法，用于创建 SystemInfo 对象</span></span>
<span class="line"><span>napi_value CreateSystemInfoWrapper(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value sys_info_obj;</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;sys_info_obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    SystemInfo* sys_info = new SystemInfo(); // 创建 SystemInfo 实例</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 把 SystemInfo 实例和 JS 对象关联起来，并指定 FinalizeSystemInfo 作为清理回调</span></span>
<span class="line"><span>    status = napi_wrap(env, sys_info_obj, sys_info, FinalizeSystemInfo, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return sys_info_obj; // 返回新创建的 JS 对象</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个 <code>FinalizeSystemInfo</code> 函数作为 <code>napi_finalize</code> 回调，当相关联的 JavaScript 对象即将被 GC 清理时，该函数会被调用以释放 <code>SystemInfo</code> 实例。这样我们就确保了，无论何时 JavaScript 对象被回收，其对应的本地资源都能够得到适当的处理，避免了内存泄露。</p><h4 id="napi-async-execute-callback" tabindex="-1"><a class="header-anchor" href="#napi-async-execute-callback"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_execute_callback" target="_blank" rel="noopener noreferrer">napi_async_execute_callback</a></span></a></h4><p>Node.js 的 N-API（原生 API）是一个让你能够用 C 或者 C++ 编写扩张模块的界面。当你想要提高性能，或者使用一些 Node.js 中没有直接提供的本地库时，你可能会用到它。</p><p><code>napi_async_execute_callback</code> 是 N-API 中的一个函数，它允许你在创建异步任务时定义要执行的逻辑。当你调用这个函数，Node.js 会在后台线程上执行定义的回调函数，而不会阻塞主事件循环。这对于不希望影响到主线程性能的密集型计算任务非常有用。</p><p>为了理解 <code>napi_async_execute_callback</code>，我们需要先明白几个概念：</p><ul><li><strong>异步编程</strong>：在 Node.js 中，异步编程指的是程序在等待某个操作完成时可以继续执行其他代码，比如读取文件、数据库操作或者网络请求。</li><li><strong>事件循环</strong>：Node.js 使用事件循环来处理异步操作。当所有同步代码执行完毕后，它会检查是否有异步任务完成并准备好回调函数执行。</li><li><strong>多线程</strong>：虽然 JavaScript 在 Node.js 中默认是单线程运行的，但 Node.js 可以利用 C++ 扩展或者工作线程（worker threads）在后台执行多线程任务。</li></ul><p>现在，让我们举个例子来描述 <code>napi_async_execute_callback</code> 是如何工作的：</p><p>假设你有一个耗时的图像处理任务，在 Node.js 中你想通过一个扩展模块来实现，以避免阻塞主事件循环。首先，你会用 C++ 来写这个图像处理逻辑，然后需要向 Node.js 注册这个任务，告诉它这是一个异步任务。</p><ol><li>你会创建一个 <code>napi_async_work</code> 对象，它代表了一个将要被异步执行的任务。</li><li>你会定义一个 <code>Execute</code> 回调，这个回调包含了真正的处理逻辑，即图像处理算法。</li><li>你将这个 <code>Execute</code> 回调与 <code>napi_async_work</code> 对象关联，并通过调用 <code>napi_async_execute_callback</code> 来在一个后台线程上执行它。</li></ol><p>这个过程允许 Node.js 在处理该任务的同时，继续处理其他事件循环中的事项，如处理 HTTP 请求或者用户的输入。</p><p>以下是一个抽象的伪代码示例，展示了如何使用 <code>napi_async_execute_callback</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数是耗时任务的实际逻辑</span></span>
<span class="line"><span>void Execute(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 执行一些耗时的操作，例如图像处理</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数会在耗时任务完成后被调用，通常用来返回结果给JavaScript</span></span>
<span class="line"><span>void Complete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 处理完成后，返回结果给 JavaScript 环境</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数是用来启动整个异步任务的</span></span>
<span class="line"><span>napi_value StartAsyncWork(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value work_name;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;WorkName&quot;, NAPI_AUTO_LENGTH, &amp;work_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建 async work</span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, work_name, Execute, Complete, NULL, &amp;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个 work 排入队列，使其开始在后台线程上执行</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码是非常简化的示例，仅用于说明 <code>napi_async_execute_callback</code> 的基本概念。在实际应用中，你还需要管理内存，处理错误，并确保跨语言边界（C++ 到 JavaScript）时数据正确传递。</p><h4 id="napi-async-complete-callback" tabindex="-1"><a class="header-anchor" href="#napi-async-complete-callback"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_complete_callback" target="_blank" rel="noopener noreferrer">napi_async_complete_callback</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，让你可以在服务器端执行 JavaScript 代码。N-API 是 Node.js 提供的一套 C API，使得原生插件（native addons）能够不受 Node.js 版本影响地编译和运行。</p><p>在 Node.js 的 N-API 中，<code>napi_async_complete_callback</code> 是一个类型定义，它是用于异步操作的回调函数的签名。这个回调函数在一个异步操作完成时被调用。</p><p>为了理解 <code>napi_async_complete_callback</code>，需要先明白几个概念：</p><ol><li><strong>原生插件</strong>：这些插件是使用 C 或 C++ 编写的，通过 N-API 可以与 Node.js 交互。</li><li><strong>异步操作</strong>：在 Node.js 中，很多操作都是异步进行的，即它们会在后台执行，并在完成时通知 Node.js 主线程。</li><li><strong>回调函数</strong>：当异步操作完成时，用来接收结果或者错误信息的函数。</li></ol><p>现在，让我们具体看一下 <code>napi_async_complete_callback</code>。这个回调函数定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>typedef void (*napi_async_complete_callback)(napi_env env,</span></span>
<span class="line"><span>                                              napi_status status,</span></span>
<span class="line"><span>                                              void* data);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>napi_env env</code>: 这个参数是一个表示 N-API 环境的句柄，它提供了大量的 API 函数使得你能在原生插件中操作 JavaScript 代码、对象等。</li><li><code>napi_status status</code>: 这个参数表示异步操作的完成状态，它可以告诉你操作是否成功，或者发生了哪种类型的错误。</li><li><code>void* data</code>: 这是一个指向任意数据的指针，你可以在开始异步操作时传递一个指向你的数据的指针，在回调函数被调用时再从这个指针获取数据。</li></ul><p>假设你正在编写一个原生插件，其中有一个需要执行长时间计算的异步操作。下面是一个使用 <code>napi_async_complete_callback</code> 的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设这个函数是一个长时间运行的异步操作</span></span>
<span class="line"><span>void long_running_operation(void* data) {</span></span>
<span class="line"><span>    // 执行一些长时间的操作...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是当上述长时间运行的操作完成后会被调用的回调函数</span></span>
<span class="line"><span>void operation_completed(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 根据 status 参数检查操作是否成功完成</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 如果成功，处理结果</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果失败，处理错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在你的插件中启动异步操作，并提供上面的回调</span></span>
<span class="line"><span>void start_async_work() {</span></span>
<span class="line"><span>    // 初始化一些数据</span></span>
<span class="line"><span>    void* data = ...;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 启动异步操作</span></span>
<span class="line"><span>    long_running_operation(data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置当操作完成时要调用的回调函数</span></span>
<span class="line"><span>    napi_async_complete_callback callback = operation_completed;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 更多的代码来安排回调函数在合适的时机被调用...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：实际上你不能直接这样简单地调用 <code>long_running_operation</code> 和 <code>operation_completed</code>，因为这将同步执行并不是异步。在 Node.js 的 N-API 中，你必须使用正确的模式比如 <code>napi_create_async_work</code> 和 <code>napi_queue_async_work</code> 来安排异步工作和相应的完成回调。以上代码只是为了演示 <code>napi_async_complete_callback</code> 的概念而已。</p><p>总结一下，<code>napi_async_complete_callback</code> 是定义异步操作完成时调用的回调函数类型，它允许原生插件开发者处理异步操作的结果或错误。</p><h4 id="napi-threadsafe-function-call-js" tabindex="-1"><a class="header-anchor" href="#napi-threadsafe-function-call-js"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_threadsafe_function_call_js" target="_blank" rel="noopener noreferrer">napi_threadsafe_function_call_js</a></span></a></h4><p>Node.js 中的 <code>napi_threadsafe_function_call_js</code> 是一个用于多线程编程的高级 API 函数，它允许你在任何线程中安全地调用 JavaScript 函数。这很重要，因为通常在 Node.js 中，只能在主线程（也就是事件循环运行的线程）中直接执行 JavaScript。</p><p><code>napi_threadsafe_function_call_js</code> 属于 N-API，这是 Node.js 提供的一组 C 语言 API。通过 N-API，原生插件可以不受 Node.js 版本更进建立和维护，同时保持对前后版本的兼容性。</p><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h3><p>在多线程程序中，当你想从一个非主线程（例如，一个由 C++库创建的线程）调用 JavaScript 函数时，如果直接进行这样的调用，很可能会导致竞争条件、内存泄露或程序崩溃等问题，因为 V8 引擎（Node.js 的 JavaScript 引擎）并不是线程安全的。</p><p>为了解决这个问题，<code>napi_create_threadsafe_function()</code> 函数被用来创建一个所谓的“线程安全函数”。然后，你可以从任何线程使用 <code>napi_threadsafe_function_call_js</code> 来调用这个 JavaScript 函数，而不用担心上述那些问题。</p><h3 id="使用例子" tabindex="-1"><a class="header-anchor" href="#使用例子"><span>使用例子</span></a></h3><p>假设我们有一个耗时的运算任务，我们想要在一个 C++的辅助线程中执行它，但在任务完成后我们需要回到 Node.js 的主线程来处理结果。</p><p>首先，我们需要创建一个线程安全函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是将被辅助线程调用的JavaScript函数</span></span>
<span class="line"><span>void js_callback(napi_env env, napi_value js_callback, void* context, void* data) {</span></span>
<span class="line"><span>    // 在这里构造你的回调逻辑</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用napi_create_threadsafe_function创建一个线程安全函数</span></span>
<span class="line"><span>napi_value resource_id;</span></span>
<span class="line"><span>napi_create_string_utf8(env, &quot;MyResource&quot;, NAPI_AUTO_LENGTH, &amp;resource_id);</span></span>
<span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span>napi_create_threadsafe_function(env,</span></span>
<span class="line"><span>                                js_func,      // 传入的JS函数</span></span>
<span class="line"><span>                                NULL,         // async_resource</span></span>
<span class="line"><span>                                resource_id,  // async_resource_name</span></span>
<span class="line"><span>                                0,            // max_queue_size</span></span>
<span class="line"><span>                                1,            // initial_thread_count</span></span>
<span class="line"><span>                                NULL,         // context</span></span>
<span class="line"><span>                                NULL,         // finalize_cb</span></span>
<span class="line"><span>                                NULL,         // finalize_hint</span></span>
<span class="line"><span>                                js_callback,  // native回调</span></span>
<span class="line"><span>                                &amp;tsfn);</span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在一个辅助线程中，当我们想要调用 JavaScript 函数时：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void some_async_work(void* data) {</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    // 执行某些异步操作</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当准备好调用JavaScript时：</span></span>
<span class="line"><span>    napi_call_threadsafe_function(tsfn, data, napi_tsfn_blocking); // data 是将传递给 `js_callback` 的参数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建新线程并开始异步工作</span></span>
<span class="line"><span>pthread_t thread_id;</span></span>
<span class="line"><span>pthread_create(&amp;thread_id, NULL, some_async_work, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，当我们不再需要线程安全函数时，释放它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_release_threadsafe_function(tsfn, napi_tsfn_release);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的代码示例说明了如何设置一个线程安全函数并在辅助线程中调用它。这里没有展示完整的代码，因为实际的实现需要考虑 Node.js 模块的初始化、错误处理等多个方面。但基本思路就是创建一个可以在线程之间共享并安全调用的 JavaScript 函数，并且确保当你完成使用时正确地清理资源。</p><h4 id="napi-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_cleanup_hook</a></span></a></h4><p>Node.js 的 N-API 是一个用于构建原生插件的接口。原生插件是使用 C, C++等编程语言编写的模块，可以被 Node.js 直接调用，通常用于性能关键型任务或者调用操作系统级别功能。</p><p><code>napi_cleanup_hook</code> 是 N-API 中的一个功能，它允许原生插件在 Node.js 的环境被清理前执行一些特定的代码。换句话说，当你的 Node.js 应用程序准备关闭时（例如调用了<code>process.exit()</code>或者正常结束），这个钩子函数就会被触发。</p><p>这很有用，因为它为原生模块提供了一种在垃圾收集器销毁之前自动释放资源的机制。如果你创建了一些需要手动清理的资源（比如动态分配的内存、文件描述符、线程等），那么使用<code>napi_cleanup_hook</code>就非常重要了。</p><p>例子 1：假设您编写了一个原生模块，该模块打开一个日志文件，并且希望在 Node.js 退出时关闭该文件以防止数据损坏。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void cleanup_file(void* arg) {</span></span>
<span class="line"><span>    FILE* file = (FILE*)arg;</span></span>
<span class="line"><span>    fclose(file);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...在某处注册清理钩子</span></span>
<span class="line"><span>FILE* log_file = fopen(&quot;log.txt&quot;, &quot;a&quot;);</span></span>
<span class="line"><span>napi_add_cleanup_hook(env, cleanup_file, log_file);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先定义了一个名为<code>cleanup_file</code>的函数来关闭文件。然后，我们打开日志文件，并用<code>napi_add_cleanup_hook</code>注册了这个函数作为清理钩子，并将文件指针作为参数传递给它。</p><p>例子 2：假设你的原生模块启动了一个后台线程来执行一些长时间运行的计算，并且需要在应用程序退出时安全地停止该线程。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void cleanup_thread(void* arg) {</span></span>
<span class="line"><span>    my_thread_data* data = (my_thread_data*)arg;</span></span>
<span class="line"><span>    // 设置一个标志或发送信号来告诉线程停止运行</span></span>
<span class="line"><span>    stop_thread(data-&gt;thread_id);</span></span>
<span class="line"><span>    // 等待线程实际结束</span></span>
<span class="line"><span>    join_thread(data-&gt;thread_id);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...在某处注册清理钩子</span></span>
<span class="line"><span>my_thread_data* thread_data = start_background_thread();</span></span>
<span class="line"><span>napi_add_cleanup_hook(env, cleanup_thread, thread_data);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，假设我们有一个函数<code>start_background_thread</code>来启动后台线程，并返回一个包含线程信息的结构体。我们定义了一个<code>cleanup_thread</code>函数来处理线程的停止过程，并通过<code>napi_add_cleanup_hook</code>注册了它作为一个清理钩子。</p><p>总结：<code>napi_cleanup_hook</code>是一个强大的工具，它确保了即使 Node.js 应用程序正在退出，原生模块也能够有序地清理自己的资源，避免内存泄漏和其他潜在问题。记住，这是高级功能，并且主要用于那些创建复杂原生扩展的开发者。</p><h4 id="napi-async-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-async-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_async_cleanup_hook</a></span></a></h4><p>Node.js 中的 <code>napi_async_cleanup_hook</code> 是一个功能，它允许你在 Node.js 的异步环境中注册清理钩子（cleanup hooks）。这是为了确保当一个异步资源，比如定时器、文件流等，不再需要时能够适当地执行清理工作。</p><p>在 Node.js 应用程序中，有时你会创建一些长期运行的异步操作。例如，可能会启动一个定时器来周期性地执行任务，或者打开一个文件流进行读写。当这些异步操作结束或不再需要时，与它们相关联的资源必须被正确地释放，以避免内存泄漏和其他潜在问题。</p><p><code>napi_async_cleanup_hook</code> 函数就是为了解决这个问题而设计的。通过使用这个函数，你可以注册一个回调函数，当 Node.js 进程准备退出时，这个回调函数将被调用，使得你有机会去清理那些仍然挂起的异步资源。</p><p>举个例子来说：</p><ol><li><strong>创建定时器示例</strong>：<br> 假设你在 Node.js 应用程序中设置了一个间隔定时器（interval timer），每隔一段时间执行某项任务。在某些情况下，如果你的应用程序需要优雅地关闭，你可能需要清除这个定时器。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">createHook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">asyncResource</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;async_hooks&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假定存在一个定时器变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> intervalTimer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> initIntervalTimer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 设置定时器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  intervalTimer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;定时器运行中...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 使用 napi_async_cleanup_hook 注册清理钩子</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  createHook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    init</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">asyncId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">triggerAsyncId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">resource</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // 当 Node.js 退出时调用的清理函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">type</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;TIMERWRAP&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">        napi_async_cleanup_hook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">          clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">intervalTimer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">          console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;定时器已清除&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">enable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">initIntervalTimer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 在某个时间点之后停止应用程序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  process</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">exit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 触发清理钩子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先定义了一个初始化定时器的函数 <code>initIntervalTimer()</code>，它会创建一个定时器，并注册一个 <code>napi_async_cleanup_hook</code> 来清理这个定时器。当 <code>process.exit(0)</code> 被调用时，它会触发清理钩子，从而清除定时器并输出日志表示定时器已被清除。</p><ol start="2"><li><strong>文件流清理示例</strong>：<br> 如果你打开了一个文件流用于读取或写入数据，可能也希望在应用程序退出之前关闭这个流。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">createReadStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">createHook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">asyncResource</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;async_hooks&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打开一个文件流</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> createReadStream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;path/to/file.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createHook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  init</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">asyncId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">triggerAsyncId</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">resource</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">type</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;FSREQCALLBACK&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      // 当 Node.js 退出时调用的清理函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">      napi_async_cleanup_hook</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">        stream</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">          console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;文件流已关闭&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">enable</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 在某个时间点之后停止应用程序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  process</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">exit</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 触发清理钩子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中的代码类似，我们打开一个文件流并使用 <code>napi_async_cleanup_hook</code> 来注册一个清理钩子，它将在应用程序退出前关闭这个文件流。</p><p>重要的是要注意，<code>napi_async_cleanup_hook</code> 是 N-API 的一部分，N-API 是一个 C API，可用于构建原生插件。在 JavaScript 层面，我们通常使用 Node.js 提供的高级抽象如 <code>async_hooks</code> 模块来处理异步资源的生命周期。</p><p>上述例子中简化了许多底层的细节，并没有直接使用 <code>napi_async_cleanup_hook</code>，因为在纯 JavaScript 环境中不直接使用 N-API 函数。不过，对于编写本地插件（native addon）的开发人员来说，了解如何通过 N-API 使用这些钩子是很重要的。</p><h2 id="error-handling" tabindex="-1"><a class="header-anchor" href="#error-handling"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#error-handling" target="_blank" rel="noopener noreferrer">Error handling</a></span></a></h2><p>Node.js 中的 N-API 是一个用于构建原生插件的 API 层，它允许你使用 C 或 C++ 代码与 JavaScript 运行时交互，并在不同版本的 Node.js 之间提供二进制兼容性。错误处理是编程中非常重要的一个环节，因为它可以帮助你理解程序运行时可能遇到的问题并妥善地对这些问题进行处理。</p><p>在 Node.js 的 N-API 中，错误处理通常涉及以下几个方面：</p><ol><li><p><strong>N-API 函数返回值</strong>：当你调用一个 N-API 函数时，它通常会返回一个称为 <code>napi_status</code> 的枚举值。这个返回值表示函数调用是否成功。如果函数执行成功，它通常返回 <code>napi_ok</code>。如果发生错误，它将返回一个不同的枚举值，来描述发生了什么类型的错误。</p><p>例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 尝试调用 N-API 函数并检查其返回状态</span></span>
<span class="line"><span>status = napi_do_something(env, &amp;result);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 错误处理逻辑</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>错误信息</strong>：当 N-API 返回一个错误状态时，你可以使用一些特定的 N-API 函数来获取更多关于错误的信息。例如，你可以获取错误消息或触发错误的引擎异常。</p><p>例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>const napi_extended_error_info* error_info;</span></span>
<span class="line"><span>status = napi_get_last_error_info(env, &amp;error_info);</span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  const char* error_message = error_info-&gt;error_message;</span></span>
<span class="line"><span>  // 使用错误信息进行处理</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>异常处理</strong>：JavaScript 中的异常可以通过 N-API 捕获和抛出。如果有一个 JavaScript 异常被抛出，你可以使用 <code>napi_is_exception_pending</code> 函数来检查，并使用 <code>napi_get_and_clear_last_exception</code> 来获取异常对象。</p><p>例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value exception;</span></span>
<span class="line"><span>bool has_exception;</span></span>
<span class="line"><span>status = napi_is_exception_pending(env, &amp;has_exception);</span></span>
<span class="line"><span>if (status == napi_ok &amp;&amp; has_exception) {</span></span>
<span class="line"><span>  status = napi_get_and_clear_last_exception(env, &amp;exception);</span></span>
<span class="line"><span>  // 现在你可以处理异常了</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>创建和抛出错误</strong>：如果你需要从你的原生模块中抛出一个错误，你可以使用如 <code>napi_throw_error</code>、<code>napi_throw_type_error</code> 或 <code>napi_throw_range_error</code> 等函数来创建并抛出错误。</p><p>例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>status = napi_throw_error(env, NULL, &quot;An error occurred&quot;);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 抛出错误失败的处理逻辑</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>实际应用例子：</p><p>假设你正在编写一个原生插件，该插件需要完成一个数学计算，并且只接受正整数作为输入。你可以使用 N-API 的错误处理功能来确保输入有效，并在出现错误时通知 JavaScript。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status sum_positive_integers(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 2;</span></span>
<span class="line"><span>  napi_value args[2];</span></span>
<span class="line"><span>  napi_value this_arg;</span></span>
<span class="line"><span>  int64_t number1, number2;</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取参数</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok || argc `&lt;` 2) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Function requires 2 arguments.&quot;);</span></span>
<span class="line"><span>    return status;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 确保参数是数字并且是正整数</span></span>
<span class="line"><span>  status = napi_get_value_int64(env, args[0], &amp;number1);</span></span>
<span class="line"><span>  if (status != napi_ok || number1 `&lt;` 0) {</span></span>
<span class="line"><span>    napi_throw_type_error(env, NULL, &quot;First argument must be a positive integer.&quot;);</span></span>
<span class="line"><span>    return status;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  status = napi_get_value_int64(env, args[1], &amp;number2);</span></span>
<span class="line"><span>  if (status != napi_ok || number2 `&lt;` 0) {</span></span>
<span class="line"><span>    napi_throw_type_error(env, NULL, &quot;Second argument must be a positive integer.&quot;);</span></span>
<span class="line"><span>    return status;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 计算和</span></span>
<span class="line"><span>  int64_t sum = number1 + number2;</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  status = napi_create_int64(env, sum, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;An error occurred while creating return value.&quot;);</span></span>
<span class="line"><span>    return status;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回结果</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述例子中，我们检查了函数是否收到了正确数量的参数，验证了这些参数是否符合预期（正整数），如果检测到任何错误，我们就使用 N-API 的错误抛出函数来返回一个适当的错误给 JavaScript 环境。这样，JavaScript 调用者就可以捕获这些错误并据此采取相应的措施。</p><h3 id="return-values" tabindex="-1"><a class="header-anchor" href="#return-values"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#return-values" target="_blank" rel="noopener noreferrer">Return values</a></span></a></h3><p>Node.js 中的 N-API（原生 API）允许 JavaScript 代码和 C/C++原生插件之间进行交互。当你使用 N-API 编写原生扩展时，你会经常需要处理函数返回值。在这个上下文中，“返回值”特指从一个 N-API 调用返回到 JavaScript 的值。</p><p>在 Node.js v21.7.1 的文档中，关于返回值的说明主要是告诉开发者如何正确地从 N-API 函数返回结果给 JavaScript 代码。大多数 N-API 函数会返回类型为 <code>napi_status</code> 的值。这个值表示函数执行是否成功，或者发生了什么样的错误。</p><p>这里有一些可能的返回值：</p><ul><li><code>napi_ok</code>: 表示没有错误发生，函数调用成功。</li><li><code>napi_invalid_arg</code>: 表示提供了无效参数。</li><li><code>napi_object_expected</code>: 表示预期一个对象但没有得到。</li><li><code>napi_string_expected</code>: 表示预期一个字符串但没有得到。</li><li>...以及其他更多的状态码。</li></ul><p>现在来看几个实际的例子：</p><h3 id="示例-1-创建一个新的-javascript-字符串" tabindex="-1"><a class="header-anchor" href="#示例-1-创建一个新的-javascript-字符串"><span>示例 1：创建一个新的 JavaScript 字符串</span></a></h3><p>假设我们正在编写一个将 C 语言的字符串复制到 JavaScript 字符串的 N-API 函数。函数首先检查参数有效，然后执行操作，并返回状态。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是我们的本地扩展函数</span></span>
<span class="line"><span>napi_status CreateNewString(napi_env env, napi_value* result) {</span></span>
<span class="line"><span>    // 创建一个C字符串</span></span>
<span class="line"><span>    const char* str = &quot;Hello from native code!&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用N-API创建一个新的JS字符串</span></span>
<span class="line"><span>    return napi_create_string_utf8(env, str, NAPI_AUTO_LENGTH, result);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数作为模块导出</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value new_str;</span></span>
<span class="line"><span>  napi_status status = CreateNewString(env, &amp;new_str);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return new_str;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>CreateNewString</code>函数创建了一个新的 JavaScript 字符串，并通过<code>result</code>参数返回它。如果操作成功，<code>napi_create_string_utf8</code>会返回<code>napi_ok</code>。</p><h3 id="示例-2-从函数中返回数值" tabindex="-1"><a class="header-anchor" href="#示例-2-从函数中返回数值"><span>示例 2：从函数中返回数值</span></a></h3><p>另一个常见用例是从原生函数返回一个数字给 JavaScript。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是我们的本地扩展函数</span></span>
<span class="line"><span>napi_status CalculateSum(napi_env env, int a, int b, napi_value* result) {</span></span>
<span class="line"><span>    int sum = a + b;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将计算结果转换为JavaScript数字</span></span>
<span class="line"><span>    return napi_create_int32(env, sum, result);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数作为模块导出</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value sum_result;</span></span>
<span class="line"><span>  napi_status status = CalculateSum(env, 3, 5, &amp;sum_result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return sum_result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>CalculateSum</code>接收两个整数，计算它们的和，并通过<code>result</code>返回这个和的 JavaScript 数值。如果成功，<code>napi_create_int32</code>会返回<code>napi_ok</code>。</p><p>注意，在这些示例中，我们没有展示错误处理的完整代码。在实际的 N-API 模块中，你需要检查每个 N-API 调用的返回状态，并适当地处理错误情况，例如释放资源、打印错误信息、或者返回一个错误对象到 JavaScript。</p><p>总结就是，Node.js 文档中关于 N-API 的“返回值”部分主要强调了从 N-API 函数返回状态码的重要性。这些状态码对于调试和确保 N-API 函数正确地与 JavaScript 交互至关重要。</p><h4 id="napi-get-last-error-info" tabindex="-1"><a class="header-anchor" href="#napi-get-last-error-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_last_error_info" target="_blank" rel="noopener noreferrer">napi_get_last_error_info</a></span></a></h4><p>当您在使用 Node.js 进行编程，特别是当您在使用 N-API（Node.js 的一个用于构建原生插件的 API）时，您可能会遇到错误和问题。这时候，<code>napi_get_last_error_info</code> 就派上了用场。</p><p><code>napi_get_last_error_info</code> 是一个函数，它能够帮助您获得关于最后一个发生的 N-API 调用错误的信息。每当 N-API 函数失败时，Node.js 都会存储有关错误的详细信息，包括错误代码、错误消息等。</p><p>让我们看一下如何使用 <code>napi_get_last_error_info</code> 和它有什么作用：</p><h3 id="使用-napi-get-last-error-info-的步骤" tabindex="-1"><a class="header-anchor" href="#使用-napi-get-last-error-info-的步骤"><span>使用 <code>napi_get_last_error_info</code> 的步骤：</span></a></h3><ol><li>当您调用一个 N-API 函数且它返回一个表示失败的结果时（通常是一个错误码）。</li><li>然后您可以立即调用 <code>napi_get_last_error_info</code> 来获取错误详情。</li><li>此函数将填充一个你提供的 <code>napi_extended_error_info</code> 结构体，其中包含了错误信息。</li></ol><h3 id="napi-get-last-error-info-的实际例子" tabindex="-1"><a class="header-anchor" href="#napi-get-last-error-info-的实际例子"><span><code>napi_get_last_error_info</code> 的实际例子：</span></a></h3><p>假设您正在编写一个 Node.js 原生插件，该插件需要从 Node.js 接收一些数据。您可能会调用一个 N-API 函数来读取这个数据，比如 <code>napi_get_value_string_utf8</code>。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们已经有了一个 napi_value 变量 `value` 代表JS传过来的字符串</span></span>
<span class="line"><span>napi_status status;</span></span>
<span class="line"><span>size_t result;</span></span>
<span class="line"><span>char* buffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 尝试获取字符串长度</span></span>
<span class="line"><span>status = napi_get_value_string_utf8(env, value, NULL, 0, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 判断是否成功执行</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 如果失败，则获取错误信息</span></span>
<span class="line"><span>  const napi_extended_error_info* error_info;</span></span>
<span class="line"><span>  napi_get_last_error_info(env, &amp;error_info);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 输出错误信息</span></span>
<span class="line"><span>  printf(&quot;Error code: %d\n&quot;, error_info-&gt;error_code);</span></span>
<span class="line"><span>  printf(&quot;Error message: %s\n&quot;, error_info-&gt;error_message);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中：</p><ul><li>我们首先尝试通过调用 <code>napi_get_value_string_utf8</code> 来获取字符串长度。</li><li>如果状态码 <code>status</code> 不是 <code>napi_ok</code>，意味着函数调用失败。</li><li>接着我们调用 <code>napi_get_last_error_info</code> 获取更多关于错误的信息。</li><li>我们使用 <code>napi_extended_error_info</code> 结构体来获取错误代码和消息。</li><li>最后打印出错误信息。</li></ul><p>通过这种方式，使用 <code>napi_get_last_error_info</code> 可以帮助开发者诊断 N-API 函数调用失败的原因，并根据错误信息来修复问题。</p><p>记住，这是在编写 C 或 C++扩展时使用的函数。在 JavaScript 代码中，您通常不会直接与这些底层 API 打交道。这是为那些想要扩展 Node.js 能力，通过编写接近硬件层面代码的高级用户准备的。</p><h3 id="exceptions" tabindex="-1"><a class="header-anchor" href="#exceptions"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#exceptions" target="_blank" rel="noopener noreferrer">Exceptions</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建本地插件的接口。它允许你使用 C 或者 C++ 代码与 Node.js 进行交互，这样可以在性能要求较高的场景中运用更高效的代码。在 v21.7.1 版本的文档中，“Exceptions”指的是在你的本地插件代码中如何处理和抛出错误。</p><p>异常（Exceptions）是一种在程序执行过程中遇到不正常情况时通知运行环境的机制。在 JavaScript 中，通常会使用 <code>throw</code> 关键字来抛出一个异常，并且可以用 <code>try...catch</code> 结构来捕获并处理这些异常。</p><p>当你在编写使用 N-API 的本地插件时，你也需要正确处理可能发生的异常，这包括两个方面：</p><ol><li>将 C/C++ 中的错误转换为 JavaScript 异常。</li><li>捕获 JavaScript 异常并在本地代码中进行处理。</li></ol><p>下面是几个关于在 Node.js N-API 中如何处理异常的例子：</p><h3 id="抛出一个异常" tabindex="-1"><a class="header-anchor" href="#抛出一个异常"><span>抛出一个异常</span></a></h3><p>假设你有一个本地函数，你想在某种错误条件下将其转换为 JavaScript 异常。</p><p>C++ 代码示例:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 假设发生了某种错误</span></span>
<span class="line"><span>    bool has_error = true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (has_error) {</span></span>
<span class="line"><span>        // 创建一个 JavaScript 错误对象</span></span>
<span class="line"><span>        napi_value error;</span></span>
<span class="line"><span>        napi_create_error(env, nullptr, napi_value(&quot;发生错误&quot;), &amp;error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 抛出这个错误对象</span></span>
<span class="line"><span>        napi_throw(env, error);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回未定义（如果没有错误）</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="捕获并处理异常" tabindex="-1"><a class="header-anchor" href="#捕获并处理异常"><span>捕获并处理异常</span></a></h3><p>现在假设你调用了一个可能会抛出异常的 JavaScript 函数，并且你想在你的本地代码中捕获并处理这个异常。</p><p>C++ 代码示例:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CallJavaScriptFunction(napi_env env) {</span></span>
<span class="line"><span>    // 获取全局对象</span></span>
<span class="line"><span>    napi_value global;</span></span>
<span class="line"><span>    napi_get_global(env, &amp;global);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取你想调用的 JavaScript 函数（比如 &#39;someFunction&#39;）</span></span>
<span class="line"><span>    napi_value js_function;</span></span>
<span class="line"><span>    napi_get_named_property(env, global, &quot;someFunction&quot;, &amp;js_function);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用这个函数</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_status status = napi_call_function(env, global, js_function, 0, nullptr, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否在调用期间抛出了异常</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 从环境中获取异常</span></span>
<span class="line"><span>        napi_value exception;</span></span>
<span class="line"><span>        napi_get_and_clear_last_exception(env, &amp;exception);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 处理这个异常，或者重新抛出</span></span>
<span class="line"><span>        // (例如打印错误信息)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的第二个例子中，我们尝试调用一个 JavaScript 函数，如果抛出异常，我们会通过 <code>napi_get_and_clear_last_exception</code> 捕获它，并决定如何处理。</p><p>总而言之，在 Node.js N-API 中处理异常涉及创建 JavaScript 错误对象、抛出它们以及在本地代码中捕获和处理 JavaScript 抛出的异常。正确地处理异常对于编写稳定且可靠的原生插件至关重要。</p><h4 id="napi-throw" tabindex="-1"><a class="header-anchor" href="#napi-throw"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_throw" target="_blank" rel="noopener noreferrer">napi_throw</a></span></a></h4><p>Node.js 中的<code>napi_throw</code>是 Node.js 提供的一个 API，它属于 N-API（原生 API），这是一个用 C 或 C++编写原生插件的接口。<code>napi_throw</code>的作用是在原生代码中抛出一个 JavaScript 错误。</p><p>当你使用 Node.js 进行开发时，大部分时间你可能都是在用 JavaScript 编写代码。然而，有时候你可能需要调用一些底层系统级别的功能，或者想要提高程序的性能，这个时候就可以用 C 或 C++来编写那部分代码，然后通过 N-API 与你的 Node.js 应用程序交互。</p><p>下面我将通过一个简单的例子解释<code>napi_throw</code>的工作原理：</p><p>假设你正在编写一个 Node.js 的扩展模块，该模块需要对传入的字符串参数进行校验，如果传入的不是字符串，则应该抛出一个错误。你的 C 函数可能会像这样：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value argv[1];</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取函数参数</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;获取参数失败！&quot;);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查参数类型是否为字符串</span></span>
<span class="line"><span>  napi_valuetype val_type;</span></span>
<span class="line"><span>  status = napi_typeof(env, argv[0], &amp;val_type);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;无法检查参数类型！&quot;);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (val_type != napi_string) {</span></span>
<span class="line"><span>    // 如果参数不是字符串，抛出TypeError</span></span>
<span class="line"><span>    napi_throw_type_error(env, NULL, &quot;参数必须是一个字符串！&quot;);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 这里是处理字符串的其他逻辑...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 假设一切顺利，你返回了某个结果</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  // ... 创建result值 ...</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数和导出模块...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们先通过<code>napi_get_cb_info</code>获取 JavaScript 传给函数的参数。然后，我们检查这个参数是否为字符串类型，如果不是，我们使用<code>napi_throw_type_error</code>抛出一个 TypeError 异常。注意，这里我们用的是特殊的<code>napi_throw_type_error</code>而不是<code>napi_throw</code>，因为我们想要抛出的是具体的 TypeError 异常。</p><p>实际上，<code>napi_throw</code>更加通用，你可以使用它直接抛出一个自定义的错误对象。例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value error_object;</span></span>
<span class="line"><span>// ... 创建或获取某个错误对象 ...</span></span>
<span class="line"><span>status = napi_throw(env, error_object); // 抛出这个错误对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结一下，<code>napi_throw</code>就是一个让你在原生模块代码中抛出 JavaScript 错误的工具，它让你能够告知 JavaScript 运行时：这里有个问题，处理流程应该停下来，并以异常的方式告诉调用方。在实际应用中，正确地处理错误并抛出异常是非常重要的，因为它有助于保持代码的鲁棒性并使得调试更加容易。</p><h4 id="napi-throw-error" tabindex="-1"><a class="header-anchor" href="#napi-throw-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_throw_error" target="_blank" rel="noopener noreferrer">napi_throw_error</a></span></a></h4><p><code>napi_throw_error</code> 是 Node.js 中 N-API（Node.js API）的一部分，它允许本地插件的开发者（通常是使用 C 或者 C++语言编写的代码模块）在发生错误时向 JavaScript 抛出异常。N-API 是一个稳定的 API 层，允许你构建原生插件并保证在 Node.js 的不同版本间保持兼容性。</p><p>当你在 JavaScript 代码中遇到错误时，可能会用到 <code>throw</code> 关键字来抛出异常，类似地，在原生模块中，你可以使用 <code>napi_throw_error</code> 来实现这个目的。当你调用 <code>napi_throw_error</code> 后，当前执行的 Node.js 函数会停止，并且这个错误会被返回给调用这个原生模块的 JavaScript 代码。</p><p>下面是 <code>napi_throw_error</code> 的基本用法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 一些代码逻辑 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设出现了一个错误，我们需要抛出它</span></span>
<span class="line"><span>    if (发现错误) {</span></span>
<span class="line"><span>        status = napi_throw_error(env, NULL, &quot;这里是错误信息&quot;);</span></span>
<span class="line"><span>        if (status != napi_ok) {</span></span>
<span class="line"><span>            // 处理无法抛出错误的情况</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他逻辑...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们有一个名为 <code>MyFunction</code> 的函数，它可能是作为一个原生模块暴露给 JavaScript 的功能。如果在函数内部检测到了错误条件，我们就使用 <code>napi_throw_error</code> 来抛出一个错误。第一个参数 <code>env</code> 是一个环境变量，它提供了当前 Node.js 调用的上下文。第二个参数是错误码，这里传递 <code>NULL</code> 表示我们没有指定错误码。最后一个参数是一个人类可读的错误信息字符串。</p><p>例如，假设你正在编写一个原生模块，用来处理图像，但是如果传入的文件路径不存在，你就需要报告一个错误：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>#include `&lt;`stdio.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value ProcessImage(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    char filename[100];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们通过某些方式获取到了文件名到 filename 变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查文件是否存在</span></span>
<span class="line"><span>    if (fopen(filename, &quot;r&quot;) == NULL) {</span></span>
<span class="line"><span>        // 文件不存在，抛出错误</span></span>
<span class="line"><span>        status = napi_throw_error(env, NULL, &quot;文件不存在或无法打开！&quot;);</span></span>
<span class="line"><span>        if (status != napi_ok) {</span></span>
<span class="line"><span>            // 处理无法抛出错误的情况</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 处理图像...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，如果尝试打开文件失败了，那么 <code>fopen</code> 会返回 <code>NULL</code>，然后我们调用 <code>napi_throw_error</code> 抛出一个错误，错误信息是 &quot;文件不存在或无法打开！&quot;。当这个原生模块的这个函数被 JavaScript 代码调用时，如果遇到这个错误，JavaScript 调用者可以捕获这个异常并作出相应的处理。</p><h4 id="napi-throw-type-error" tabindex="-1"><a class="header-anchor" href="#napi-throw-type-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_throw_type_error" target="_blank" rel="noopener noreferrer">napi_throw_type_error</a></span></a></h4><p>当然，让我来详细解释一下 <code>napi_throw_type_error</code> 这个函数在 Node.js 中的作用。</p><p>Node.js 的 N-API 是一个 C 语言的接口，它允许你使用 C 或 C++编写扩展，并与 JavaScript 交互。这使得开发者能够为 Node.js 编写性能敏感的操作，比如直接与操作系统或其他底层系统交互。</p><p><code>napi_throw_type_error</code> 是 N-API 中提供的一个函数，用于在原生代码中抛出一个 JavaScript 类型错误（TypeError）。类型错误通常发生在值不是预期类型时，比如当期望一个字符串（String）而实际上得到了一个数字（Number）。</p><p>下面是一个简单的例子，说明了如何在 N-API 扩展中使用 <code>napi_throw_type_error</code>：</p><p>想象我们正在创建一个 N-API 模块，该模块包含一个函数，此函数要求传入一个字符串参数。如果调用者传入非字符串参数，我们就抛出一个类型错误。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原生函数，期望接收一个字符串参数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Failed to parse arguments&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数类型是否为字符串</span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    status = napi_typeof(env, argv[0], &amp;valuetype);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Failed to identify argument type&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果不是字符串，则抛出类型错误</span></span>
<span class="line"><span>    if (valuetype != napi_string) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Argument must be a string.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 进行其它操作 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回undefined表示函数执行成功但没有返回值</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们定义了一个名为 <code>MyFunction</code> 的 C 函数，它将被暴露给 JavaScript 环境并且可以从 Node.js 代码中调用。如果调用者没有传递一个字符串参数，<code>napi_typeof</code> 函数会检测到这个问题，然后我们调用 <code>napi_throw_type_error</code> 来抛出类型错误。</p><p>现在，假设你已经编译了这个 N-API 模块并命名为 <code>my_native_module</code>。在 Node.js 代码中，你可以这样调用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./my_native_module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 故意传入一个非字符串参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这里将捕获并打印出类型错误</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个 JavaScript 示例中，我们尝试使用一个数字去调用 <code>myFunction</code>。因为我们的原生函数期望一个字符串，所以它使用 <code>napi_throw_type_error</code> 抛出一个错误，然后在 JavaScript 层面，我们通过 try-catch 结构捕获并处理这个错误。</p><p>希望这个解释和例子可以帮助你理解 <code>napi_throw_type_error</code> 在 Node.js 中的应用。</p><h4 id="napi-throw-range-error" tabindex="-1"><a class="header-anchor" href="#napi-throw-range-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_throw_range_error" target="_blank" rel="noopener noreferrer">napi_throw_range_error</a></span></a></h4><p>Node.js 中的 <code>napi_throw_range_error</code> 是一个函数，属于 Node.js 的 N-API（原生 API），它允许本地模块（用 C 或 C++编写的扩展）与 JavaScript 代码交互。当你需要从 C/C++代码中抛出一个 JavaScript 的 <code>RangeError</code> 异常时，可以使用这个函数。</p><p>在详细解释之前，首先要了解几个关键概念：</p><ol><li><p><strong>N-API</strong>: 这是一个独立于具体版本的 Node.js API，意在减少原生插件作者因 Node.js 升级导致的维护成本，并提供 ABI（应用程序二进制接口）稳定性。</p></li><li><p><strong>RangeError</strong>: 在 JavaScript 中，<code>RangeError</code> 是一种错误对象，表示值不在其允许的范围或者长度之内时发生的错误。</p></li><li><p><strong>C/C++ 原生模块</strong>: 通常指的是使用 Node.js 提供的 N-API 编写的、可以被 Node.js 直接调用的模块，这些模块是用 C 或 C++语言编写的。</p></li></ol><p>现在，我们来更加详细地看看 <code>napi_throw_range_error</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_throw_range_error(napi_env env,</span></span>
<span class="line"><span>                                   const char* code,</span></span>
<span class="line"><span>                                   const char* msg);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这个参数是指向 N-API 环境的指针，这个环境包含了所有 N-API 调用所需的状态信息。</li><li><code>code</code>: 这是一个字符串，代表错误的标识码。它对于区分不同的错误类型很有用。</li><li><code>msg</code>: 这也是一个字符串，含有描述错误详情的文本信息。</li></ul><p>当你调用 <code>napi_throw_range_error</code> 时，它会创建一个新的 <code>RangeError</code> 对象，并使用你提供的 <code>code</code> 和 <code>msg</code> 来初始化这个错误对象。然后，它会抛出这个错误，就像在 JavaScript 代码中使用 <code>throw new RangeError(msg);</code> 一样。</p><h3 id="实际运用示例" tabindex="-1"><a class="header-anchor" href="#实际运用示例"><span>实际运用示例</span></a></h3><p>假设你正在编写一个原生模块，该模块提供一个函数，这个函数要求输入一个数组和一个索引值，返回数组中对应索引位置的元素。如果传入的索引超出了数组范围，你想要抛出一个 <code>RangeError</code>。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原生函数实现</span></span>
<span class="line"><span>napi_value GetArrayElement(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否传入了足够的参数，以及参数的类型是否正确</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设已经获取了array和index，并对它们进行了验证</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    bool is_out_of_range = false;</span></span>
<span class="line"><span>    // ... 判断索引是否超出数组范围的代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (is_out_of_range) {</span></span>
<span class="line"><span>        // 索引超出范围，抛出RangeError</span></span>
<span class="line"><span>        napi_throw_range_error(env, &quot;ERR_INDEX_OUT_OF_RANGE&quot;, &quot;Index is out of range.&quot;);</span></span>
<span class="line"><span>        return NULL; // 返回NULL表示发生了异常</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他处理代码，返回数组中的元素 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化模块，注册原生函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value getArrayElementFn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, GetArrayElement, NULL, &amp;getArrayElementFn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;getArrayElement&quot;, getArrayElementFn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，如果判断索引超出了数组范围，我们就调用 <code>napi_throw_range_error</code> 抛出异常。这会立即停止当前的函数执行，并将控制权返回给 JavaScript 调用者。JavaScript 调用者可以通过 try-catch 结构捕获并处理这个异常。</p><p>这样一来，使用你编写的原生模块的开发者就能得到清晰的错误信息，并且能够像处理常规 JavaScript 异常一样处理这些错误。</p><h4 id="node-api-throw-syntax-error" tabindex="-1"><a class="header-anchor" href="#node-api-throw-syntax-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_throw_syntax_error" target="_blank" rel="noopener noreferrer">node_api_throw_syntax_error</a></span></a></h4><p>Node.js 中的 <code>napi_throw_syntax_error</code> 是一个函数，属于 N-API 这套 API 的一部分。N-API 提供了一个 C 语言的接口，允许原生插件（用 C 或 C++编写）与 Node.js 代码交互。这些原生插件通常用于性能关键型任务，比如图像处理或者访问系统底层资源。</p><p><code>napi_throw_syntax_error</code> 函数具体是用来创建并抛出一个 JavaScript 语法错误 (<code>SyntaxError</code>)。在 JavaScript 中，当代码中有语法错误时，比如括号不匹配、关键字使用不当等情况，解释器就会抛出 <code>SyntaxError</code>。然而，在一个原生模块中，如果你想要从 C/C++ 级别上抛出一个类似的错误到 JavaScript 环境，你可以通过 <code>napi_throw_syntax_error</code> 来实现。</p><h3 id="函数签名" tabindex="-1"><a class="header-anchor" href="#函数签名"><span>函数签名：</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_throw_syntax_error(napi_env env, const char* code, const char* msg);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code> 参数是一个 <code>napi_env</code> 类型的变量，它代表了当前的 Node.js 执行环境。</li><li><code>code</code> 参数是一个以 NULL 结尾的字符串，表示错误代码或标识符。</li><li><code>msg</code> 参数是另一个以 NULL 结尾的字符串，它描述了错误的详细信息。</li></ul><h3 id="返回值" tabindex="-1"><a class="header-anchor" href="#返回值"><span>返回值：</span></a></h3><p>该函数返回一个 <code>napi_status</code> 类型的值，表示操作成功与否：</p><ul><li>如果函数执行成功，它将返回 <code>napi_ok</code>。</li><li>如果发生了错误（例如参数无效），它将返回相应的错误码。</li></ul><h3 id="实际运用示例-1" tabindex="-1"><a class="header-anchor" href="#实际运用示例-1"><span>实际运用示例：</span></a></h3><p>假设你正在编写一个 Node.js 原生模块，要求用户传入一段 JSON 字符串来处理。如果传入的字符串格式错误，你希望抛出一个语法错误提醒用户。</p><p>下面是一段可能的 C/C++ 代码片段，展示了如何使用 <code>napi_throw_syntax_error</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value ParseJSON(napi_env env, napi_callback_info args) {</span></span>
<span class="line"><span>    // 获取传递给这个函数的参数</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, args, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数类型是否为字符串</span></span>
<span class="line"><span>    napi_valuetype val_type;</span></span>
<span class="line"><span>    napi_typeof(env, argv[0], &amp;val_type);</span></span>
<span class="line"><span>    if (val_type != napi_string) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Argument must be a string.&quot;);</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 尝试将传入的字符串解析为 JSON</span></span>
<span class="line"><span>    // 假设 parseJSONString 是某个自定义的函数，用于解析 JSON</span></span>
<span class="line"><span>    bool parse_successful = parseJSONString(env, argv[0]);</span></span>
<span class="line"><span>    if (!parse_successful) {</span></span>
<span class="line"><span>        // 如果解析失败，则抛出语法错误</span></span>
<span class="line"><span>        napi_throw_syntax_error(env, NULL, &quot;Invalid JSON string&quot;);</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>    // 余下的函数逻辑</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在原生模块初始化时注册上述函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, ParseJSON, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;parseJSON&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，<code>ParseJSON</code> 函数首先检查传入的参数是否为字符串，如果不是，它会抛出一个类型错误。如果参数确实是字符串，但无法被正确解析为 JSON，它则会使用 <code>napi_throw_syntax_error</code> 抛出一个语法错误。这样，当 JavaScript 代码调用这个原生模块时，如果提供的 JSON 字符串格式有误，JavaScript 代码将能够捕获到一个 <code>SyntaxError</code> 异常。</p><h4 id="napi-is-error" tabindex="-1"><a class="header-anchor" href="#napi-is-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_error" target="_blank" rel="noopener noreferrer">napi_is_error</a></span></a></h4><p>Node.js 中的 N-API 是一个底层的 API，它允许你用 C 或 C++编写扩展。这些扩展可以被 Node.js 直接调用，用于执行那些 JavaScript 不擅长或者速度较慢的任务。<code>napi_is_error</code>是 N-API 提供的一种功能，我们来详细了解一下。</p><h3 id="napi-is-error-1" tabindex="-1"><a class="header-anchor" href="#napi-is-error-1"><span>napi_is_error</span></a></h3><p>简单来说，<code>napi_is_error</code>函数用来检查一个<code>napi_value</code>是否表示一个 JavaScript 的 Error 对象。在 JavaScript 中，错误通常用 Error 对象来表示。这个功能对于原生模块的开发者来说很有用，因为它们需要处理从 JavaScript 传递过来的值，并且有时需要区分哪些值是正常值，哪些是错误。</p><h4 id="函数签名-1" tabindex="-1"><a class="header-anchor" href="#函数签名-1"><span>函数签名</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_is_error(napi_env env, napi_value value, bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code>：环境变量，代表了 Node.js 的运行环境。</li><li><code>value</code>：要检查的<code>napi_value</code>。</li><li><code>result</code>：输出参数，如果<code>value</code>是一个错误对象，<code>*result</code>会设置为<code>true</code>，否则为<code>false</code>。</li></ul><h4 id="返回值-1" tabindex="-1"><a class="header-anchor" href="#返回值-1"><span>返回值</span></a></h4><p>返回<code>napi_status</code>，它告诉你操作是否成功。如果操作失败，通常意味着有一些严重的问题，比如参数无效等。</p><h3 id="实际例子-3" tabindex="-1"><a class="header-anchor" href="#实际例子-3"><span>实际例子</span></a></h3><p>假设你正在编写一个 Node.js 的原生模块，你可能有一个 C 函数，它接收一个从 JavaScript 传来的参数，你需要确定这个参数是不是一个 Error 对象。</p><p>以下是一个使用<code>napi_is_error</code>的 C 代码片段：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设已经获得了napi_env env和napi_value arg</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool is_error;</span></span>
<span class="line"><span>napi_status status = napi_is_error(env, arg, &amp;is_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误，例如可以输出错误日志、抛出异常等</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (is_error) {</span></span>
<span class="line"><span>    // 如果arg是一个Error对象，执行相应的处理</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 如果arg不是Error对象，执行其他逻辑</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，你首先定义了一个布尔变量<code>is_error</code>来存储结果。然后，你调用<code>napi_is_error</code>并传入<code>env</code>、<code>arg</code>和<code>is_error</code>的地址。函数将检查<code>arg</code>是否是一个 Error 对象，并将结果存储在<code>is_error</code>中。之后，根据<code>is_error</code>的值，你可以决定接下来的处理流程。</p><p>请记住，这个 API 和其它的 N-API 函数一样，主要用于创建 Node.js 的原生扩展。如果你是一个编程新手，可能还不需要深入到这个层面。但了解 Node.js 能与 C/C++交互，以及如何检查错误是很有用的。随着你逐渐深入学习，可能会遇到需要使用这些高级特性的情况。</p><h4 id="napi-create-error" tabindex="-1"><a class="header-anchor" href="#napi-create-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_error" target="_blank" rel="noopener noreferrer">napi_create_error</a></span></a></h4><p>当然，我会尽量详细并通俗地解释 <code>napi_create_error</code> 这个函数及其在 Node.js 中的作用。</p><h3 id="什么是-napi-create-error" tabindex="-1"><a class="header-anchor" href="#什么是-napi-create-error"><span>什么是 <code>napi_create_error</code>？</span></a></h3><p><code>napi_create_error</code> 是 Node.js 的 N-API（Node.js API）中的一个函数，用于创建一个新的 <code>Error</code> 对象。N-API 是 Node.js 提供给原生插件作者的稳定的 C 接口，让他们可以不必担心 Node.js 版本的变化而频繁更新代码。</p><p>JavaScript 中的错误处理是通过 <code>throw</code> 关键字和 <code>try...catch</code> 结构来实现的。在原生模块中，你可能需要创建一个 JavaScript 错误对象并将其传递回 JavaScript 环境以便能够在 JavaScript 中处理这些错误。<code>napi_create_error</code> 就是用来在原生代码中创建 JavaScript 错误对象的方法。</p><h3 id="napi-create-error-函数参数和返回值" tabindex="-1"><a class="header-anchor" href="#napi-create-error-函数参数和返回值"><span><code>napi_create_error</code> 函数参数和返回值</span></a></h3><p><code>napi_create_error</code> 函数通常接受以下几个参数：</p><ol><li><code>napi_env env</code>: 当前执行环境的句柄，它提供了从原生代码到 Node.js 运行时的上下文。</li><li><code>napi_value code</code>: 错误码，通常是一个字符串或整数，表示错误类型。</li><li><code>napi_value msg</code>: 实际的错误信息，通常是描述错误详情的字符串。</li></ol><p>这个函数的返回值是一个 <code>napi_status</code> 类型的枚举值，表示调用是否成功。如果成功，你就可以在之后的代码中使用创建的错误对象。</p><h3 id="如何使用-napi-create-error" tabindex="-1"><a class="header-anchor" href="#如何使用-napi-create-error"><span>如何使用 <code>napi_create_error</code></span></a></h3><p>假设你正在编写一个 Node.js 原生插件，并且需要在检测到某种错误情况时，抛出一个错误给 JavaScript 处理。以下是一个简单的示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个原生函数，该函数需要在发生错误时抛出异常</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value error_code, error_message, error_object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这里你的逻辑代码可能会发现了一个错误，并需要报告它</span></span>
<span class="line"><span>    bool has_error = true; // 假设我们检测到了一个错误</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (has_error) {</span></span>
<span class="line"><span>        // 创建错误码</span></span>
<span class="line"><span>        status = napi_create_string_utf8(env, &quot;MY_ERROR_CODE&quot;, NAPI_AUTO_LENGTH, &amp;error_code);</span></span>
<span class="line"><span>        if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 创建错误信息</span></span>
<span class="line"><span>        status = napi_create_string_utf8(env, &quot;An unexpected error occurred!&quot;, NAPI_AUTO_LENGTH, &amp;error_message);</span></span>
<span class="line"><span>        if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 创建错误对象</span></span>
<span class="line"><span>        status = napi_create_error(env, error_code, error_message, &amp;error_object);</span></span>
<span class="line"><span>        if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 抛出错误</span></span>
<span class="line"><span>        napi_throw(env, error_object);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他正常逻辑...</span></span>
<span class="line"><span>    return some_successful_result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册 MyFunction</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，如果 <code>MyFunction</code> 检测到错误，它会创建一个带有错误码 <code>&quot;MY_ERROR_CODE&quot;</code> 和错误信息 <code>&quot;An unexpected error occurred!&quot;</code> 的错误对象。然后，它使用 <code>napi_throw</code> 函数抛出这个错误对象。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><code>napi_create_error</code> 是 Node.js N-API 中用来在原生模块代码中创建 JavaScript 错误对象的函数。通过它，你可以在原生代码中生成错误，并通过 JavaScript 的错误处理机制来捕获和处理这些错误。它对于提供清晰的错误信息和保持 JavaScript 和原生代码之间的兼容性非常重要。</p><p>记住，在实现原生模块时，正确的错误处理能够大大提高模块的健壮性和可用性。</p><h4 id="napi-create-type-error" tabindex="-1"><a class="header-anchor" href="#napi-create-type-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_type_error" target="_blank" rel="noopener noreferrer">napi_create_type_error</a></span></a></h4><p>Node.js 中的 N-API (Node Addon API) 是一个用于构建本地插件（native addons）的 API 层。本地插件是指直接与 Node.js 运行时集成的，使用 C 或 C++ 编写的模块。这些插件可以提供性能上的优势或者使得 Node.js 能够访问系统级资源和库。</p><p><code>napi_create_type_error</code> 函数是 N-API 中的一部分，它允许你创建一个 JavaScript 的类型错误 (TypeError) 对象。在 JavaScript 中，当一个值不是预期的数据类型时，通常会抛出一个 TypeError。例如，如果函数期望一个字符串参数，但是收到了一个数字，那么就可能抛出一个 TypeError。</p><h3 id="使用-napi-create-type-error" tabindex="-1"><a class="header-anchor" href="#使用-napi-create-type-error"><span>使用 <code>napi_create_type_error</code></span></a></h3><p>在 Node.js 的本地插件中，你有时需要向 JavaScript 代码报告某个值的类型不正确。在这种情况下，你可以使用 <code>napi_create_type_error</code> 来创建一个相应的错误对象，并将它传递回 JavaScript 环境。</p><p>以下是如何使用 <code>napi_create_type_error</code> 的步骤：</p><ol><li>确认你正在编写的代码是一个本地插件，即使用 C 或 C++ 并希望与 Node.js 交互。</li><li>包含必要的 N-API 头文件。</li><li>实现一个函数，该函数会检查输入参数的类型，并在类型不符合期望时创建类型错误。</li></ol><p>下面是一个简化的例子来演示其用法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是一个函数，它期望第一个参数是一个字符串。</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取函数参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数类型</span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    status = napi_typeof(env, args[0], &amp;valuetype);</span></span>
<span class="line"><span>    if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果不是字符串，则创建 TypeError</span></span>
<span class="line"><span>    if (valuetype != napi_string) {</span></span>
<span class="line"><span>        napi_value result;</span></span>
<span class="line"><span>        napi_value error_message;</span></span>
<span class="line"><span>        const char* message = &quot;Wrong argument type. Expected a string.&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 创建一个JS字符串作为错误信息</span></span>
<span class="line"><span>        status = napi_create_string_utf8(env, message, NAPI_AUTO_LENGTH, &amp;error_message);</span></span>
<span class="line"><span>        if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 创建 TypeError 错误对象</span></span>
<span class="line"><span>        status = napi_create_type_error(env, NULL, error_message, &amp;result);</span></span>
<span class="line"><span>        if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 抛出错误</span></span>
<span class="line"><span>        napi_throw(env, result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果参数类型正确，继续执行函数...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化代码略过...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>MyFunction</code> 是一个本地插件中定义的函数，它期望接收一个字符串类型的参数。如果传入的参数不是字符串类型，那么我们使用 <code>napi_create_type_error</code> 来创建一个 TypeError 对象，并通过 <code>napi_throw</code> 来抛出这个错误。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p><code>napi_create_type_error</code> 是 Node.js N-API 的一部分，用于在本地插件中创建并抛出 JavaScript 的 TypeError。这对于确保 JavaScript 从本地插件接收到正确类型的数据非常有用，并且有助于开发者诊断和处理错误。</p><h4 id="napi-create-range-error" tabindex="-1"><a class="header-anchor" href="#napi-create-range-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_range_error" target="_blank" rel="noopener noreferrer">napi_create_range_error</a></span></a></h4><p>Node.js 中的<code>napi_create_range_error</code>是一个功能，它属于 N-API（原生 API），这是一套 C 语言编写的接口，允许你创建和操作 JavaScript 值，并在原生插件（用 C/C++编写的模块）中与 JavaScript 代码交互。使用 N-API 编写的原生模块可以在不同版本的 Node.js 上运行而无需重新编译，这有助于提高模块的兼容性和稳定性。</p><p>现在，来解释一下什么是<code>napi_create_range_error</code>：</p><p>在 JavaScript 中，<code>RangeError</code>是一种错误对象，表示当一个值不在其预期范围内时抛出的错误。例如，如果你尝试用一个负数去访问数组的元素，或者使用<code>Number</code>对象的方法传递了一个无效的数字范围，就会抛出<code>RangeError</code>。</p><p>使用<code>napi_create_range_error</code>，你可以从 C/C++代码中创建一个与 JavaScript <code>RangeError</code>相对应的 N-API 错误对象。这在你需要将一个由原生代码检测到的范围错误传达给 JavaScript 环境时非常有用。</p><p>这个函数的签名如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_range_error(napi_env env,</span></span>
<span class="line"><span>                                    napi_value code,</span></span>
<span class="line"><span>                                    napi_value msg,</span></span>
<span class="line"><span>                                    napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是一个代表 N-API 环境的句柄，你可以通过它来调用 N-API 的其他函数。</li><li><code>code</code>: 一个<code>napi_value</code>，包含了一个错误码，通常是一个字符串 ID。</li><li><code>msg</code>: 一个<code>napi_value</code>，包含了一个描述错误的消息。</li><li><code>result</code>: 这是一个输出参数，指向创建好的<code>RangeError</code>对象。</li></ul><p>举个例子，假设你正在编写一个原生插件，需要检查传入的参数是否在有效的索引范围内：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_status CheckIndexInRange(napi_env env, int index, int array_size) {</span></span>
<span class="line"><span>    if (index `&lt;` 0 || index &gt;= array_size) {</span></span>
<span class="line"><span>        // 创建一个错误消息</span></span>
<span class="line"><span>        napi_value msg;</span></span>
<span class="line"><span>        napi_create_string_utf8(env, &quot;Index is out of range&quot;, NAPI_AUTO_LENGTH, &amp;msg);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 创建一个 RangeError 对象</span></span>
<span class="line"><span>        napi_value range_error;</span></span>
<span class="line"><span>        napi_create_range_error(env, NULL, msg, &amp;range_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 将这个错误抛给 JavaScript 环境</span></span>
<span class="line"><span>        napi_throw(env, range_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return napi_throw_error; // 返回一个表示发生了错误的状态码</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return napi_ok; // 没有错误发生</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，当<code>CheckIndexInRange</code>函数检测到<code>index</code>不在合法范围内时，它会创建一个<code>RangeError</code>并使用<code>napi_throw</code>将这个错误抛出到 JavaScript 环境中。这样，当 JavaScript 代码调用这个原生模块的相关函数并发生范围错误时，JavaScript 代码就能捕获到这个错误并相应地处理。</p><h4 id="node-api-create-syntax-error" tabindex="-1"><a class="header-anchor" href="#node-api-create-syntax-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_create_syntax_error" target="_blank" rel="noopener noreferrer">node_api_create_syntax_error</a></span></a></h4><p>好的，Node.js 中的 <code>node_api_create_syntax_error</code> 是一个关于 N-API 的功能点。N-API 是 Node.js 提供的一套用于构建原生插件的 API，这些 API 是独立于 JavaScript 运行时的，并且在 Node.js 的不同版本中保持向后兼容。</p><p><code>node_api_create_syntax_error</code> 函数用于创建一个新的 <code>SyntaxError</code> 对象。<code>SyntaxError</code> 是 JavaScript 中的一个错误类型，它表示在解析代码时发生的语法错误。当 JavaScript 引擎读取和解释代码而遇到不能理解的结构时，就会抛出 <code>SyntaxError</code>。</p><p>该函数的具体作用是在原生代码（比如 C 或 C++模块）中创建一个与 JavaScript <code>SyntaxError</code> 相似的错误对象，然后可以将这个错误传回到 JavaScript 环境中。这样做的目的是为了让原生模块能够以一种对 JavaScript 开发者来说熟悉的方式报告错误。</p><p>使用 <code>node_api_create_syntax_error</code> 时，通常会指定三个参数：</p><ol><li><code>env</code> - 当前的 N-API 环境句柄，它提供了大量实用的 API。</li><li><code>code</code> - 错误码，是一个唯一标识符，用于区分不同的错误。</li><li><code>msg</code> - 实际的错误信息，描述了发生了什么错误。</li></ol><p>现在我们来看几个简单的例子:</p><h3 id="例子-1-创建一个简单的-syntaxerror" tabindex="-1"><a class="header-anchor" href="#例子-1-创建一个简单的-syntaxerror"><span>例子 1: 创建一个简单的 <code>SyntaxError</code></span></a></h3><p>假设你正在编写一个原生模块，需要检测传入的字符串是否符合你预期的格式。如果字符串格式不正确，你想要抛出一个 <code>SyntaxError</code>。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateSyntaxErrorExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_value syntax_error;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个 SyntaxError 对象</span></span>
<span class="line"><span>  const char* error_message = &quot;Unexpected token in JSON at position 10&quot;;</span></span>
<span class="line"><span>  napi_status status = napi_create_syntax_error(env, NULL, error_message, &amp;syntax_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查操作是否成功</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将创建的错误返回给 JavaScript</span></span>
<span class="line"><span>  return syntax_error;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 更多的模块初始化代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码定义了一个函数 <code>CreateSyntaxErrorExample</code>，它创建了一个包含自定义错误消息的 <code>SyntaxError</code> 对象，并将其返回给 JavaScript。若创建失败，应当处理相应的错误状态。</p><h3 id="例子-2-在检测到无效输入时使用-syntaxerror" tabindex="-1"><a class="header-anchor" href="#例子-2-在检测到无效输入时使用-syntaxerror"><span>例子 2: 在检测到无效输入时使用 <code>SyntaxError</code></span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value ParseJSON(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  napi_status status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 以下略过参数检验和转换的代码</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 假设我们已经获取了要解析的字符串：json_str</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  bool is_valid_json = false;</span></span>
<span class="line"><span>  // 对 json_str 进行处理并设置 is_valid_json 标志</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (!is_valid_json) {</span></span>
<span class="line"><span>    // 如果不是有效的 JSON，则创建 SyntaxError 并将其抛出</span></span>
<span class="line"><span>    napi_value syntax_error;</span></span>
<span class="line"><span>    status = napi_create_syntax_error(env, NULL, &quot;Invalid JSON string&quot;, &amp;syntax_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>      napi_throw(env, syntax_error); // 抛出错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 解析成功的逻辑...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 更多的模块初始化代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>ParseJSON</code> 函数试图解析一个 JSON 字符串。如果检测到该字符串不是有效的 JSON，它将创建一个 <code>SyntaxError</code> 对象并通过调用 <code>napi_throw</code> 将其抛给调用方。这样，JavaScript 调用侧就可以捕获并处理这个错误了。</p><h4 id="napi-get-and-clear-last-exception" tabindex="-1"><a class="header-anchor" href="#napi-get-and-clear-last-exception"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_and_clear_last_exception" target="_blank" rel="noopener noreferrer">napi_get_and_clear_last_exception</a></span></a></h4><p><code>napi_get_and_clear_last_exception</code> 是 Node.js 中的一个函数，它属于 N-API 的一部分。N-API 是一个稳定的 C API，允许你构建原生插件，即用 C、C++等语言编写的模块，这些模块可以直接被 Node.js 代码调用。</p><p>当你在创建 Node.js 的原生插件时，可能会与 JavaScript 代码进行交互，并且有时候这些交互可能会导致异常（错误）发生。正常情况下，如果 JavaScript 代码抛出了一个异常，而你没有恰当地处理它，那么这个异常就会沿着调用栈向上传播，直到它到达最顶层并被 Node.js 环境捕获。</p><p><code>napi_get_and_clear_last_exception</code> 这个函数的作用是：当你的原生代码引起了 JavaScript 异常时，你可以使用此函数来检索这个异常对象，并且同时清除掉这个异常，防止它继续向上传播。</p><p>以下是如何使用 <code>napi_get_and_clear_last_exception</code> 的一个简单例子：</p><p>假设我们有一个原生函数，该函数试图执行一段 JavaScript 代码，但可能会抛出一个异常：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设的原生函数，其中可能会产生JavaScript异常</span></span>
<span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 尝试做一些工作...</span></span>
<span class="line"><span>    // 这里的某些操作可能会抛出JavaScript异常</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否有异常发生</span></span>
<span class="line"><span>    napi_value exception;</span></span>
<span class="line"><span>    napi_status status = napi_get_and_clear_last_exception(env, &amp;exception);</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 异常已经被清理，现在你可以决定如何处理它</span></span>
<span class="line"><span>        // 例如，你可以打印出错误信息或将其作为错误返回值返回给调用者</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 其他工作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>MyNativeFunction</code> 函数在执行期间可能会产生一个异常。通过调用 <code>napi_get_and_clear_last_exception</code>，我们检查是否有任何异常发生，并清除它。如果确实存在异常，我们就可以获取异常对象，并决定如何处理它，比如记录日志，或者将错误信息返回给原生函数的调用者。</p><p>此外，N-API 提供了一套完整的异常处理 API，包括但不限于获取异常信息、创建新的错误对象等，让原生模块开发者能够更好地控制错误处理流程。</p><p>记住，N-API 是专门设计用来构建原生插件的，所以如果你只是在写普通的 Node.js JavaScript 代码，可能永远都不需要直接接触到像<code>napi_get_and_clear_last_exception</code>这样的函数。这些 API 更多地用在底层的性能优化或特殊功能实现上。</p><h4 id="napi-is-exception-pending" tabindex="-1"><a class="header-anchor" href="#napi-is-exception-pending"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_exception_pending" target="_blank" rel="noopener noreferrer">napi_is_exception_pending</a></span></a></h4><p>好的，让我来解释一下 Node.js 中的 <code>napi_is_exception_pending</code> 函数。</p><p>N-API（Node.js API）是一个用于构建原生插件的接口。原生插件指的是用 C、C++等编程语言写成的模块，它们能够直接与 Node.js 的底层 API 进行交互，通常用于性能关键型操作或者调用系统级别的库。</p><p>在使用 N-API 编写原生代码时，可能会产生异常。在 JavaScript 中，异常通常是一个错误对象，当你的代码执行出错时，JavaScript 运行时会抛出这个错误对象。类似地，在 N-API 编写的原生插件中也可以抛出异常。</p><p><code>napi_is_exception_pending</code> 是一个函数，用来检查是否有异常在原生模块中被触发但还未被 JavaScript 处理。这个函数非常重要，因为在继续执行其他 N-API 调用前，必须清理现有的异常，否则可能导致不可预见的行为。</p><p>下面我们看一下 <code>napi_is_exception_pending</code> 函数的基本使用方法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // ...你的代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否有未处理的异常</span></span>
<span class="line"><span>  bool hasException;</span></span>
<span class="line"><span>  napi_status status = napi_is_exception_pending(env, &amp;hasException);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 如果调用成功，并且有异常存在</span></span>
<span class="line"><span>  if (status == napi_ok &amp;&amp; hasException) {</span></span>
<span class="line"><span>    // 处理异常，比如获取异常对象并打印它</span></span>
<span class="line"><span>    napi_value exception;</span></span>
<span class="line"><span>    status = napi_get_and_clear_last_exception(env, &amp;exception);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 打印异常信息或其他处理 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一个错误或null表示函数执行遇到了问题</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ... 其他代码，如果没有异常就继续执行 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回结果</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  // 假设我们要返回一个简单的字符串 &quot;hello world&quot;</span></span>
<span class="line"><span>  status = napi_create_string_utf8(env, &quot;hello world&quot;, NAPI_AUTO_LENGTH, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return status == napi_ok ? result : NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册上面的函数为一个原生模块的导出函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value fn;</span></span>
<span class="line"><span>  napi_status status = napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>  if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个名为 <code>MyFunction</code> 的函数，它首先使用 <code>napi_is_exception_pending</code> 来检查是否有异常在等待处理。如果有异常，我们利用函数 <code>napi_get_and_clear_last_exception</code> 获取这个异常对象，并且可以做进一步处理，例如打印异常信息。此外，如果没有异常就继续后面的操作，并最终创建一个字符串返回结果。</p><p>通过这种方式，我们在编写原生插件的时候能够更好地管理和响应异常情况，确保 Node.js 应用的稳定性和正确性。</p><h4 id="napi-fatal-exception" tabindex="-1"><a class="header-anchor" href="#napi-fatal-exception"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_fatal_exception" target="_blank" rel="noopener noreferrer">napi_fatal_exception</a></span></a></h4><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎的 JavaScript 运行环境，允许你在服务器端运行 JavaScript 代码。Node.js 使用事件驱动、非阻塞 I/O 模型，使其轻量且高效，非常适合处理数据密集型实时应用。</p><p>在 Node.js 中，有一个原生模块系统叫作 N-API，它提供了一系列的 API，让你能够使用 C 或者 C++ 来编写扩展。这些扩展能够直接与 Node.js 的 JavaScript 运行时进行交互，提供一些 JavaScript 本身无法或者不那么高效实现的功能。</p><p><code>napi_fatal_exception</code> 是 N-API 中的一个函数，当你在编写一个 Node.js 的原生扩展时可能会用到它。简单来说，当你的原生扩展中发生了一个无法恢复的错误，可以调用此函数来通知 Node.js 异常情况，并让 Node.js 停止当前的事件循环并退出。</p><p>下面是 <code>napi_fatal_exception</code> 的一个简化示例说明：</p><p>想象你正在编写一个原生模块，该模块需要执行一些底层操作，比如访问硬件信息或者进行复杂的数学计算。假设在执行这些操作时出现了一个严重错误，例如访问了无效的内存地址或者触发了一个断言失败。在这种情况下，可能需要立即终止程序，因为程序的状态已经不确定且可能导致更多错误或安全问题。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个示例原生函数，它可能会遇到致命的异常</span></span>
<span class="line"><span>napi_value ExampleFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 假设我们在这里进行一些操作，但出现了一个严重错误...</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 致命错误发生，我们需要通知 Node.js</span></span>
<span class="line"><span>    napi_value error;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;致命错误：操作无法完成！&quot;, NAPI_AUTO_LENGTH, &amp;error);</span></span>
<span class="line"><span>    napi_fatal_exception(env, error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 此行之后的代码将不会被执行，因为 napi_fatal_exception 将终止执行</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, ExampleFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;exampleFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，如果 <code>ExampleFunction</code> 函数中的操作失败并触发了致命的异常，它会创建一个错误信息字符串并通过 <code>napi_fatal_exception</code> 传递给 Node.js。一旦调用了 <code>napi_fatal_exception</code>，Node.js 会认为发生了不可恢复的错误，并将默认终止进程。</p><p>值得注意的是，在真实的原生模块开发中，你不会频繁地使用 <code>napi_fatal_exception</code>，因为大部分错误都应该通过正常的 JavaScript 异常机制来处理。只有在确实遇到了无法恢复的严重错误时，才应该使用此函数。</p><h3 id="fatal-errors" tabindex="-1"><a class="header-anchor" href="#fatal-errors"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#fatal-errors" target="_blank" rel="noopener noreferrer">Fatal errors</a></span></a></h3><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎的 JavaScript 运行环境，它使得开发者可以使用 JavaScript 编写服务端代码。在 Node.js 中提供了很多的内建模块，以及通过 npm（Node Package Manager）可以安装的第三方模块，以便开发者构建各种应用程序。</p><p>N-API 是 Node.js 提供的一个用来构建原生扩展的 API。原生扩展是一种特殊类型的模块，它允许 JavaScript 与能够以更高性能执行特定任务的 C/C++代码互操作。这通常用于那些对性能要求很高的场景，比如访问硬件功能或者进行密集型计算。</p><p>当你遇到 &quot;Fatal errors&quot; 这个术语时，它指的是在运行 Node.js 程序过程中，系统遇到了无法恢复的错误，导致 Node.js 进程崩溃。下面就来简单解释一下什么是 Fatal errors，并给出一些实际的例子。</p><h3 id="fatal-errors-1" tabindex="-1"><a class="header-anchor" href="#fatal-errors-1"><span>Fatal errors</span></a></h3><p>在 Node.js 的 N-API 上下文中，Fatal error 是指在使用 N-API 函数调用时，如果因为某种原因（比如内存不足、无效的参数等）导致程序无法继续执行，Node.js 就会触发一个致命错误。</p><p>它通常意味着有一些重大的问题出现了，必须立即修复，因为它会导致 Node.js 进程完全退出，而且不会触发正常的异常处理流程。而且，由于这类错误是在 C/C++ 层面产生的，JavaScript 层面的 try-catch 无法捕捉到它们。</p><h4 id="实际的例子" tabindex="-1"><a class="header-anchor" href="#实际的例子"><span>实际的例子：</span></a></h4><ol><li><p><strong>内存不足</strong>: 如果你的原生扩展尝试分配内存，但是系统没有足够的可用内存，这可能会导致致命错误。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Napi::Env env = ...;</span></span>
<span class="line"><span>size_t size_to_allocate = 1024 * 1024 * 1024; // 尝试分配 1GB 内存</span></span>
<span class="line"><span>char* large_block = new (std::nothrow) char[size_to_allocate];</span></span>
<span class="line"><span>if (large_block == nullptr) {</span></span>
<span class="line"><span>  // 内存分配失败，触发Fatal error</span></span>
<span class="line"><span>  NAPI_FATAL_ERROR(&quot;Unable to allocate enough memory&quot;);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>违反 API 使用规则</strong>: 比如，如果一个 N-API 函数要求传入非空指针作为参数，但你错误地传入了空指针，这可能导致致命错误。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Napi::Env env = ...;</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>// 假设 some_function 需要一个有效的 `napi_value` 参数，而不是 `nullptr`</span></span>
<span class="line"><span>napi_status status = some_function(env, nullptr, &amp;result);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // API 调用不正确，触发Fatal error</span></span>
<span class="line"><span>  const napi_extended_error_info* error_info;</span></span>
<span class="line"><span>  napi_get_last_error_info(env, &amp;error_info);</span></span>
<span class="line"><span>  NAPI_FATAL_ERROR(error_info-&gt;error_message);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>未处理的异常</strong>: 如果你的原生扩展函数中发生了未被捕获的异常，它也可能转变成致命错误。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Napi::Env env = ...;</span></span>
<span class="line"><span>try {</span></span>
<span class="line"><span>  // 执行一些可能抛出异常的操作</span></span>
<span class="line"><span>} catch (const std::exception&amp; e) {</span></span>
<span class="line"><span>  // 异常被捕获，但没有合适的处理方式，触发Fatal error</span></span>
<span class="line"><span>  NAPI_FATAL_ERROR(e.what());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>在处理致命错误时，你需要谨慎，确保只有在真正无法恢复的情况下才触发它们，并且最好在发生之前，就通过代码审查和测试来预防这类错误的发生。因为一旦发生，它通常意味着进程的即刻终止。</p><h4 id="napi-fatal-error" tabindex="-1"><a class="header-anchor" href="#napi-fatal-error"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_fatal_error" target="_blank" rel="noopener noreferrer">napi_fatal_error</a></span></a></h4><p>Node.js 中有一种叫 N-API 的 API（应用程序编程接口），它允许你使用 C 或 C++ 编写代码，这些代码可以和 Node.js 进行交互。N-API 设计的目的是帮助开发者创建所谓的原生插件或原生模块，即直接与 Node.js JavaScript 引擎通信的非 JavaScript 代码。</p><p><code>napi_fatal_error</code> 是 N-API 提供的一个函数，它的作用是在一个不可恢复的错误发生时通知 Node.js。当这个函数被调用后，它会导致 Node.js 进程立即终止，也就是说你的 Node.js 应用会立刻停止运行，并输出一条错误消息。</p><p>这个函数的定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void napi_fatal_error(const char* location, size_t location_length,</span></span>
<span class="line"><span>                      const char* message, size_t message_length);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明：</p><ul><li><code>location</code>: 这个参数是一个字符串，表示错误发生的位置，可能是一个文件名或者函数名。</li><li><code>location_length</code>: 是上述位置字符串的长度。</li><li><code>message</code>: 这个参数是一个字符串，包含了错误信息。</li><li><code>message_length</code>: 是上述错误信息字符串的长度。</li></ul><p>这里要注意的是，<code>napi_fatal_error</code> 通常只在最糟糕的情况下使用，当你确实没有其他方法来处理错误时。因为一旦调用这个函数，你的应用将不会有机会进行任何形式的清理工作，比如关闭文件句柄、数据库连接等。</p><p>举例来说，假设你正在编写一个原生插件来读取某种特殊格式的文件，而这种格式的解析库只提供了 C++ 接口。在解析文件的过程中，如果发现了一个根本无法解析的错误（比如文件已损坏到无法修复的地步），你就可以使用 <code>napi_fatal_error</code> 来报告这个问题：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void readFileAndParse(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 假设 params 包含了我们需要的参数</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (file_is_corrupted(params)) {</span></span>
<span class="line"><span>        // 如果文件损坏了，并且我们无法处理这个错误</span></span>
<span class="line"><span>        const char* location = &quot;readFileAndParse&quot;;</span></span>
<span class="line"><span>        const char* message = &quot;The file is corrupted and cannot be read.&quot;;</span></span>
<span class="line"><span>        napi_fatal_error(location, NAPI_AUTO_LENGTH, message, NAPI_AUTO_LENGTH);</span></span>
<span class="line"><span>        // 调用 napi_fatal_error 后，下面的代码不会被执行</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 正常的文件处理代码</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请记住，<code>napi_fatal_error</code> 应该是最后的手段。在大多数情况下，优雅地处理错误（如返回异常给 JavaScript）是更好的做法，因为这允许你的应用有机会恢复或至少以适当的方式退出。</p><h2 id="object-lifetime-management" tabindex="-1"><a class="header-anchor" href="#object-lifetime-management"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#object-lifetime-management" target="_blank" rel="noopener noreferrer">Object lifetime management</a></span></a></h2><p>在 Node.js 中，N-API 是一个用于构建本地插件的 API。它允许你使用 C 或者 C++ 代码来写扩展，这些扩展可以直接与 Node.js 的运行时交互。而“对象生命周期管理”指的是在这个上下文中如何管理 JavaScript 对象和本地资源（C/C++ 分配的内存）的创建、使用和销毁。</p><p>在编写 N-API 扩展时，需要格外注意不要造成内存泄露或野指针。这就需要妥善管理你创建的对象的生命周期。Node.js 的垃圾回收器负责管理 JavaScript 对象的生命周期，但对于本地资源并不会自动管理。因此，N-API 提供了一系列的函数来帮助控制本地资源的生命周期。</p><h3 id="引用-reference" tabindex="-1"><a class="header-anchor" href="#引用-reference"><span>引用 (Reference)</span></a></h3><p>在 N-API 中，你可以创建对 JavaScript 对象的引用。这种引用保证了对象不会被垃圾回收器回收，直到你明确地告诉它这样做。引用分为两种：</p><ul><li>强引用 (<code>napi_ref</code>): 当你创建一个强引用时，相应的对象将保持活跃状态，不会被垃圾回收器回收。</li><li>弱引用 (<code>napi_weakref</code>): 弱引用不会阻止对象被回收。当你只想要知道对象是否还活着，但不想影响其生命周期时，可以使用弱引用。</li></ul><h3 id="实际例子-4" tabindex="-1"><a class="header-anchor" href="#实际例子-4"><span>实际例子</span></a></h3><p>假设你正在编写一个 Node.js 模块，该模块需要从 JavaScript 创建一个大型的数据缓存，并将其传递给 C++ 的某个库去处理。</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你即将存储 JavaScript 对象引用的变量</span></span>
<span class="line"><span>napi_ref myObjectRef;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将一个 JavaScript 对象保存为一个强引用，使其不会被回收</span></span>
<span class="line"><span>void CreateStrongReference(napi_env env, napi_value object) {</span></span>
<span class="line"><span>    // 创建一个新的强引用</span></span>
<span class="line"><span>    napi_status status = napi_create_reference(env, object, 1, &amp;myObjectRef);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误 ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当你不再需要那个对象时，可以删除引用以允许垃圾回收器回收它</span></span>
<span class="line"><span>void DeleteReference(napi_env env) {</span></span>
<span class="line"><span>    napi_delete_reference(env, myObjectRef);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们首先定义了一个全局变量 <code>myObjectRef</code> 来存储对象的引用。然后有两个函数：<code>CreateStrongReference</code> 用于创建一个强引用，它接受一个 JavaScript 对象，并确保它不会被垃圾回收器回收；<code>DeleteReference</code> 用于释放引用，这样垃圾回收器就可以正常地回收对象了。</p><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><p>当你使用 N-API 管理对象生命周期时，以下几点非常重要：</p><ol><li><p><strong>平衡创建和删除引用</strong>：每次调用 <code>napi_create_reference</code> 后，都应该在适当的时机调用 <code>napi_delete_reference</code>。否则可能导致内存泄漏。</p></li><li><p><strong>遵循最佳实践</strong>：避免保留不必要的引用，尤其是强引用，因为它们会影响垃圾回收器的工作，可能导致更多的内存消耗。</p></li><li><p><strong>线程安全</strong>：在多线程环境中使用 N-API 时，确保相关操作是线程安全的。</p></li></ol><p>综上所述，对象生命周期管理在使用 N-API 编写本地扩展时至关重要，合理地管理不仅可以避免内存泄漏，还能确保程序的性能。</p><h3 id="making-handle-lifespan-shorter-than-that-of-the-native-method" tabindex="-1"><a class="header-anchor" href="#making-handle-lifespan-shorter-than-that-of-the-native-method"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#making-handle-lifespan-shorter-than-that-of-the-native-method" target="_blank" rel="noopener noreferrer">Making handle lifespan shorter than that of the native method</a></span></a></h3><p>在 Node.js 中，N-API 是一个用来构建原生插件的 API。它允许你使用 C/C++代码与 Node.js 的 JavaScript 引擎交互，以此可以创建性能更优的模块或者直接调用系统级别的 API。</p><p>由于 JavaScript 和 C/C++ 在内存管理上有很大的不同，N-API 提供了一套处理这些差异的机制。特别地，在 N-API 中，我们经常需要创建“句柄”（handle），这是指向 JavaScript 对象的引用，通过这些句柄我们可以在 C/C++ 代码中操作 JavaScript 对象。</p><p>然而，在某些情况下，句柄的生命周期可能会比它所关联的 C/C++原生方法更长。这就引入了潜在的问题：如果句柄太久没有被释放，它会保持对一个可能已经不再需要的 JavaScript 对象的引用，从而导致该对象无法被垃圾回收器回收，造成内存泄漏。</p><p>为了解决这个问题，Node.js v21.7.1 中 N-API 提供了一种方式来确保句柄不会比其对应的原生方法生命周期更长。具体来说，就是通过限制句柄的作用域，只让它存在于需要它的代码执行期间。</p><p>让我们举个例子:</p><p>假设我们正在编写一个原生模块，该模块负责从操作系统中获取系统时间，并将它返回给 JavaScript 代码。我们的 C++函数可能会看起来像这样:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`napi.h&gt;</span></span>
<span class="line"><span>#include `&lt;`time.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是一个N-API暴露给JS的函数</span></span>
<span class="line"><span>Napi::Value GetSystemTime(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>    Napi::Env env = info.Env();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取系统时间</span></span>
<span class="line"><span>    time_t current_time = time(nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这里创建一个句柄，这个句柄关联到一个新的JS Date对象</span></span>
<span class="line"><span>    Napi::Object dateObject = Napi::Date::New(env, static_cast`&lt;`double&gt;(current_time) * 1000);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回这个句柄，即返回Date对象给JS</span></span>
<span class="line"><span>    return dateObject;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 省略其他注册模块的代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>dateObject</code> 是一个句柄，它指向了一个新创建的 JavaScript <code>Date</code> 对象。当 <code>GetSystemTime</code> 函数执行完毕并返回这个 <code>Date</code> 对象之后，在 C++代码中，我们不再需要 <code>dateObject</code> 这个句柄了。N-API 的设计可以保证，一旦这个函数返回，除非 JavaScript 代码依然持有这个 <code>Date</code> 对象的引用（例如，把它赋值给一个变量），否则这个 <code>Date</code> 对象和 <code>dateObject</code> 句柄都可以被垃圾回收器回收，避免了内存泄漏。</p><p>总的来说，通过调整 N-API 中句柄的生命周期，使得它们不会比相关的原生方法活得更久，Node.js V21.7.1 帮助开发者更好地管理内存，防止内存泄漏的问题。这对于编写高效、稳定的原生扩展至关重要。</p><h4 id="napi-open-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-open-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_open_handle_scope" target="_blank" rel="noopener noreferrer">napi_open_handle_scope</a></span></a></h4><p>Node.js 中的 <code>napi_open_handle_scope</code> 是一个与 N-API（Node.js API）相关的功能。在深入了解这个函数之前，先解释一下几个概念，这样你可以更好地理解它的作用。</p><p><strong>N-API（Node API）</strong><br> N-API 是一个 C 语言的 API 层，它允许你编写能够跨不同版本 Node.js 运行的本地插件。使用 N-API 编写的本地插件不依赖于 V8 引擎的内部结构，因此当 Node.js 升级时，很可能无需修改代码就能继续工作。</p><p><strong>句柄（Handle）</strong><br> 在 Node.js 中，句柄是对 JavaScript 值的引用，它们在 N-API 中用于管理和维护 JavaScript 对象的生命周期。句柄使得 C/C++代码可以存储和操作 JavaScript 对象。</p><p><strong>句柄作用域（Handle Scope）</strong><br> 句柄作用域提供了一种限制句柄生命周期的方式，它可以确保在这个作用域结束时，所有创建的句柄都会被正确的清除。这有助于避免内存泄露。</p><p>现在，来看 <code>napi_open_handle_scope</code> 这个函数的作用：</p><ul><li>当一个本地插件（用 C 或 C++编写的代码）要与 JavaScript 交云时，它可能需要创建许多 JavaScript 对象。<code>napi_open_handle_scope</code> 用于创建一个新的句柄作用域。在这个作用域中，你可以安全地创建 JavaScript 对象并且与它们交互。</li><li>在执行完相关操作后，你需要调用 <code>napi_close_handle_scope</code> 函数来关闭作用域并且释放其中的句柄，以防止内存泄露。</li></ul><p><strong>实际运用例子：</strong></p><p>假设你正在编写一个本地插件，该插件提供了一个函数，用于创建一个新的 JavaScript 数组并且填充一些数据。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个简单的函数，用来创建一个JavaScript数组并且填充数据</span></span>
<span class="line"><span>napi_value CreateArray(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 开启一个新的句柄作用域</span></span>
<span class="line"><span>    napi_handle_scope scope;</span></span>
<span class="line"><span>    napi_open_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个空的JavaScript数组</span></span>
<span class="line"><span>    napi_value array;</span></span>
<span class="line"><span>    napi_create_array(env, &amp;array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 填充数组</span></span>
<span class="line"><span>    for (int i = 0; i `&lt;` 10; i++) {</span></span>
<span class="line"><span>        napi_value num;</span></span>
<span class="line"><span>        napi_create_int32(env, i, &amp;num);</span></span>
<span class="line"><span>        napi_set_element(env, array, i, num);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 关闭句柄作用域</span></span>
<span class="line"><span>    napi_close_handle_scope(env, scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的数组</span></span>
<span class="line"><span>    return array;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们首先开启了一个新的句柄作用域，然后创建了一个 JavaScript 数组，并通过一个循环向其中填充了整数 0 到 9。在完成这些操作后，我们关闭了句柄作用域，以确保所有在作用域中创建的句柄都得到适当的清理。最后，我们返回了这个数组，这样 JavaScript 代码就可以使用它了。</p><p>使用 <code>napi_open_handle_scope</code> 和 <code>napi_close_handle_scope</code> 可以帮助你编写出更稳健、内存高效的本地插件。</p><h4 id="napi-close-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-close-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_close_handle_scope" target="_blank" rel="noopener noreferrer">napi_close_handle_scope</a></span></a></h4><p><code>napi_close_handle_scope</code> 是一个函数，它属于 Node.js 的 N-API（Node.js API），这个 API 提供了一套用 C 语言编写本地插件的接口。在解释 <code>napi_close_handle_scope</code> 之前，我们需要先理解两个概念：<code>handle</code> 和 <code>handle scope</code>。</p><p>在 JavaScript 中，当你创建了一个对象、函数或者其他任何类型的值时，JavaScript 引擎会在内存中为其分配一个地址。在 C/C++ 插件代码中操作这些 JavaScript 值时，不能直接使用它们在内存中的地址，而是通过“句柄”(handles)来引用这些值。这样做的目的是为了确保垃圾回收机制能够正确地管理这些值的生命周期，防止内存泄露。</p><p><code>handle scope</code> 则是一个包含多个句柄的容器，当你在 C/C++ 代码中创建了很多 JavaScript 值时，这些值的句柄会被存放在一个<code>handle scope</code> 中。每个<code>handle scope</code>都有自己的生命周期，在这段时间内，可以安全地引用其中的句柄。</p><p>现在让我们来看看 <code>napi_close_handle_scope</code> 函数。这个函数用于关闭一个先前打开的 <code>handle scope</code>。每当你在 C/C++ 的 N-API 插件代码中完成了一系列与 JavaScript 值相关的操作，并且不再需要继续访问这些值时，就应该关闭相应的 <code>handle scope</code>。关闭 <code>handle scope</code> 可以告诉 Node.js 的垃圾回收机制，所有在这个 <code>handle scope</code> 中的句柄所引用的 JavaScript 值现在都可以被回收，如果它们不再被程序的其他部分所引用的话。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><p>为了具体说明，我们可以设想这样一个场景：</p><p>假设你正在编写一个 Node.js 的 C++ 插件，它需要创建多个新的 JavaScript 对象，并将它们传递给 Node.js 的 JavaScript 环境。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数模拟了一个可能会创建很多JavaScript对象的操作</span></span>
<span class="line"><span>napi_value CreateObjects(napi_env env) {</span></span>
<span class="line"><span>    napi_handle_scope scope;</span></span>
<span class="line"><span>    napi_open_handle_scope(env, &amp;scope); // 打开一个 handle scope</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 接下来创建一些 JavaScript 对象，比如：</span></span>
<span class="line"><span>    napi_value jsObject1, jsObject2;</span></span>
<span class="line"><span>    napi_create_object(env, &amp;jsObject1);</span></span>
<span class="line"><span>    napi_create_object(env, &amp;jsObject2);</span></span>
<span class="line"><span>    // ... 创建更多对象，并进行相关操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 完成所有操作后，我们不再需要维持这些对象的句柄：</span></span>
<span class="line"><span>    napi_close_handle_scope(env, scope); // 关闭 handle scope</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们要返回最后创建的对象给 JavaScript 环境</span></span>
<span class="line"><span>    return jsObject2;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册上面的函数作为一个模块导出</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_property_descriptor desc = { &quot;createObjects&quot;, 0, CreateObjects, 0, 0, 0, napi_default, 0 };</span></span>
<span class="line"><span>    napi_define_properties(env, exports, 1, &amp;desc);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>napi_open_handle_scope</code> 函数用于创建一个新的 <code>handle scope</code>。随后，我们可以安全地创建多个 JavaScript 对象。在这些操作完成后，通过调用 <code>napi_close_handle_scope</code> 来关闭 <code>handle scope</code>，这表明所有在此 <code>handle scope</code> 中创建的句柄所指向的对象现在可以被垃圾收集器回收。最后，<code>CreateObjects</code> 函数返回了一个 JavaScript 对象给 Node.js 环境。</p><p>注意，以上代码只是一个简化的例子，旨在帮助理解 <code>napi_close_handle_scope</code> 的用法。在实际的 N-API 插件开发中，还需要考虑错误处理和异常安全等因素。</p><h4 id="napi-open-escapable-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-open-escapable-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_open_escapable_handle_scope" target="_blank" rel="noopener noreferrer">napi_open_escapable_handle_scope</a></span></a></h4><p>当然，让我们深入了解 Node.js 中的 <code>napi_open_escapable_handle_scope</code> 函数。</p><p>首先，<code>N-API</code> 是 Node.js 提供的一个 API 层，允许你用 C 或 C++ 编写扩展。这些扩展可以直接与 Node.js 的底层 V8 JavaScript 引擎交互。这样做的好处之一是编写出来的模块不依赖于 V8 引擎的特定版本，也就是说，它们在 Node.js 的不同版本中更加稳定。</p><p>现在让我们聊聊 <code>handle scope</code>。在 V8（Node.js 使用的 JavaScript 引擎）中，大部分的 JavaScript 对象都是通过堆内存管理的。为了高效地回收这些对象，V8 使用了垃圾回收机制。<code>Handle scope</code> 是 V8 用来跟踪和管理 JavaScript 对象生命周期的机制之一。当你创建了很多局部 JavaScript 对象，并且希望这些对象在当前函数调用完成后能够有效地被垃圾回收器清理时，你会使用 <code>handle scope</code>。</p><p>那么 <code>napi_open_escapable_handle_scope</code> 具体是做什么的呢？简单来说，它创建了一个叫做 <code>escapable handle scope</code> 的新环境，它允许你临时保留一些 JavaScript 对象，即使当前的函数已经结束，这些对象也可以“逃离”这个作用域并被其他部分的代码继续使用。</p><p><strong>实际运用示例：</strong></p><p>假设你正在编写一个 Node.js 扩展来处理图像，你需要在 C++ 代码中创建一个表示图片的 JavaScript 对象，然后将这个对象传回给 Node.js 的调用者。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数会在某处被调用，以创建一个新的图片对象</span></span>
<span class="line"><span>napi_value CreatePictureObject(napi_env env) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_handle_scope scope;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 escapable handle scope</span></span>
<span class="line"><span>    status = napi_open_escapable_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在这个作用域中创建一个新的 JavaScript 对象</span></span>
<span class="line"><span>    napi_value pictureObj;</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;pictureObj);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ...设置对象的属性等...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // “逃逸”对象，这样它就可以被返回并由函数外部的代码所使用</span></span>
<span class="line"><span>    napi_value escaped_pictureObj;</span></span>
<span class="line"><span>    status = napi_escape_handle(env, scope, pictureObj, &amp;escaped_pictureObj);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 关闭 handle scope</span></span>
<span class="line"><span>    status = napi_close_escapable_handle_scope(env, scope);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return escaped_pictureObj; // 返回“逃逸”后的对象</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数可能会被暴露给 Node.js 代码调用</span></span>
<span class="line"><span>// ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们使用 <code>napi_open_escapable_handle_scope</code> 创建了一个可以从中“逃逸”的作用域。在这个作用域里，我们创建了一个新的对象 <code>pictureObj</code>，并且通过调用 <code>napi_escape_handle</code> 让这个对象在 <code>napi_close_escapable_handle_scope</code> 调用关闭作用域后仍然可以被使用。</p><p>这样，当你的 C++ 函数返回时，Node.js 的调用者就能够获取到这个 JavaScript 对象并与其交互，比如读取属性值或者调用对象上的方法。这是一个非常有用的机制，尤其是在您需要在原生代码中创建复杂对象并将它们传递回 JavaScript 环境时。</p><h4 id="napi-close-escapable-handle-scope" tabindex="-1"><a class="header-anchor" href="#napi-close-escapable-handle-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_close_escapable_handle_scope" target="_blank" rel="noopener noreferrer">napi_close_escapable_handle_scope</a></span></a></h4><p>当然，我会努力以通俗易懂的方式来解释这个概念。</p><p>在 Node.js 中，<code>napi_close_escapable_handle_scope</code>是一个函数，它属于 N-API（Node.js API）的一部分，这是一个用于构建本地插件的 API。为了理解<code>napi_close_escapable_handle_scope</code>，我们首先需要理解几个关键概念：句柄（handle），句柄作用域（handle scope）和可逃逸的句柄作用域（escapable handle scope）。</p><p><strong>句柄 (Handle)</strong>: 在 Node.js 的上下文中，句柄是一个引用，指向 JavaScript 值或对象。由于 Node.js 内部使用 V8 引擎来管理 JavaScript 代码，所以句柄实际上是对 V8 引擎中对象的引用。</p><p><strong>句柄作用域 (Handle Scope)</strong>: 为了管理内存，V8 引擎使用了一个概念叫做句柄作用域。一个句柄作用域可以包含很多句柄。当你在 C++扩展中创建 JavaScript 值时，这些值会被放入当前的句柄作用域。当该作用域结束时，如果这些 JavaScript 值没有被其他部分的代码引用，它们就会被垃圾收集器清除掉。这有助于防止内存泄漏。</p><p><strong>可逃逸的句柄作用域 (Escapable Handle Scope)</strong>: 这是一种特殊的句柄作用域。通常情况下，在句柄作用域内创建的值不能“逃逸”到外面的作用域，但在可逃逸的句柄作用域内，你可以指定某个值“逃逸”，这意味着即使这个作用域结束了，该值也不会被清理，而是可以继续被外部的代码所使用。</p><p>现在让我们看看<code>napi_close_escapable_handle_scope</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_close_escapable_handle_scope(napi_env env,</span></span>
<span class="line"><span>                                              napi_escapable_handle_scope scope);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数的作用是关闭一个可逃逸的句柄作用域。当你完成了在可逃逸的句柄作用域内的工作，并且已经标记了想要逃逸的值（如果有的话），你就应该调用这个函数来关闭作用域。</p><p><strong>例子</strong>: 假设你正在编写一个接收一个 JavaScript 数组，并返回数组中第一个元素的扩展。在这种情况下，你可能会创建一个可逃逸的句柄作用域，获取数组的第一个元素，并将其标记为逃逸。然后使用<code>napi_close_escapable_handle_scope</code>来结束作用域，同时保持对那个元素的引用。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 是有效的 napi_env</span></span>
<span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_escapable_handle_scope scope;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建可逃逸的句柄作用域</span></span>
<span class="line"><span>status = napi_open_escapable_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 假设你已经获取了数组的第一个元素 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将你希望逃逸的值标记为逃逸，确保它在作用域之外仍然有效</span></span>
<span class="line"><span>napi_value escaped_value;</span></span>
<span class="line"><span>status = napi_escape_handle(env, scope, array_element, &amp;escaped_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 关闭可逃逸的句柄作用域</span></span>
<span class="line"><span>status = napi_close_escapable_handle_scope(env, scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 此时，escaped_value 依然有效，可以返回给 JavaScript</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中：</p><ul><li><code>napi_open_escapable_handle_scope</code> 创建了一个新的可逃逸的句柄作用域。</li><li><code>napi_escape_handle</code> 标记了一个值使其能从作用域中逃逸。</li><li><code>napi_close_escapable_handle_scope</code> 结束了这个作用域，但允许标记为逃逸的值在作用域之外生存。</li></ul><p>请注意，这里的<code>status</code>变量用于检查每个 N-API 调用是否成功。在真正的代码中，你应该总是检查<code>status</code>并相应地处理错误。</p><p>希望这个解释有助于你理解<code>napi_close_escapable_handle_scope</code>函数及其在 Node.js 本地模块开发中的作用。</p><h4 id="napi-escape-handle" tabindex="-1"><a class="header-anchor" href="#napi-escape-handle"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_escape_handle" target="_blank" rel="noopener noreferrer">napi_escape_handle</a></span></a></h4><p>好的，让我们来详细了解一下 Node.js 中的 <code>napi_escape_handle</code>。</p><p>首先，<code>napi_escape_handle</code> 是一个属于 Node.js N-API（原生 API）的函数。N-API 是 Node.js 提供的一个 C 语言的 API 层，允许你使用 C 或者 C++编写扩展模块。这些扩展模块可以直接调用低级别的 API，与 V8 引擎（Node.js 运行时的核心）进行交互，而无需关心 Node.js 内部代码的具体实现细节。</p><p>在理解<code>napi_escape_handle</code>之前，我们需要知道什么是&quot;handle scope&quot;。在 Node.js 中，为了有效地管理 JavaScript 对象的内存，V8 使用了一种称作垃圾回收（GC）的机制。为了配合这个机制，V8 引入了所谓的&quot;handle scope&quot;：当你在 C/C++扩展中创建一个新的 JavaScript 对象时，它会被自动放入当前的 handle scope。当这个 scope 结束时，如果这个对象没有别的引用，它就可以被垃圾回收器清理掉。这样可以帮助防止内存泄漏。</p><p>然而，有时你可能希望一个 JavaScript 对象能够“逃逸”出当前的 handle scope，使其不受当前 scope 结束时垃圾回收的影响。这就是<code>napi_escape_handle</code>函数的作用。</p><p>举个实际的例子：<br> 想象你正在编写一个 Node.js 扩展，该扩展创建了一个 JavaScript 对象，并希望在未来某个时候，即便是在当前的 handle scope 已经结束后，也能再次访问到这个对象。你可以使用<code>napi_escape_handle</code>来保证这个对象在当前 scope 外仍然可用。</p><p>代码示例可能类似于以下情况：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设env是当前的环境标识，scope是你当前的handle scope</span></span>
<span class="line"><span>napi_handle_scope scope;</span></span>
<span class="line"><span>napi_open_handle_scope(env, &amp;scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个新的JavaScript对象</span></span>
<span class="line"><span>napi_value js_object;</span></span>
<span class="line"><span>napi_create_object(env, &amp;js_object); // 直接操作V8引擎创建对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你想让这个对象在scope外面也能访问到</span></span>
<span class="line"><span>napi_escapable_handle_scope escapable_scope;</span></span>
<span class="line"><span>napi_open_escapable_handle_scope(env, &amp;escapable_scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 通过napi_escape_handle让js_object逃逸出当前的handle scope</span></span>
<span class="line"><span>napi_value escaped_js_object;</span></span>
<span class="line"><span>napi_escape_handle(env, escapable_scope, js_object, &amp;escaped_js_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在即使关闭scope，escaped_js_object也不会被清除</span></span>
<span class="line"><span>napi_close_escapable_handle_scope(env, escapable_scope);</span></span>
<span class="line"><span>napi_close_handle_scope(env, scope);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 你现在可以在任何时候安全地使用escaped_js_object，因为它已经逃逸出了scope</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，<code>napi_open_handle_scope</code> 和 <code>napi_open_escapable_handle_scope</code> 用来分别打开普通的和可逃逸的 handle scopes。<code>napi_escape_handle</code> 则用于将<code>js_object</code>从<code>escapable_scope</code>中逃逸到外面，让它可以在<code>escapable_scope</code>和<code>scope</code>关闭后继续存在。这样做之后，<code>escaped_js_object</code>可以在其他地方被安全地使用，而不必担心它会被垃圾回收掉。</p><p>总结一下，<code>napi_escape_handle</code>是一个高级特性，主要用于在编写 C/C++扩展时，确保 JavaScript 对象可以在它们被创建的 handle scope 外部生存。这对于管理复杂的对象生命周期十分有用，尤其是在异步操作和回调函数中。</p><h3 id="references-to-values-with-a-lifespan-longer-than-that-of-the-native-method" tabindex="-1"><a class="header-anchor" href="#references-to-values-with-a-lifespan-longer-than-that-of-the-native-method"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#references-to-values-with-a-lifespan-longer-than-that-of-the-native-method" target="_blank" rel="noopener noreferrer">References to values with a lifespan longer than that of the native method</a></span></a></h3><p>在 Node.js 中，<code>N-API</code> 是一个用于构建原生插件的 API。原生插件是指直接使用 C 或 C++ 语言编写的模块，这些模块可以通过 Node.js 调用。这样做的理由通常是为了提高性能，或者是为了能使用某些只有在低级语言中才存在的功能。</p><p>在 JavaScript 中，当你创建一个对象或者函数，并且不再有任何引用指向它时，垃圾回收器将会自动释放该对象占用的内存。但在 C/C++ 中，管理内存的责任在于开发者，他们需要显式地分配和释放内存。</p><h3 id="引用与寿命" tabindex="-1"><a class="header-anchor" href="#引用与寿命"><span>引用与寿命</span></a></h3><p>当我们在 <code>N-API</code> 插件中处理 JavaScript 值时，可能会遇到一种情况：我们希望在原生代码中保持对 JavaScript 值的引用，即使当前的原生方法结束执行后也是如此。这是因为原生方法执行完毕后，按照 JavaScript 的垃圾回收机制，如果没有其他引用指向这个值，它可能就会被回收掉。</p><p>为了解决这个问题，<code>N-API</code> 提供了一种机制，允许我们在原生代码中创建对 JavaScript 值的<strong>强引用</strong>，这些引用保证了即使原生方法执行完毕，JavaScript 值也不会被垃圾回收器回收。</p><h3 id="实际运用示例-2" tabindex="-1"><a class="header-anchor" href="#实际运用示例-2"><span>实际运用示例</span></a></h3><p>假设你正在编写一个原生插件来处理图片。你在 JavaScript 端有一个图片的引用，而你想在后台进行一些长时间运行的图像处理工作。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是一个将被长时间运行的图像处理函数</span></span>
<span class="line"><span>void ProcessImageInBackground(napi_env env, void* data) {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>    // 这里我们执行一些耗时的图像处理操作</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value StartProcessingImage(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取传递给该函数的 JavaScript 图片对象</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个对该 JavaScript 图片对象的强引用</span></span>
<span class="line"><span>    napi_ref image_ref;</span></span>
<span class="line"><span>    status = napi_create_reference(env, args[0], 1, &amp;image_ref);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将图像处理任务放入后台线程</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_create_async_work(env, ... , ProcessImageInBackground, ... , &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 启动异步工作</span></span>
<span class="line"><span>    status = napi_queue_async_work(env, result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的伪代码中，<code>StartProcessingImage</code> 函数被调用时会启动一个图像处理的异步任务。由于这项任务将在后台线程中执行，我们需要确保所处理的 JavaScript 图片对象在整个处理过程中都是活跃的，不会被垃圾回收。为此，我们通过 <code>napi_create_reference</code> 创建了一个强引用。这个强引用将保留图片对象，直到我们主动删除这个引用，或者减少引用计数到零。</p><p>简单来说，这个特性让我们可以在原生插件中安全地持有 JavaScript 对象的引用，确保即使它们不再被 JS 代码直接引用，它们也不会在我们还需要它们的时候被垃圾回收。这对于实现复杂的异步操作和资源管理十分重要。</p><h4 id="napi-create-reference" tabindex="-1"><a class="header-anchor" href="#napi-create-reference"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_reference" target="_blank" rel="noopener noreferrer">napi_create_reference</a></span></a></h4><p>Node.js 中的 <code>napi_create_reference</code> 函数是一个 N-API 调用，它允许你在原生模块中创建一个对 JavaScript 对象的引用。这个函数主要用于管理原生代码与 JavaScript 代码之间对象的生命周期。</p><p>在详细解释这个函数之前，先了解一下几个关键概念：</p><ol><li><p><strong>N-API（Node API）</strong>：这是 Node.js 提供的一个稳定的 API 层，它允许你使用 C 或 C++ 编写扩展，而不必担心随 Node.js 版本变化导致的扩展不兼容问题。</p></li><li><p><strong>引用（Reference）</strong>：在编程中，引用通常是指向另一个对象的指针或者连接。在这种情况下，我们谈论的是指向 JavaScript 对象的引用。</p></li><li><p><strong>垃圾回收（Garbage Collection，GC）</strong>：JavaScript 有自动内存管理机制，当对象不再被需要时，垃圾回收器会自动释放它们占用的内存。但是，在原生模块中，我们可能需要确保某个对象在原生代码执行期间不会被 GC 清除。</p></li></ol><p>现在来看看 <code>napi_create_reference</code> 函数的用法和目的：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_reference(napi_env env,</span></span>
<span class="line"><span>                                  napi_value value,</span></span>
<span class="line"><span>                                  uint32_t initial_refcount,</span></span>
<span class="line"><span>                                  napi_ref* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：一个表示当前环境的句柄，在任何 N-API 调用中都需要。</li><li><code>value</code>：想要创建引用的 JavaScript 对象。</li><li><code>initial_refcount</code>：初始引用计数。如果你设置为 0，那么这个对象可以被垃圾回收；如果设置大于 0，那么对象会保持活跃状态直到引用计数降至 0。</li><li><code>result</code>：这将输出一个 <code>napi_ref</code> 句柄，代表了创建的引用。</li></ul><h3 id="实际运用的例子-3" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-3"><span>实际运用的例子：</span></a></h3><p>假设你正在编写一个 Node.js 的原生扩展，该扩展与某硬件设备进行交互，并且当硬件设备发出特定事件时，它应该调用一个 JavaScript 回调函数。你希望这个 JavaScript 回调函数在原生模块存活期间一直有效，即使它在 JavaScript 代码中已经没有其他引用了。这就是 <code>napi_create_reference</code> 发挥作用的地方。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设有个硬件事件监听器的结构体</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>    void (*on_event)(void); // 当硬件事件发生时的回调指针</span></span>
<span class="line"><span>} HardwareEventListener;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是在 JavaScript 调用原生模块来注册回调时的函数</span></span>
<span class="line"><span>napi_value RegisterCallback(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_ref callbackRef;</span></span>
<span class="line"><span>    // 创建对回调函数的引用，并将初始引用计数设置为 1，确保它不会被垃圾回收</span></span>
<span class="line"><span>    napi_create_reference(env, args[0], 1, &amp;callbackRef);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 存储回调引用以便稍后使用...</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当硬件事件发生时，这个函数将被调用</span></span>
<span class="line"><span>void OnHardwareEvent() {</span></span>
<span class="line"><span>    // 使用之前存储的 `callbackRef` 来获取 JavaScript 回调函数并调用它</span></span>
<span class="line"><span>    napi_value callback;</span></span>
<span class="line"><span>    napi_get_reference_value(env, callbackRef, &amp;callback);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value global;</span></span>
<span class="line"><span>    napi_get_global(env, &amp;global);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 JavaScript 回调函数</span></span>
<span class="line"><span>    napi_call_function(env, global, callback, 0, NULL, NULL);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册该事件监听器</span></span>
<span class="line"><span>void SetupHardwareListener(HardwareEventListener *listener) {</span></span>
<span class="line"><span>    listener-&gt;on_event = OnHardwareEvent;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个 <code>napi_ref</code> 引用来确保即使在 JavaScript 中没有其他引用，回调函数仍然不会被垃圾回收。这样，每当硬件事件发生时，我们都可以安全地调用这个 JavaScript 回调函数。</p><h4 id="napi-delete-reference" tabindex="-1"><a class="header-anchor" href="#napi-delete-reference"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_delete_reference" target="_blank" rel="noopener noreferrer">napi_delete_reference</a></span></a></h4><p>当然，我很乐意帮助你了解 <code>napi_delete_reference</code> 函数。</p><p>首先，我们需要知道 <code>N-API</code> 是 Node.js 提供的一个用于构建原生插件的 API 接口。原生插件允许开发者使用 C 或者 C++ 等语言来编写可以直接运行在操作系统级别的代码，这些代码可以被 Node.js 项目调用。通常这是为了实现一些 JavaScript 难以实现或者性能不佳的底层操作。</p><p>在 N-API 中，<code>napi_create_reference</code> 和 <code>napi_delete_reference</code> 这两个函数与 “引用” 相关。在这里，“引用” 指的是从原生代码（C/C++）持有对 JavaScript 对象的引用。当你在原生模块中创建了一个引用后，即使 JavaScript 代码已经没有任何变量指向该对象，垃圾回收器也不会释放它，因为它知道原生代码仍然需要它。</p><p>现在来看 <code>napi_delete_reference</code>：</p><ul><li><p><strong>函数目的</strong>：删除先前创建的对 JavaScript 值的强引用，通常是因为原生代码不再需要引用该值。删除引用后，如果没有其他活动引用指向该 JavaScript 值，则该值可能会在未来的垃圾回收过程中被清除。</p></li><li><p><strong>基本用法</strong>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_delete_reference(napi_env env, napi_ref ref);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>env</code> 参数是代表 N-API 调用环境的句柄，而 <code>ref</code> 是之前使用 <code>napi_create_reference</code> 创建的引用。</p></li><li><p><strong>例子</strong>：假设我们有一个原生模块，其中包含一个全局 JavaScript 函数的引用，一旦我们确定不再需要这个函数，就应该删除引用，以避免内存泄漏。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设在某处已经创建了一个引用</span></span>
<span class="line"><span>napi_ref my_function_ref; // 这是一个全局变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...等到不再需要这个函数时...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 删除引用，允许 JavaScript 垃圾回收器释放函数</span></span>
<span class="line"><span>napi_status status = napi_delete_reference(env, my_function_ref);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误情况</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 清空引用变量，表示它不再指向任何内容</span></span>
<span class="line"><span>my_function_ref = NULL;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>请注意，在实际的原生模块开发中，正确管理引用至关重要，以确保不会产生内存泄露。删除引用通常是在模块卸载时、对象不再需要时或者模块的生命周期结束时进行。</p><h4 id="napi-reference-ref" tabindex="-1"><a class="header-anchor" href="#napi-reference-ref"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_reference_ref" target="_blank" rel="noopener noreferrer">napi_reference_ref</a></span></a></h4><p>好的，让我们聊聊 Node.js 中的 <code>napi_reference_ref</code> 这个功能。</p><p>首先，为了理解 <code>napi_reference_ref</code>，你需要知道一些关于 Node.js 和 N-API 的背景。</p><p>N-API 是 Node.js 的一个 C API，它允许本地插件（用 C 或 C++编写的代码）与 Node.js 的 JavaScript 引擎进行交互。这意味着开发人员可以使用其他编程语言编写能够与 JavaScript 代码无缝集成的模块。</p><p>在 JavaScript 中，有一个叫做垃圾回收（Garbage Collection，GC）的机制。这个机制会自动释放不再被程序使用的内存。但是，当你在 JavaScript 中使用由 N-API 创建的本地资源时，默认情况下，垃圾回收器不知道如何处理这些资源。因此，如果不适当地管理这些资源，就可能出现内存泄露。</p><p>现在来到 <code>napi_reference_ref</code>。这个函数与管理 N-API 中的对象引用计数有关。当你在本地代码中创建一个对 JavaScript 对象的引用，你需要确保即使 JavaScript 的垃圾回收想要清理这个对象，这个对象也不会被销毁，直到你的本地代码完成使用它。通过增加引用计数，你实际上是在告诉垃圾回收器：“嘿，我还在用这个对象，所以请不要删除它。”</p><p>具体来说，<code>napi_reference_ref</code>函数会增加一个引用的引用计数。每次调用这个函数，关联的对象就更难被垃圾回收器回收，直到相应数量的 <code>napi_reference_unref</code> 被调用来减少引用计数。</p><p>举个例子：</p><p>假设你正在编写一个本地插件，该插件保存了一个 JavaScript 对象的引用，以便随后使用。你会这样使用 <code>napi_reference_ref</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_ref ref;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 `env` 是当前的环境句柄, `object` 是已经创建的N-API中的对象句柄</span></span>
<span class="line"><span>status = napi_create_reference(env, object, 1, &amp;ref);</span></span>
<span class="line"><span>// 检查状态是否正常...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在，你想要增加引用的引用计数，确保对象不会被垃圾收集器回收</span></span>
<span class="line"><span>int32_t ref_count;</span></span>
<span class="line"><span>status = napi_reference_ref(env, ref, &amp;ref_count);</span></span>
<span class="line"><span>// 检查状态是否正常...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 做一些工作...</span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 如果你完成了对该对象的使用，可以减少引用计数</span></span>
<span class="line"><span>status = napi_reference_unref(env, ref, &amp;ref_count);</span></span>
<span class="line"><span>// 检查状态是否正常...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当引用计数减少至0时，对象可以被垃圾回收器回收</span></span>
<span class="line"><span>if (ref_count == 0) {</span></span>
<span class="line"><span>    status = napi_delete_reference(env, ref);</span></span>
<span class="line"><span>    // 检查状态是否正常...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码段演示了如何创建一个引用(<code>napi_create_reference</code>)，增加引用计数 (<code>napi_reference_ref</code>)，减少引用计数 (<code>napi_reference_unref</code>)，并在不再需要时删除引用 (<code>napi_delete_reference</code>)。</p><p>简而言之，<code>napi_reference_ref</code> 在 N-API 中是用来帮助你管理本地代码中 JavaScript 对象的生命周期，以避免在本地插件与 JavaScript 之间的互操作过程中出现内存问题。</p><h4 id="napi-reference-unref" tabindex="-1"><a class="header-anchor" href="#napi-reference-unref"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_reference_unref" target="_blank" rel="noopener noreferrer">napi_reference_unref</a></span></a></h4><p>好的，首先让我简单解释一下 Node.js 和 N-API 是什么，然后再详细讲解 <code>napi_reference_unref</code> 这个函数。</p><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎的平台，允许你使用 JavaScript 来编写服务器端代码。N-API 则是 Node.js 提供的一套 C 语言 API，它允许本地插件（通常用 C 或 C++编写）与 JavaScript 代码交互。这意味着开发者可以在 JavaScript 中调用 C/C++ 代码，或在 C/C++ 代码中操作 JavaScript 对象。</p><p>现在，谈论 <code>napi_reference_unref</code> 函数。在 N-API 中，为了控制 JavaScript 对象的生命周期，你可以创建一个引用（reference）来保持对象活跃，防止它被垃圾回收机制回收。有时候你需要减少对这个对象的引用计数，说明你对这个对象的需求降低了，这就是 <code>napi_reference_unref</code> 函数的作用。</p><p>实际上，每当你用 <code>napi_create_reference</code> 创建对一个对象的新引用时，引用计数会增加。如果你想&quot;解除&quot;这个引用，你可以使用 <code>napi_reference_unref</code> 来减少引用计数。当引用计数降到 0 时，如果没有其他引用保持这个对象活跃，那么这个对象可能会在将来的某个时间点被垃圾回收。</p><p>这里是 <code>napi_reference_unref</code> 函数的签名：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_reference_unref(napi_env env, napi_ref ref, uint32_t* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code> 是一个表示 N-API 环境的句柄。</li><li><code>ref</code> 是你之前通过 <code>napi_create_reference</code> 创建的引用。</li><li><code>result</code> 是一个输出参数，当函数执行后，它会保存新的引用计数值。</li></ul><p>现在举一个简单的例子：</p><p>假设你编写了一个原生模块，该模块在初始化时创建了对一个特殊 JavaScript 对象的引用，并且希望在模块工作期间阻止该对象被垃圾回收。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设 obj 是一个你已经获得的 napi_value 表示的 JS 对象</span></span>
<span class="line"><span>napi_ref my_ref;</span></span>
<span class="line"><span>napi_status status = napi_create_reference(env, obj, 1, &amp;my_ref);</span></span>
<span class="line"><span>// 检查状态是否 OK，然后你的引用就被创建了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，某个时间点你决定不再需要这个引用，你可以像这样减少引用计数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>uint32_t ref_count;</span></span>
<span class="line"><span>status = napi_reference_unref(env, my_ref, &amp;ref_count);</span></span>
<span class="line"><span>// 检查状态，如果 OK，ref_count 将包含减少后的引用计数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果以后再也不需要这个对象，你可以完全删除这个引用：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>if (ref_count == 0) {</span></span>
<span class="line"><span>    status = napi_delete_reference(env, my_ref);</span></span>
<span class="line"><span>    // 检查状态，确保引用被正确删除</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>理解 <code>napi_reference_unref</code> 及其相关函数对于编写健壮且内存管理良好的原生模块是很重要的。记住，错误的引用计数管理可能导致内存泄漏或提早垃圾回收对象，这可能导致程序崩溃或不可预测的行为。</p><h4 id="napi-get-reference-value" tabindex="-1"><a class="header-anchor" href="#napi-get-reference-value"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_reference_value" target="_blank" rel="noopener noreferrer">napi_get_reference_value</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建本地插件的 API 层，它提供了从 JavaScript 代码中调用 C 或 C++ 函数的功能。使用 N-API 可以创建可以由 Node.js 调用的本机模块，这样可以提升性能或者允许你使用系统级别的特性。</p><p><code>napi_get_reference_value</code> 是 N-API 提供的一种函数，它用来从一个已经创建的引用中检索 JavaScript 值。在 Node.js 的本地插件开发中，我们时常需要保持对某些 JavaScript 对象的引用，以便后续使用或防止这些对象被垃圾回收器回收。为此，我们使用 N-API 创建引用，并通过 <code>napi_get_reference_value</code> 函数来获取这个引用所指向的实际 JavaScript 值。</p><p>下面我将解释 <code>napi_get_reference_value</code> 的基本使用方法，并给出一个简单的例子。</p><h3 id="使用步骤" tabindex="-1"><a class="header-anchor" href="#使用步骤"><span>使用步骤</span></a></h3><ol><li><strong>创建引用</strong>：首先，你需要有一个引用 (<code>napi_ref</code>) 指向一个 JavaScript 对象。这通常是通过 <code>napi_create_reference</code> 完成的。</li><li><strong>获取引用值</strong>：之后，你可以使用 <code>napi_get_reference_value</code> 来获取引用指向的那个 JavaScript 值。</li></ol><h3 id="函数签名-2" tabindex="-1"><a class="header-anchor" href="#函数签名-2"><span>函数签名</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_reference_value(napi_env env,</span></span>
<span class="line"><span>                                     napi_ref ref,</span></span>
<span class="line"><span>                                     napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：当前环境的句柄，它代表了 Node.js 运行时的上下文，用于处理所有 N-API 调用。</li><li><code>ref</code>：要获取其值的引用。</li><li><code>result</code>：指向 <code>napi_value</code> 的指针，该函数会将引用的 JavaScript 值赋给这个指针。</li></ul><h3 id="函数返回值" tabindex="-1"><a class="header-anchor" href="#函数返回值"><span>函数返回值</span></a></h3><ul><li>返回类型为 <code>napi_status</code>，它表示函数调用的状态。如果成功，会返回 <code>napi_ok</code>；如果失败，会返回错误代码。</li></ul><h3 id="示例-1" tabindex="-1"><a class="header-anchor" href="#示例-1"><span>示例</span></a></h3><p>假设我们想要创建一个本地模块，该模块保持对某个 JavaScript 对象的引用，并且希望在未来某个时间点再次获取这个对象：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假定有一个全局变量保存引用</span></span>
<span class="line"><span>napi_ref global_ref;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建引用的函数</span></span>
<span class="line"><span>napi_value CreateReference(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value argv[1];</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取传入的JavaScript对象</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Failed to parse arguments&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个弱引用，引用计数设置为1</span></span>
<span class="line"><span>  status = napi_create_reference(env, argv[0], 1, &amp;global_ref);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Failed to create reference&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return argv[0];</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取引用对象的函数</span></span>
<span class="line"><span>napi_value GetReferenceValue(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 使用global_ref获取JavaScript对象</span></span>
<span class="line"><span>  status = napi_get_reference_value(env, global_ref, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Failed to get reference value&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回JavaScript层面的对象</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化模块...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了两个函数：<code>CreateReference</code> 和 <code>GetReferenceValue</code>。<code>CreateReference</code> 接收一个 JavaScript 对象，并创建一个引用。然后，我们可以在任意时间点，通过 <code>GetReferenceValue</code> 函数来获取这个引用所指向的原始 JavaScript 对象。</p><h3 id="注意事项-1" tabindex="-1"><a class="header-anchor" href="#注意事项-1"><span>注意事项</span></a></h3><ul><li>使用引用时需要注意适当管理它们的生命周期，避免内存泄露。</li><li>引用可以是强引用或弱引用，区别在于它是否阻止垃圾回收器回收其指向的 JavaScript 对象。</li></ul><p>以上就是 <code>napi_get_reference_value</code> 在 Node.js N-API 中的基本介绍和一个简单的示例。希望这有助于你理解如何在本地插件中处理 JavaScript 对象的引用。</p><h3 id="cleanup-on-exit-of-the-current-node-js-environment" tabindex="-1"><a class="header-anchor" href="#cleanup-on-exit-of-the-current-node-js-environment"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#cleanup-on-exit-of-the-current-nodejs-environment" target="_blank" rel="noopener noreferrer">Cleanup on exit of the current Node.js environment</a></span></a></h3><p>Node.js 中的&quot;N-API&quot;是一个用于构建本地插件（native addons）的 API。本地插件是一些用 C, C++等语言编写的模块，它们可以直接与 Node.js 的 JavaScript 运行时进行交互。使用本地插件，你可以执行一些需要更高性能或者需要直接访问系统资源的任务。</p><p>在 Node.js v21.7.1 版本中，“Cleanup on exit of the current Node.js environment”指的是当 Node.js 进程退出时，相关的 N-API 资源会被清理掉。这意味着如果你的 Node.js 应用程序正在使用本地插件，并且创建了一些通过 N-API 创建的对象，那么当 Node.js 进程结束时（例如，你关闭了服务器），这些对象所占用的资源会自动被释放，防止内存泄漏。</p><p>具体来说，这个特性涉及到如何处理各种回调和钩子(hooks)，以确保当 Node.js 环境终止时，任何未完成的任务都能正确地清理干净，从而避免内存泄露和其他潜在问题。这通常会在如下情况中发生：</p><ul><li>当 Node.js 由于异常错误而退出时。</li><li>当 Node.js 正常关闭时，比如调用<code>process.exit()</code>。</li></ul><p>实际运用的例子可能包括：</p><ol><li><p><strong>数据库连接插件</strong>: 如果你使用一个本地插件来管理数据库连接，那么在 Node.js 退出时，所有的数据库连接都会被自动关闭，防止出现连接没有正确结束的情况。</p></li><li><p><strong>文件操作插件</strong>: 假设你有一个本地插件用于执行文件 I/O 操作，在 Node.js 结束时，所有打开的文件描述符会被关闭，确保没有文件被意外留在打开状态中。</p></li><li><p><strong>硬件接口插件</strong>: 如果你的 Node.js 应用程序与某些硬件设备进行通信，比如通过串口与传感器交互，那么在退出时，相关的硬件资源也会被适当释放。</p></li></ol><p>要点是，N-API 提供了一组稳定的 APIs，使得本地插件的开发者不需要对每一个 Node.js 的新版本都做适配，同时确保了 Node.js 环境退出时资源能够得到正确的清理。这样的设计既方便了开发者，也提高了程序的稳定性和安全性。</p><h4 id="napi-add-env-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-add-env-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_add_env_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_add_env_cleanup_hook</a></span></a></h4><p>好的，首先来简单介绍一下 Node.js 和 N-API 是什么，然后我会详细解释 <code>napi_add_env_cleanup_hook</code> 这个函数及其应用。</p><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行环境，它允许我们在服务器上运行 JavaScript 代码。Node.js 的特点是异步和非阻塞 IO，这使得它非常适合处理大量并发连接，例如在网络服务器或与数据库的交互中。</p><p>N-API 是 Node.js 的一个稳定的 API 层，用于构建原生插件。原生插件是用 C 或 C++ 写的模块，可以直接调用系统级别的 API，比如操作文件系统或者创建网络连接。N-API 的作用是提供一组稳定、版本无关的接口，允许原生插件代码与 Node.js 进行交互，而不必担心底层 JavaScript 引擎的变化。</p><p>现在，让我们来看看 <code>napi_add_env_cleanup_hook</code> 这个函数。</p><p><code>napi_add_env_cleanup_hook</code> 函数用于注册一个回调函数，这个回调函数将在 Node.js 环境即将销毁时被调用。这通常发生在 Node.js 应用程序即将退出时，或者当某个特定的 Node.js 工作线程（例如在 worker_threads 模块中）即将结束时。</p><p>为什么需要这个功能呢？</p><p>当你创建原生插件时，可能会分配一些资源，例如内存、文件描述符或其他操作系统资源。如果这些资源在插件生命周期结束时没有正确地清理，可能会导致资源泄露。使用 <code>napi_add_env_cleanup_hook</code> 可以确保当 Node.js 环境结束时，你有机会释放这些资源，从而避免资源泄露。</p><p>下面是 <code>napi_add_env_cleanup_hook</code> 的基本用法示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是你希望在环境清理时执行的函数</span></span>
<span class="line"><span>void cleanup(void* arg) {</span></span>
<span class="line"><span>    // 释放资源，arg 是在注册回调时传递的任意数据</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，当你的插件被加载时执行</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 注册清理钩子</span></span>
<span class="line"><span>    napi_add_env_cleanup_hook(env, cleanup, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用 NODE_API_MODULE 宏注册你的插件</span></span>
<span class="line"><span>NODE_API_MODULE(your_module_name, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此代码中：</p><ol><li><code>cleanup</code> 函数是在 Node.js 环境终止前需要执行的清理逻辑。</li><li><code>Init</code> 函数是模块初始化时调用的入口点，在这里注册了清理钩子。</li><li><code>napi_add_env_cleanup_hook</code> 将 <code>cleanup</code> 函数注册为清理钩子，而第三个参数是可选的，可以传递给 <code>cleanup</code> 函数的数据。</li></ol><p>实际应用举例：</p><ul><li>如果你的插件打开了文件进行读写，你需要确保在退出前关闭这些文件。</li><li>如果你的插件启动了一个新的线程或进程，并在背后运行，你需要确保在清理钩子中停止并清理这些线程或进程。</li><li>如果你的插件分配了内存，可能需要在清理钩子中释放这些内存。</li></ul><p>总结一下，使用 <code>napi_add_env_cleanup_hook</code> 可以确保当 Node.js 环境结束时，原生插件有机会进行适当的资源回收和清理工作，这对于编写高效、不泄露资源的原生插件至关重要。</p><h4 id="napi-remove-env-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-remove-env-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_remove_env_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_remove_env_cleanup_hook</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建本机插件的 API。这个 API 设计得相对底层，提供了更直接地与 JavaScript 运行时和 V8 引擎交互的能力。N-API 旨在不仅跨 Node.js 版本提供稳定性，还降低向下兼容性问题，因此开发者可以编写一次代码，在多个版本的 Node.js 上运行。</p><p><code>napi_remove_env_cleanup_hook</code> 是 N-API 中的一个函数，它的作用是移除之前使用 <code>napi_add_env_cleanup_hook</code> 函数注册的环境清理钩子（cleanup hook）。所谓“环境清理钩子”是指当 Node.js 环境正在销毁时将要执行的函数，它们通常用来释放资源，比如关闭文件描述符、解除内存分配等。</p><p>现在，让我们以通俗易懂的方式进行解释：</p><p>想象你参加了一个聚会，在聚会结束之前，你说：“聚会结束时候我会帮忙收拾桌子。”你的这个承诺就类似于一个“清理钩子”，聚会主办方会记住这个承诺，并在聚会结束时调用它，即告诉你去执行收拾桌子的工作。</p><p>但是如果在聚会结束之前，你不得不提前离开，你可能需要告知主办方：“嘿，我得走了，所以请别指望我来收拾桌子。”这样，主办方就会从他们的待办列表中移除你的那项任务。在 Node.js 中，使用 <code>napi_remove_env_cleanup_hook</code> 就是执行这个“通知取消”的动作。</p><p>实际使用的例子:</p><p>假设你编写了一个 Node.js 的本地插件，它打开了一个文件，并且在 Node.js 环境清理时需要确保这个文件被正确关闭。你可能首先会用 <code>napi_add_env_cleanup_hook</code> 添加一个清理钩子来关闭这个文件。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设有这样一个关闭文件的函数</span></span>
<span class="line"><span>void close_file(void* arg) {</span></span>
<span class="line"><span>  // ... 关闭文件的代码 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册清理钩子</span></span>
<span class="line"><span>napi_status status = napi_add_env_cleanup_hook(env, close_file, nullptr);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在设想，随着代码的运行，出于某种原因，你的插件在 Node.js 环境结束之前已经关闭了文件，并且你确定不再需要在环境清理时执行这个钩子。这时，你就可以使用 <code>napi_remove_env_cleanup_hook</code> 来移除之前设置的清理钩子。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 移除清理钩子</span></span>
<span class="line"><span>status = napi_remove_env_cleanup_hook(env, close_file, nullptr);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结起来，<code>napi_remove_env_cleanup_hook</code> 的作用就是为了撤销那些不再需要在 Node.js 环境结束时执行的任务，以确保资源得到正确的管理和释放。</p><h4 id="napi-add-async-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-add-async-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_add_async_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_add_async_cleanup_hook</a></span></a></h4><p>Node.js 中的 N-API 是一个 C 语言的 API 层，它允许你编写原生插件。原生插件是一些用 C 或 C++等编程语言编写的模块，可以直接调用底层操作系统的 API 或者执行一些 JavaScript 引擎不能直接执行的计算密集型任务。</p><p>在 Node.js 中，有时候我们会启动一些异步操作，比如读取文件、发送网络请求等。这些操作通常由 Node.js 后台的线程池处理。但是如果你正在编写一个原生模块，可能需要在自己的代码中创建额外的资源，比如动态分配内存、打开文件句柄或数据库连接等。当 Node.js 的进程退出时，你需要确保清理这些资源，以避免内存泄露或其他问题。</p><p><code>napi_add_async_cleanup_hook</code>函数正是为了解决这个问题而存在。它可以注册一个回调函数，当 Node.js 的异步操作即将完成并且进程准备退出时，这个回调函数会被调用。这样，你就可以在回调函数中做一些清理工作。</p><p>使用<code>napi_add_async_cleanup_hook</code>的具体步骤如下：</p><ol><li><p><strong>定义清理函数</strong>: 创建一个函数，这个函数包含了你要执行的清理逻辑。</p></li><li><p><strong>注册清理钩子</strong>: 在你的原生模块的合适位置调用<code>napi_add_async_cleanup_hook</code>，将你的清理函数和任何需要传递给它的数据作为参数提供给这个 API。</p></li><li><p><strong>执行清理</strong>: 当 Node.js 准备退出或者模块被卸载时，该清理函数会被调用。</p></li></ol><p>下面是一个简化的例子来说明这个过程：</p><p>首先，你将定义一个清理函数，例如用于关闭文件描述符：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void cleanup_file_descriptor(void* arg) {</span></span>
<span class="line"><span>    int fd = *(int*)arg;</span></span>
<span class="line"><span>    close(fd); // 假设这是一个关闭文件描述符的标准库函数</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在你的模块初始化或者创建资源时，你将注册这个清理钩子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_env env; // N-API环境变量，通常从函数参数获得</span></span>
<span class="line"><span>int* fd_ptr = malloc(sizeof(int)); // 动态分配内存存放文件描述符</span></span>
<span class="line"><span>// ... 你的代码打开文件，并将结果存储在fd_ptr指向的内存中</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册清理钩子</span></span>
<span class="line"><span>napi_status status = napi_add_async_cleanup_hook(env, cleanup_file_descriptor, fd_ptr, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，无论何时你的模块被卸载或者 Node.js 进程退出，<code>cleanup_file_descriptor</code>都会被调用来关闭文件和释放资源。</p><p>请注意，你需要处理好所有可能的边界情况，比如清理函数被调用时资源已经清理过了，或者在异步操作尚未完成时进程退出等情况。正确地管理资源是编写可靠和高效原生模块的关键部分。</p><h4 id="napi-remove-async-cleanup-hook" tabindex="-1"><a class="header-anchor" href="#napi-remove-async-cleanup-hook"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_remove_async_cleanup_hook" target="_blank" rel="noopener noreferrer">napi_remove_async_cleanup_hook</a></span></a></h4><p>好的，让我来解释一下 Node.js 中的 <code>napi_remove_async_cleanup_hook</code> 是什么以及如何使用它。</p><p>首先，我们需要了解 N-API 是什么。N-API（Node.js API）是一个内置于 Node.js 的 C API 层，它让你可以用 C 或 C++ 编写扩展模块，并保证对 Node.js 不同版本的兼容性。简单来说，它允许开发者编写可跨 Node.js 版本运行的原生插件。</p><p>现在，谈论 <code>napi_remove_async_cleanup_hook</code> 这个函数，它是 N-API 的一部分。此函数用于移除之前通过 <code>napi_add_async_cleanup_hook</code> 添加的异步清理钩子（hook）。&quot;异步清理钩子&quot;是一种在异步操作完成时或 Node.js 环境被销毁时调用的函数，主要用于资源的清理工作。</p><p>为什么需要这样的机制？想象这样一个情况：你创建了一个原生插件，里面有些异步操作，比如文件读写、网络请求等。这些异步操作可能会使用到一些需要手动释放的资源，如动态分配的内存、打开的文件句柄等。如果你的插件在没处理完这些操作就被卸载了，就需要确保这些资源被正确地释放，避免内存泄漏等问题。这就是添加异步清理钩子的目的。</p><p>当你不再需要这些清理钩子时，就可以用 <code>napi_remove_async_cleanup_hook</code> 来删除它们。这通常发生在你确定异步操作已经完全清理干净，或者你的模块正在被卸载并且你想显式地进行清理。</p><p>举个实际的例子：</p><p>假设你的原生扩展模块中有一个异步操作，这个操作在背后打开了一个文件，并进行了一些读写操作。你会使用 <code>napi_add_async_cleanup_hook</code> 来注册一个回调函数，在这个回调函数中关闭文件句柄，并释放任何分配的内存。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设这是你的清理函数</span></span>
<span class="line"><span>void cleanup_file(void* arg) {</span></span>
<span class="line"><span>  // 这里我们关闭文件并释放内存</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在你的异步操作中，你添加了清理钩子</span></span>
<span class="line"><span>napi_status status = napi_add_async_cleanup_hook(env, cleanup_file, NULL, &amp;handle);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在某个时间点，你知道文件已经安全地关闭，相关资源也已经释放了，因此你不再需要清理钩子。这时你就可以调用 <code>napi_remove_async_cleanup_hook</code> 来移除它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 移除之前添加的清理钩子</span></span>
<span class="line"><span>napi_status remove_status = napi_remove_async_cleanup_hook(env, handle);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>总结一下，<code>napi_remove_async_cleanup_hook</code> 是 N-API 提供的一种机制，让你能够管理和移除在原生模块中添加的资源清理回调，保证资源得到妥善处理。在实际使用中，它帮助你控制何时停止监听和执行清理工作，特别是在你确认资源已经被清理或者模块即将卸载时非常有用。</p><h3 id="finalization-on-the-exit-of-the-node-js-environment" tabindex="-1"><a class="header-anchor" href="#finalization-on-the-exit-of-the-node-js-environment"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#finalization-on-the-exit-of-the-nodejs-environment" target="_blank" rel="noopener noreferrer">Finalization on the exit of the Node.js environment</a></span></a></h3><p>Node.js 是一个运行在服务器端的 JavaScript 环境，它允许开发者使用 JavaScript 来编写服务器端代码。在 Node.js 中有一个名为 N-API 的接口，它允许原生模块（通常是用 C 或 C++ 写的扩展）与 JavaScript 代码进行交互。</p><p>在 N-API 中，“Finalization”一词指的是一个对象的清理过程，即当该对象不再需要时，将其占用的资源进行释放的过程。这在处理原生资源如文件句柄、网络连接或者内存分配时尤为重要，以避免出现资源泄露，即这些资源没有被适当释放，导致内存等资源的浪费。</p><p>在 Node.js v21.7.1 的文档中提到的“Finalization on the exit of the Node.js environment”特指 Node.js 应用程序退出时触发的清理动作。这意味着当你的 Node.js 程序结束运行时，N-API 会确保所有注册了 finalizer 的原生对象都得到妥善处理，即使它们还没有显式地通过垃圾回收机制被清理。</p><p>这个功能的重要性在于，它保证了即便在异常情况下，比如程序崩溃或是由于其他原因提前退出时，仍然能够释放掉所有的原生资源。</p><p>让我们举几个实际的例子来说明这个概念：</p><ol><li><p><strong>数据库连接</strong>：<br> 假设你正在使用一个 Node.js 的数据库连接库来与数据库进行交互。每个数据库连接可能都会在系统中打开一个文件描述符或者维持一个网络套接字。当你的程序正常结束时，你可能会手动关闭这些连接。然而，如果程序非正常退出，比如由于一个未捕获的异常，那么没有执行清理代码的话，这些数据库连接可能就不会关闭。使用 N-API，并注册了正确的 finalizer，可以保证在 Node.js 环境退出时这些连接能够被关闭。</p></li><li><p><strong>临时文件清理</strong>：<br> 你的应用程序可能会创建临时文件来处理数据。在应用程序的正常工作流程中，这些临时文件在使用完之后会被删除。但是，如果程序意外退出，可能会留下这些没用的临时文件。通过在原生模块中设置 finalizer，无论程序正常还是异常退出，都能保证这些文件会在 Node.js 环境退出时被删除。</p></li><li><p><strong>自定义资源管理</strong>：<br> 如果你正在编写一个对外部硬件（例如 USB 设备）进行操作的原生模块，当 Node.js 环境退出时，你需要确保所有的硬件连接被正确断开，并且相关资源得到释放。设置 finalizer 可以帮助你在环境退出时执行必要的资源清理动作。</p></li></ol><p>总结一下：“Finalization on the exit of the Node.js environment”是关于确保在 Node.js 环境退出时，所有的原生资源都能够被正确释放的机制。这是一个重要的功能，因为它防止了资源泄露，保护了系统的健康和稳定性。</p><h2 id="module-registration" tabindex="-1"><a class="header-anchor" href="#module-registration"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#module-registration" target="_blank" rel="noopener noreferrer">Module registration</a></span></a></h2><p>Node.js 中的 Module registration（模块注册）是一个关键的过程，用于告诉 Node.js 有哪些模块可用，以及如何在需要时加载和使用这些模块。Node.js 使用 CommonJS 规范来组织和使用模块，而 N-API 是 Node.js 提供的一套稳定的 API，允许原生插件（通常是 C 或 C++编写的模块）与 Node.js 代码无缝地交互。</p><p>在 Node.js v21.7.1 中，我们可以使用 N-API 来创建原生插件，并通过模块注册将这些插件暴露给 Node.js 环境。让我们逐步详细了解这个过程：</p><h3 id="步骤-1-创建原生模块源文件" tabindex="-1"><a class="header-anchor" href="#步骤-1-创建原生模块源文件"><span>步骤 1: 创建原生模块源文件</span></a></h3><p>首先，你需要用 C 或 C++编写你的原生模块代码。比如，假设你想创建一个简单的原生模块<code>hello</code>, 它只做一件事：返回&quot;Hello, world!&quot;字符串。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value HelloMethod(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value greeting;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个JavaScript字符串 &quot;Hello, world!&quot;</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;Hello, world!&quot;, NAPI_AUTO_LENGTH, &amp;greeting);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return greeting;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个结构体定义了模块的属性和方法</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, HelloMethod, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将上面创建的函数设置为这个模块的属性 &quot;hello&quot;</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;hello&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码定义了一个函数<code>HelloMethod</code>，它会返回一个包含&quot;Hello, world!&quot;字符串的 JavaScript 值。然后在<code>Init</code>函数中，我们把<code>HelloMethod</code>作为模块的导出函数，使得当模块被加载时，可以通过<code>require</code>调用该函数。</p><h3 id="步骤-2-编译原生模块" tabindex="-1"><a class="header-anchor" href="#步骤-2-编译原生模块"><span>步骤 2: 编译原生模块</span></a></h3><p>要使用这个原生模块，它必须被编译成 Node.js 可以加载的格式（通常是<code>.node</code>文件）。这通常是通过工具像<code>node-gyp</code>来完成的。你需要一个<code>binding.gyp</code>文件来告诉<code>node-gyp</code>如何编译你的模块。</p><h3 id="步骤-3-加载和使用模块" tabindex="-1"><a class="header-anchor" href="#步骤-3-加载和使用模块"><span>步骤 3: 加载和使用模块</span></a></h3><p>编译完成后，你可以像使用普通的 JavaScript 模块一样在 Node.js 中使用你的原生模块。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> helloAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/hello.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">helloAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出 &quot;Hello, world!&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>require</code>加载原生模块后，你就可以调用模块中定义的函数，就像上面例子中的<code>helloAddon.hello()</code>。</p><h3 id="实际运用的例子-4" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-4"><span>实际运用的例子</span></a></h3><ul><li><strong>性能优化</strong>：如果你的 Node.js 应用中有特别计算密集型的任务，你可能会选择用 C++来实现这些部分以提高性能。</li><li><strong>系统级操作</strong>：比如你需要直接和操作系统底层 API 交互，那么原生模块会非常有用。</li><li><strong>第三方库的集成</strong>：如果存在某些没有 JavaScript 版本但功能强大的 C/C++库，你可以通过编写原生插件来在 Node.js 中使用这些库。</li></ul><p>Node.js 的原生模块注册机制为开发者提供了强大的功能扩展能力，但同时也涉及到更复杂的编程知识，可能需要对 C/C++及操作系统有较深的理解。</p><h2 id="working-with-javascript-values" tabindex="-1"><a class="header-anchor" href="#working-with-javascript-values"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#working-with-javascript-values" target="_blank" rel="noopener noreferrer">Working with JavaScript values</a></span></a></h2><p>Node.js 是一个让 JavaScript 可以在服务器端运行的平台。在 Node.js 中，你可以编写 JavaScript 来操控服务器的功能，比如文件系统、网络通信等。当我们在 Node.js 中使用 JavaScript 编写代码时，我们经常需要处理各种数据值，例如字符串、数字、对象等。</p><p>为了更好地在原生模块中（由 C 或 C++编写的模块）与 JavaScript 的数据进行交互，Node.js 提供了一个 N-API，这是一个用于构建原生插件的 API。N-API 提供了一系列的函数，使得原生代码能够创建和操作 JavaScript 中的值。</p><p>以下是一些基本的 JavaScript 值操作和对应的例子：</p><ol><li><p>创建 JavaScript 赋值：<br> 在原生模块中，你可能需要创建一个新的 JavaScript 字符串或者数字，并将它返回给 JavaScript 环境。例如：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value create_number(napi_env env) {</span></span>
<span class="line"><span>    napi_value num;</span></span>
<span class="line"><span>    napi_status status = napi_create_double(env, 123.456, &amp;num);</span></span>
<span class="line"><span>    // 检查是否成功创建数字</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        return num; // 返回创建的数字</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们使用 <code>napi_create_double</code> 函数创建了一个 JavaScript 数字，并通过参数 <code>env</code>（表示当前的执行环境）和 <code>num</code>（用来存放创建的 JavaScript 数字）。</p></li><li><p>从 JavaScript 值中读取数据：<br> 如果你想从 JavaScript 环境传递给原生模块的数据中读取信息，你可以使用 N-API 提供的函数来做到。例如，如果你要读取一个从 JavaScript 传入的数字：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void read_number(napi_env env, napi_value js_value) {</span></span>
<span class="line"><span>    double value;</span></span>
<span class="line"><span>    napi_status status = napi_get_value_double(env, js_value, &amp;value);</span></span>
<span class="line"><span>    // 检查是否成功读取数值</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        printf(&quot;Received number: %f\n&quot;, value);</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>napi_get_value_double</code> 函数用于获取 JavaScript 传入的数值并存储在变量 <code>value</code> 中。</p></li><li><p>操作 JavaScript 对象：<br> JavaScript 中的对象是键值对的集合，在原生代码中，你也可以创建和修改这样的对象。例如，如果你要创建一个 JavaScript 对象并设置属性：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_object(napi_env env) {</span></span>
<span class="line"><span>    napi_value obj;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的空对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 添加一个属性“name”到对象中</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        napi_value name;</span></span>
<span class="line"><span>        status = napi_create_string_utf8(env, &quot;Node.js&quot;, NAPI_AUTO_LENGTH, &amp;name);</span></span>
<span class="line"><span>        if (status == napi_ok) {</span></span>
<span class="line"><span>            status = napi_set_named_property(env, obj, &quot;name&quot;, name);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查整个过程是否成功</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        return obj; // 返回创建的对象</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码首先创建了一个新的 JavaScript 对象 <code>obj</code>，然后创建了一个 JavaScript 字符串 <code>name</code>，最后，它将 <code>name</code> 添加到 <code>obj</code> 对象作为一个名为 <code>&quot;name&quot;</code> 的属性。</p></li></ol><p>通过以上示例，你可以看到 Node.js 中的 N-API 如何帮助我们在原生模块与 JavaScript 之间传递和操作数据。这使得 Node.js 可以被用于更加复杂和性能要求高的场景，因为原生模块通常比纯 JavaScript 代码执行得更快。</p><h3 id="enum-types" tabindex="-1"><a class="header-anchor" href="#enum-types"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#enum-types" target="_blank" rel="noopener noreferrer">Enum types</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。N-API 的目的是减少维护原生插件时 Node.js 版本更迭可能引发的问题，它提供了一套稳定的 API 集合，使得插件与 Node.js 版本之间更加解耦。</p><p>在 N-API 中的 Enum（枚举）类型是一种特殊的数据类型，它允许开发者定义一组命名的常量。使用枚举可以更清晰地表达代码的意图，并限制变量可以接受的值范围。</p><p>举个例子，让我们想象你正在编写一个原生插件来处理文件系统操作。在这种情况下，你可能需要处理不同类型的文件系统错误。通常，这些错误可以分成若干类别，例如 &quot;权限错误&quot;、&quot;路径不存在&quot; 和 &quot;盘满&quot; 等。使用枚举类型可以帮助你预先定义这些错误类别：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 定义枚举类型</span></span>
<span class="line"><span>enum FileSystemError {</span></span>
<span class="line"><span>  PERMISSION_ERROR,</span></span>
<span class="line"><span>  PATH_NOT_FOUND,</span></span>
<span class="line"><span>  DISK_FULL</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在你的代码中，你可以使用这些枚举值来表示特定的错误：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 使用枚举类型</span></span>
<span class="line"><span>FileSystemError errorType = PATH_NOT_FOUND;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (errorType == PATH_NOT_FOUND) {</span></span>
<span class="line"><span>  // 处理路径不存在的错误</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 N-API 中，有很多内置的枚举类型，它们代表了 Node.js 原生层面上各种不同的值和状态。例如，当创建异步工作队列项目或处理回调时，你会用到这样的枚举类型。这些枚举值在 N-API 文档中都有详细的描述。它们通常用来指示如何处理 JavaScript 值和原生函数调用的结果。</p><p>假设你要创建一个异步函数，这个函数需要在完成时返回其执行的结果，那么你可能会使用 <code>napi_status</code> 枚举来传递操作的结果状态：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个异步函数的示例，该函数在执行后会返回状态码</span></span>
<span class="line"><span>napi_value SomeAsyncFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...执行一些操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 跟据执行结果设置状态</span></span>
<span class="line"><span>  status = (执行成功) ? napi_ok : napi_generic_failure;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回状态码对应的JavaScript值</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  napi_create_int32(env, (int32_t)status, &amp;result);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>napi_status</code> 是 N-API 定义的一个枚举类型，其中包含了诸如 <code>napi_ok</code>, <code>napi_invalid_arg</code>, <code>napi_object_expected</code> 等等，用来指示函数调用的结果状态。在实际的异步函数中，你会根据操作的成功或失败，设置相应的枚举值，然后将这个值转换成 JavaScript 能够理解的形式，返回给调用者。这样的设计可以让你的原生插件与 JavaScript 代码之间有一个清晰的交互界面。</p><h4 id="napi-key-collection-mode" tabindex="-1"><a class="header-anchor" href="#napi-key-collection-mode"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_key_collection_mode" target="_blank" rel="noopener noreferrer">napi_key_collection_mode</a></span></a></h4><p>Node.js 中的 N-API (Native API) 是一个用于构建原生插件的 API，它让 JavaScript 代码能够和 C/C++代码交互，这样你就可以使用 C/C++来编写一些性能敏感或者需要直接与操作系统底层交互的部分，并且在 Node.js 环境中调用它们。</p><p><code>napi_key_collection_mode</code> 是 N-API 中的一个枚举类型，用于设定如何收集对于 Native 对象的 property keys。在 JavaScript 中，对象是由键值对组成的，而当我们从 C/C++代码中创建或操作 JavaScript 对象时，可能需要考虑到垃圾回收（Garbage Collection，简称 GC）的问题。</p><p>所以，<code>napi_key_collection_mode</code> 有以下两种模式：</p><ol><li><code>napi_key_include_prototypes</code>：这个模式意味着当收集对象的 keys 时，会包括该对象原型链上的 keys。</li><li><code>napi_key_own_only</code>：这个模式下，则只会收集对象自身的 keys，而不包括其原型链上的任何 keys。</li></ol><p>举个例子，假设你在 C/C++插件中创建了一个 JavaScript 对象，并且想要获取它的属性键列表。如果你选择<code>napi_key_include_prototypes</code>模式，你得到的列表将包括对象本身的 keys 加上它继承的所有 keys（例如，来自它的原型或<code>prototype</code>属性）。如果你选择<code>napi_key_own_only</code>，那么你只会得到对象自己的 keys，不包含继承的。</p><p>在实际的应用场景中，这个功能可能被用在插件需要详尽地检查 JavaScript 对象的情况下。比如，如果你正在编写一个插件来序列化一个 JavaScript 对象，那么你可能需要根据是否希望包括原型链上的属性来选择合适的<code>napi_key_collection_mode</code>。</p><p>这里是一个简化的示例代码片段（并非完整程序），它展示了如何在 C/C++中使用<code>napi_key_collection_mode</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 省略其他必须的函数和错误处理 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value GetOwnPropertyKeys(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的对象</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数数量和类型等...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个数组来存放对象的keys</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_property_names(env, args[0], &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置key collection mode为仅包括对象自身的keys</span></span>
<span class="line"><span>    status = napi_set_property_names_enum(env, args[0], napi_key_own_only);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 还有更多的流程和错误处理 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result; // 返回keys数组</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>GetOwnPropertyKeys</code>是一个函数，它试图从 Node.js 传入的对象中获取所有的自身属性 keys。我们首先获得了 JS 传递给我们的对象，然后使用<code>napi_get_property_names</code>获取属性 keys，并通过<code>napi_set_property_names_enum</code>设置我们想要的 key collection 模式。最终返回了一个包含所有自身属性 keys 的数组。</p><p>请注意，由于这个特性是 N-API 的一部分，它通常在相对底层的场景中使用，并且这里的代码只是为了解释<code>napi_key_collection_mode</code>是如何工作的，实际使用中需要考虑错误处理和内存管理等问题。</p><h4 id="napi-key-filter" tabindex="-1"><a class="header-anchor" href="#napi-key-filter"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_key_filter" target="_blank" rel="noopener noreferrer">napi_key_filter</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。一个原生插件是一个可以直接调用 C/C++代码的 JavaScript 模块，这使得开发者能够编写性能关键型操作，或是需要使用到系统底层功能的应用程序。</p><p>在 N-API 中有一个概念叫“属性键过滤”（Property Key Filtering），这涉及到在操作对象时筛选出哪些属性键（即对象的属性名）是我们感兴趣的。<code>napi_key_filter</code>是一个枚举类型，它定义了不同的筛选选项，让你能够更精准地控制哪些键被包含在某些特定 N-API 函数的操作中。</p><p>下面是一些<code>napi_key_filter</code>可能的选项：</p><ul><li><code>napi_key_all_properties</code>: 不进行过滤，包括所有的属性。</li><li><code>napi_key_own_only</code>: 只包括对象自己的属性，不包括从原型链继承的属性。</li><li><code>napi_key_writable</code>: 只包括可写的属性。</li><li><code>napi_key_enumerable</code>: 只包括可枚举的属性。</li><li><code>napi_key_skip_strings</code>: 跳过字符串键，只关注 Symbol 键。</li><li><code>napi_key_skip_symbols</code>: 跳过 Symbol 键，只关注字符串键。</li></ul><p>实际运用举例：</p><ol><li><p><strong>获取对象的所有自有属性</strong>:</p><p>如果你想获取一个对象上所有属于该对象本身的属性（不包括那些通过原型链继承来的），你可以结合使用<code>napi_key_own_only</code>和一些相关的 N-API 函数。</p></li><li><p><strong>枚举可写属性</strong>:</p><p>你可能正构建一个原生插件，需要复制一个 JavaScript 对象的属性到 C++对象中去。但你只希望复制那些可写的属性。在这种情况下，你可以使用<code>napi_key_writable</code>作为过滤器。</p></li><li><p><strong>避开 Symbols</strong>:</p><p>JavaScript 中的 Symbol 是唯一的，不能被常规字符串键污染。如果你的应用逻辑需要跳过处理 Symbol 键，你可以使用<code>napi_key_skip_symbols</code>。</p></li></ol><p>示例代码片段（并非完整程序）:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 和 object 是已经定义好的变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取对象的所有自有属性</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>napi_status status = napi_get_property_names(env, object, napi_key_own_only, &amp;result);</span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  // 使用 result 这里代表包含了所有自有属性的数组</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 此处的代码需要配合完整的N-API使用环境来工作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码示例仅用于说明如何在 C++中使用<code>napi_key_own_only</code>过滤器与 N-API 相结合进行操作。开发者需要提供完整的错误处理和环境设置代码以确保其正确运行。记住，这些接口是面向 C/C++开发者的，对于初学者来说可能需要较长时间去熟悉和理解。</p><h4 id="napi-key-conversion" tabindex="-1"><a class="header-anchor" href="#napi-key-conversion"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_key_conversion" target="_blank" rel="noopener noreferrer">napi_key_conversion</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行环境，它允许在服务器端运行 JavaScript 代码。N-API（Node API）是 Node.js 提供的一组 C API，使得本地插件（通常用 C 或 C++编写）可以不受特定版本 Node.js 影响地运行。</p><p><code>napi_key_conversion</code> 并不是 Node.js v21.7.1 中特定的功能，而是指 N-API 当中与键转换相关的多个函数。这些函数被用来将 JavaScript 中的对象属性名（keys）转换为适合本地插件使用的格式，或反之。在实际应用中，这使得 JavaScript 代码和本地插件能够相互交换数据。</p><p>举几个实际例子来说明：</p><ol><li><p><strong>读取 JavaScript 对象属性</strong>：你可能在 C/C++ 插件中需要读取一个从 JavaScript 传入的对象的属性。使用 N-API 中的键转换函数，你可以将 JavaScript 的字符串属性名转换为一个 N-API 可以理解的表示形式，然后获取该属性的值。</p></li><li><p><strong>设置 JavaScript 对象属性</strong>：相对地，如果你想在本地插件中创建或修改 JavaScript 对象的属性，你可以先将属性名转换为 N-API 的键表示，然后设置其值。</p></li><li><p><strong>处理 JavaScript Map 或 Set</strong>：当 JavaScript 的 Map 或 Set 数据结构与本地插件交互时，你可能需要将 JavaScript 的值转换为适当的键，以便在 C/C++ 插件中使用这些集合。</p></li></ol><p>请注意，由于我不能提供超出知识截止日期范围的具体信息，所述内容仅基于 Node.js 和 N-API 在该时间点之前的通用概念进行了解释。如需最新详情，请参考 Node.js 的官方文档。</p><h4 id="napi-valuetype" tabindex="-1"><a class="header-anchor" href="#napi-valuetype"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_valuetype" target="_blank" rel="noopener noreferrer">napi_valuetype</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。原生插件是可以直接与 Node.js 运行时进行交互的 C 或 C++代码模块，它们通常用于执行计算密集型任务或进行系统级操作，比如访问硬件。</p><p><code>napi_valuetype</code>是 N-API 提供的枚举类型之一，用于表示 JavaScript 值在原生代码中的类型。在 JavaScript 中，各种数据类型（如数字、字符串、对象等）都可以通过 N-API 在原生代码里有对应的表示方法。了解一个 JavaScript 值的具体类型对于原生插件的编写是非常重要的，因为不同的类型在原生层面上可能需要不同的处理方式。</p><h3 id="napi-valuetype-枚举" tabindex="-1"><a class="header-anchor" href="#napi-valuetype-枚举"><span><code>napi_valuetype</code> 枚举</span></a></h3><p>这个枚举包括了一系列预定义的值，每一个都代表了一个 JavaScript 值的类型。下面是一些例子：</p><ul><li><code>napi_undefined</code>: 表示 JavaScript 的<code>undefined</code>类型。</li><li><code>napi_null</code>: 表示 JavaScript 的<code>null</code>类型。</li><li><code>napi_boolean</code>: 表示 JavaScript 的布尔类型（<code>true</code>或<code>false</code>）。</li><li><code>napi_number</code>: 表示 JavaScript 的数值类型。</li><li><code>napi_string</code>: 表示 JavaScript 的字符串类型。</li><li><code>napi_symbol</code>: 表示 JavaScript 的 Symbol 类型。</li><li><code>napi_object</code>: 表示 JavaScript 的对象类型。</li><li><code>napi_function</code>: 表示 JavaScript 的函数类型。</li><li><code>napi_external</code>: 表示一个外部类型，这通常用于表示一个 C/C++数据结构绑定到一个 JavaScript 对象。</li></ul><h3 id="实际运用的例子-5" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-5"><span>实际运用的例子</span></a></h3><p>假设我们正在编写一个原生插件，并且我们想要获取从 JavaScript 传递给我们的值的类型。以下是如何使用<code>napi_valuetype</code>来确定一个 JavaScript 值的类型：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们已经有了一个napi_value类型的变量`value`代表一个JS传递过来的值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_valuetype valueType;</span></span>
<span class="line"><span>napi_status status = napi_typeof(env, value, &amp;valueType);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  switch (valueType) {</span></span>
<span class="line"><span>    case napi_undefined:</span></span>
<span class="line"><span>      // 处理undefined值</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_null:</span></span>
<span class="line"><span>      // 处理null值</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_boolean:</span></span>
<span class="line"><span>      // 处理布尔值</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_number:</span></span>
<span class="line"><span>      // 处理数值</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_string:</span></span>
<span class="line"><span>      // 处理字符串</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_symbol:</span></span>
<span class="line"><span>      // 处理Symbol</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_object:</span></span>
<span class="line"><span>      // 处理对象</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_function:</span></span>
<span class="line"><span>      // 处理函数</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    case napi_external:</span></span>
<span class="line"><span>      // 处理外部绑定的数据结构</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>    default:</span></span>
<span class="line"><span>      // 未知类型</span></span>
<span class="line"><span>      break;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>  // 处理获取类型失败的情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码展示了如何使用<code>napi_typeof</code>来获取一个<code>napi_value</code>对应的类型，并且根据这个类型执行不同的逻辑处理。 这在原生插件开发中是很常见的场景，特别是当你需要处理从 JavaScript 传递过来的多种类型的参数时。</p><p>通过正确地识别和处理不同的 JavaScript 值类型，原生插件就能够更安全和有效地执行其任务，并且能够更好地与 JavaScript 代码进行交互。</p><h4 id="napi-typedarray-type" tabindex="-1"><a class="header-anchor" href="#napi-typedarray-type"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_typedarray_type" target="_blank" rel="noopener noreferrer">napi_typedarray_type</a></span></a></h4><p>好的，让我们来详细了解一下 Node.js v21.7.1 中的 <code>napi_typedarray_type</code>。</p><p>首先，N-API 是 Node.js 提供的一个用于构建原生插件的 API。它允许你使用 C 或者 C++ 语言来编写可以直接和 JavaScript 交互的代码片段，这通常在性能要求比较高或者需要使用系统级资源的时候会非常有用。<code>napi_typedarray_type</code> 是 N-API 中的一个功能，用来获取一个 TypedArray 的类型。</p><p>TypedArray 是 JavaScript 中的一个特殊的数组对象，它提供了一个底层的二进制缓冲区（binary buffer），可以用来存储多种不同类型的数据，例如整数或浮点数，并且是以字节为单位操作。不同类型的 TypedArray 可以存储不同类型的值，比如 <code>Int32Array</code> 可以存储 32 位整数，<code>Float64Array</code> 可以存储 64 位浮点数等。</p><p>现在，当你在原生模块中处理一个从 JavaScript 传递过来的 TypedArray 时，你可能想知道它具体是什么类型的 TypedArray。这就是 <code>napi_typedarray_type</code> 发挥作用的地方。</p><p>举个例子，假设你正在编写一个 Node.js 原生模块，需要处理一个从 JavaScript 传递过来的 TypedArray，但你不确定它是 <code>Int32Array</code> 还是其他什么类型的 TypedArray。你可以使用 <code>napi_typedarray_type</code> 来查看：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 在某个原生函数中</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 参数 env 是 napi_env 类型，表示当前的环境上下文</span></span>
<span class="line"><span>// 参数 value 是 napi_value 类型，表示 JavaScript 传递给原生函数的 TypedArray 对象</span></span>
<span class="line"><span>void MyFunction(napi_env env, napi_value value) {</span></span>
<span class="line"><span>    // 用于存储查询结果的变量</span></span>
<span class="line"><span>    napi_typedarray_type type;</span></span>
<span class="line"><span>    size_t length;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span>    size_t offset;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 查询 TypedArray 的类型</span></span>
<span class="line"><span>    napi_status status = napi_get_typedarray_info(env, value, &amp;type, &amp;length, &amp;data, NULL, &amp;offset);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查 napi_get_typedarray_info 调用是否成功</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 根据得到的 type 值对应不同的类型</span></span>
<span class="line"><span>        switch (type) {</span></span>
<span class="line"><span>            case napi_int8_array:</span></span>
<span class="line"><span>                // 处理 Int8Array 类型的 TypedArray</span></span>
<span class="line"><span>                break;</span></span>
<span class="line"><span>            case napi_uint8_array:</span></span>
<span class="line"><span>                // 处理 Uint8Array 类型的 TypedArray</span></span>
<span class="line"><span>                break;</span></span>
<span class="line"><span>            // ... 其他 case 分支</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，通过调用 <code>napi_get_typedarray_info</code> 函数并传入 <code>napi_typedarray_type</code> 类型的指针 <code>&amp;type</code>，就可以查询出 TypedArray 的确切类型，并根据类型执行不同的操作。这样你就可以针对不同类型的 TypedArray 编写高效的数据处理逻辑了。</p><p>希望这个解释和示例能够帮助你理解 <code>napi_typedarray_type</code> 在 Node.js 中的运用。</p><h3 id="object-creation-functions" tabindex="-1"><a class="header-anchor" href="#object-creation-functions"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#object-creation-functions" target="_blank" rel="noopener noreferrer">Object creation functions</a></span></a></h3><p>Node.js v21.7.1 中的“Object creation functions”是指 Node.js 提供的一组用于创建和操作 JavaScript 对象的函数，它们都是基于 N-API（Node.js API）实现的。这些函数允许原生模块（通常用 C 或 C++编写）与 JavaScript 代码交互，即你可以在 C/C++代码中创建 JavaScript 对象，并将它们传递给 JavaScript 层面的代码。</p><p>N-API 是一个独立于 JavaScript 运行时的 API 层，旨在维护原生插件（native addons）的兼容性 across different versions of Node.js 和不同的 JavaScript engines 比如 V8 (Chrome), Chakra (Microsoft Edge), SpiderMonkey (Firefox), 等等。</p><p>下面我们来看几个具体的例子以理解 N-API 提供的对象创建函数的使用：</p><h3 id="_1-创建一个新的空对象" tabindex="-1"><a class="header-anchor" href="#_1-创建一个新的空对象"><span>1. 创建一个新的空对象</span></a></h3><p>在原生模块中，你可能想要创建一个新的空对象并返回给 JavaScript：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_empty_object(napi_env env) {</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_status status = napi_create_object(env, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // Handle error...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>napi_create_object</code>函数用于创建了一个新的空 JavaScript 对象。<code>env</code>参数是表示当前 N-API 环境的句柄，而<code>result</code>将会被赋值为新创建的对象。</p><h3 id="_2-创建一个具有属性的对象" tabindex="-1"><a class="header-anchor" href="#_2-创建一个具有属性的对象"><span>2. 创建一个具有属性的对象</span></a></h3><p>如果你想在对象中添加属性：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_object_with_properties(napi_env env) {</span></span>
<span class="line"><span>    napi_value obj;</span></span>
<span class="line"><span>    napi_status status = napi_create_object(env, &amp;obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置属性“name”为字符串“Node.js”</span></span>
<span class="line"><span>    napi_value name_string;</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;Node.js&quot;, NAPI_AUTO_LENGTH, &amp;name_string);</span></span>
<span class="line"><span>    status = napi_set_named_property(env, obj, &quot;name&quot;, name_string);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置属性“version”为数字21.7</span></span>
<span class="line"><span>    napi_value version_number;</span></span>
<span class="line"><span>    status = napi_create_double(env, 21.7, &amp;version_number);</span></span>
<span class="line"><span>    status = napi_set_named_property(env, obj, &quot;version&quot;, version_number);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // Handle error...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return obj;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们首先使用<code>napi_create_object</code>创建了一个空对象，然后使用<code>napi_create_string_utf8</code>创建了一个字符串，接着用<code>napi_set_named_property</code>将这个字符串设置为对象的属性。同样的过程也用来创建一个数值属性。</p><h3 id="_3-创建数组" tabindex="-1"><a class="header-anchor" href="#_3-创建数组"><span>3. 创建数组</span></a></h3><p>创建 JavaScript 数组的示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_array_with_numbers(napi_env env) {</span></span>
<span class="line"><span>    napi_value my_array;</span></span>
<span class="line"><span>    napi_status status = napi_create_array(env, &amp;my_array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 向数组中填充数字</span></span>
<span class="line"><span>    for (int i = 0; i `&lt;` 10; i++) {</span></span>
<span class="line"><span>        napi_value num;</span></span>
<span class="line"><span>        status = napi_create_int32(env, i, &amp;num);</span></span>
<span class="line"><span>        status = napi_set_element(env, my_array, i, num);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // Handle error...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return my_array;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>napi_create_array</code>用于创建一个新数组，<code>napi_set_element</code>用于设置数组元素。</p><p>这些只是简单的例子，但它们展示了如何使用 N-API 的对象创建函数在原生代码中操作 JavaScript 对象。这是构建高效且可跨多个 Node.js 版本运行的原生扩展的关键技术之一。当然，实际开发中需要处理更复杂的逻辑，包括错误处理、异步编程等。</p><h4 id="napi-create-array" tabindex="-1"><a class="header-anchor" href="#napi-create-array"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_array" target="_blank" rel="noopener noreferrer">napi_create_array</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API 层，它允许你用 C 或 C++ 编写可以直接与 JavaScript 交互的代码。这样做的好处是可以提高性能，或者允许你使用操作系统底层的功能，这在纯 JavaScript 中可能无法实现。</p><p><code>napi_create_array</code> 是 N-API 提供的一个函数，它允许你在原生代码中创建一个新的空数组，并且将这个数组返回给 JavaScript 环境。</p><p>这里是 <code>napi_create_array</code> 函数的签名：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_array(napi_env env,</span></span>
<span class="line"><span>                              napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是表示 N-API 环境的句柄，每次 N-API 调用都需要这个环境变量。</li><li><code>result</code>: 这是一个指向 <code>napi_value</code> 的指针，它将在函数执行后保存创建的数组对象。</li></ul><p>如果调用成功，<code>napi_create_array</code> 会返回 <code>napi_ok</code> 并通过 <code>result</code> 参数返回一个新的数组对象。</p><p>下面是如何在 C++ 扩展中使用 <code>napi_create_array</code> 的简单例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数是一个N-API调用的示例，用来创建一个空数组并返回给JavaScript</span></span>
<span class="line"><span>napi_value CreateArrayExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 定义一个napi_value来存放结果数组</span></span>
<span class="line"><span>  napi_value array;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个新的空数组</span></span>
<span class="line"><span>  napi_status status = napi_create_array(env, &amp;array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否成功创建了数组</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回创建的数组</span></span>
<span class="line"><span>  return array;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，此函数用来声明和设置模块的导出</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 注册函数CreateArrayExample到exports对象，使其在JS中可见</span></span>
<span class="line"><span>  napi_value create_array_fn;</span></span>
<span class="line"><span>  napi_create_function(env, NULL, 0, CreateArrayExample, NULL, &amp;create_array_fn);</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;createArray&quot;, create_array_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// N-API模块声明宏</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设上面的代码是你的原生模块的一部分，编译并安装之后，你就可以在 Node.js 中这样使用它：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 导入你的原生模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;your-native-module-name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 使用原生模块中的函数来创建一个新的空数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> newArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">newArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: []</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个 <code>CreateArrayExample</code> 函数回调，该函数使用 <code>napi_create_array</code> 创建一个空数组，并将其返回给 JavaScript 端。然后，我们在 <code>Init</code> 函数中将这个回调注册为模块导出的一部分，使得当我们在 JavaScript 中导入这个原生模块时能够调用 <code>createArray</code> 方法来创建数组。</p><p>总结一下，<code>napi_create_array</code> 是一个用于从原生模块创建新数组的工具，它允许原生模块与 JavaScript 更紧密地集成和交互。</p><h4 id="napi-create-array-with-length" tabindex="-1"><a class="header-anchor" href="#napi-create-array-with-length"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_array_with_length" target="_blank" rel="noopener noreferrer">napi_create_array_with_length</a></span></a></h4><p><code>napi_create_array_with_length</code> 是 Node.js 中用于原生插件开发的一个函数。Node.js 允许你使用 C 或 C++ 语言写扩展模块，这些模块需要使用 N-API（Node API）来和 JavaScript 代码进行交互。<code>napi_create_array_with_length</code> 就是其中一个用于创建数组的 API 函数。</p><p>首先，我们需要理解在 Node.js 的环境中，JavaScript 运行在 V8 引擎上。而 N-API 则提供了一层抽象，使得原生模块的代码能够脱离特定版本的 V8 引擎运行，增加了与不同 Node.js 版本之间的兼容性。</p><p>现在，让我们详细解释一下 <code>napi_create_array_with_length</code> 的功能：</p><ul><li><p><strong>作用</strong>：<br><code>napi_create_array_with_length</code> 函数用来创建一个新的 JavaScript 数组对象，并且可以指定这个数组初始时应该有的长度。</p></li><li><p><strong>参数</strong>：</p><ul><li><code>napi_env env</code>: 当前的 N-API 环境的句柄（handle），它代表了一个独立的运行时环境，是大多数 N-API 函数调用时必须传入的。</li><li><code>size_t length</code>: 你想要创建数组的长度。</li><li><code>napi_value* result</code>: 指针变量，用来接收创建好的 JavaScript 数组对象。</li></ul></li><li><p><strong>返回值</strong>：<br> 返回一个 <code>napi_status</code> 值，表示函数调用成功还是失败。如果成功，<code>result</code> 参数将被设置为新创建的数组。</p></li></ul><p>以下是一个简单的使用示例，在一个原生模块中创建一个具有特定长度的数组：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们要在一个名为“CreateArray”的函数中使用这个 API</span></span>
<span class="line"><span>napi_value CreateArray(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value array;</span></span>
<span class="line"><span>    size_t array_length = 10; // 我们想要创建一个长度为10的数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 `napi_create_array_with_length` 来创建数组</span></span>
<span class="line"><span>    napi_status status = napi_create_array_with_length(env, array_length, &amp;array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否调用成功</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果成功，返回新创建的数组</span></span>
<span class="line"><span>    return array;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际应用中，你可能会在编写一个需要返回大量数据、或者初始化一个特定长度的数组值时使用到 <code>napi_create_array_with_length</code>。例如，如果你编写的原生模块需要执行一些计算并将结果存储在一个数组中返回给 JavaScript，就可以使用这个 API 来创建这样一个数组。</p><h4 id="napi-create-arraybuffer" tabindex="-1"><a class="header-anchor" href="#napi-create-arraybuffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_arraybuffer" target="_blank" rel="noopener noreferrer">napi_create_arraybuffer</a></span></a></h4><p>好的，让我们深入了解 Node.js 中的 <code>napi_create_arraybuffer</code> 函数。</p><p>在 Node.js 中，N-API 是一个用来构建原生插件（native addons）的 API。它让你可以用 C 或 C++ 编写与 JavaScript 代码交云合作执行的代码。这很有用，因为通过原生插件你可以更高效地利用系统资源或执行一些无法直接在 JavaScript 中实现的任务。</p><p><code>napi_create_arraybuffer</code> 是 N-API 的一部分，是一个函数，允许你在原生代码中创建一个 ArrayBuffer 对象。ArrayBuffer 是一个表示固定长度的原始二进制数据缓冲区的类型，在 JavaScript 中通常被用于处理二进制数据。</p><p>下面是如何使用 <code>napi_create_arraybuffer</code> 函数的步骤：</p><ol><li><p><strong>确定要创建的 ArrayBuffer 的大小。</strong> 你需要知道你希望分配多少字节的内存。</p></li><li><p><strong>调用 <code>napi_create_arraybuffer</code> 函数。</strong> 传入要分配的字节数和一个指向指针变量的指针，这个指针变量将会指向 ArrayBuffer 数据的开始处。</p></li><li><p><strong>处理函数返回的结果。</strong> <code>napi_create_arraybuffer</code> 调用后将返回一个状态值，表示操作是否成功。</p></li><li><p><strong>利用这个 ArrayBuffer。</strong> 你可以填充这个 ArrayBuffer，或者把它传回 JavaScript 侧去使用。</p></li></ol><p>现在，让我们通过一个简单的例子来理解这个过程：</p><p>假设我们想要创建一个包含 10 个字节的 ArrayBuffer。在 C/C++ 环境下你的代码可能会是这样的：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个示例函数，展示如何创建一个新的 ArrayBuffer</span></span>
<span class="line"><span>napi_value CreateArrayBufferExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 我们想要创建的 ArrayBuffer 的大小</span></span>
<span class="line"><span>    const size_t byteLength = 10;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这将是指向 ArrayBuffer 数据的指针</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这将是最终创建的 ArrayBuffer 对象</span></span>
<span class="line"><span>    napi_value arrayBuffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个大小为 10 个字节的 ArrayBuffer</span></span>
<span class="line"><span>    napi_status status = napi_create_arraybuffer(env, byteLength, &amp;data, &amp;arrayBuffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否成功创建了 ArrayBuffer</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 填充 ArrayBuffer，例如：用零初始化它</span></span>
<span class="line"><span>    memset(data, 0, byteLength);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的 ArrayBuffer 对象给 JavaScript 使用</span></span>
<span class="line"><span>    return arrayBuffer;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们首先定义了一个函数 <code>CreateArrayBufferExample</code>，它将创建一个新的 ArrayBuffer。我们设定了 ArrayBuffer 的大小是 10 个字节，并且通过 <code>napi_create_arraybuffer</code> 分配了内存。如果函数调用成功，我们会得到一个指向新分配内存的指针 <code>data</code>，以及一个代表 ArrayBuffer 的 N-API value <code>arrayBuffer</code>。然后我们使用 <code>memset</code> 来初始化这段内存（在这个例子里，我们把它全部设置为零）。最后，我们返回 <code>arrayBuffer</code>，它可以在 JavaScript 代码中作为一个 ArrayBuffer 对象使用。</p><p>总结起来，<code>napi_create_arraybuffer</code> 是一个非常有用的函数，可以帮助你在原生插件中创建用于处理二进制数据的 ArrayBuffer 对象。通过这种方式，你可以构建性能更优异的应用程序，并且可以在 JavaScript 和原生代码之间有效地传递大型数据块。</p><h4 id="napi-create-buffer" tabindex="-1"><a class="header-anchor" href="#napi-create-buffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_buffer" target="_blank" rel="noopener noreferrer">napi_create_buffer</a></span></a></h4><p>Node.js 中的<code>napi_create_buffer</code>是一个函数，它属于 N-API（Node API）的一部分。N-API 提供了一种稳定的、版本无关的 API，使得原生模块（即用 C 或 C++编写的扩展模块）可以与 Node.js 的不同版本兼容。</p><p>在解释<code>napi_create_buffer</code>之前，我们需要先理解什么是 Buffer。在 Node.js 中，Buffer 是一个用来处理二进制数据的对象。比如说你想从文件中读取数据，或者与网络上的服务器交换数据，通常这些数据都是以二进制形式存在的。Buffer 就是用来表示这些原始的二进制数据的。</p><p>现在来看<code>napi_create_buffer</code>这个函数。它的作用是创建一个新的 Buffer 对象，这个 Buffer 对象是在 Node.js 的 C/C++插件（native addon）中使用的。使用这个函数可以让插件创建一个 JavaScript Buffer 实例，然后这个实例可以被返回给 JavaScript 代码使用。</p><p>下面是<code>napi_create_buffer</code>的基本用法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 定义长度为1024字节的buffer</span></span>
<span class="line"><span>  size_t length = 1024;</span></span>
<span class="line"><span>  void* data;</span></span>
<span class="line"><span>  napi_value buffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用napi_create_buffer来创建一个buffer</span></span>
<span class="line"><span>  napi_status status = napi_create_buffer(env, length, &amp;data, &amp;buffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 初始化buffer内容，只是示例，实际可能会根据具体需求来操作内存</span></span>
<span class="line"><span>  memset(data, 0, length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回新创建的Buffer对象给JavaScript</span></span>
<span class="line"><span>  return buffer;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在插件初始化时注册上面定义的函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  napi_create_function(env, NULL, 0, CreateBuffer, NULL, &amp;fn);</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;createBuffer&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个函数<code>CreateBuffer</code>。这个函数被用来创建一个长度为 1024 字节的 Buffer，并且将它初始化为全 0。然后我们把这个 Buffer 对象返回给 JS 代码，JS 代码就可以像使用普通 Buffer 一样使用它。</p><p>如何在 Javascript 中使用这个 Buffer 呢？假设上面的 C 代码是我们的插件代码，我们编译并安装之后，在 JS 中可以这样使用：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 加载我们的C/C++插件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 创建一个1024字节的Buffer</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：1024</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：0 因为我们在C代码中将其初始化为0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>napi_create_buffer</code>一般在需要在 C/C++插件中处理大量二进制数据时使用。例如，处理图像、音频文件、准备要通过网络发送的数据包等场景。通过这种方式，插件可以创建 Buffer 对象并填充数据，最后将 Buffer 传递回 JavaScript，以便进行进一步的处理或输出。</p><h4 id="napi-create-buffer-copy" tabindex="-1"><a class="header-anchor" href="#napi-create-buffer-copy"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_buffer_copy" target="_blank" rel="noopener noreferrer">napi_create_buffer_copy</a></span></a></h4><p>好的，我来解释一下 <code>napi_create_buffer_copy</code> 这个函数在 Node.js 中的作用和如何使用它。</p><p>在 Node.js 中，N-API（Node API）是一个用于构建本地插件的接口。本地插件是用 C 或 C++编写的模块，可以直接调用 Node.js 提供的 API，从而实现一些 JavaScript 不能高效处理的任务，比如直接与操作系统进行交互或执行 CPU 密集型计算等。</p><p>函数 <code>napi_create_buffer_copy</code> 是 N-API 的一部分，它允许你在原生代码（如 C/C++）中创建一个 Node.js 的 <code>Buffer</code> 对象，并且将一段数据复制到这个新创建的 <code>Buffer</code> 中。</p><p>在 JavaScript 中，<code>Buffer</code> 对象通常用于处理二进制数据流，比如网络通信、文件操作等场景。</p><p>现在，让我们来看看 <code>napi_create_buffer_copy</code> 的定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_buffer_copy(napi_env env,</span></span>
<span class="line"><span>                                    size_t length,</span></span>
<span class="line"><span>                                    const void* data,</span></span>
<span class="line"><span>                                    napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：这是一个表示当前 N-API 环境的句柄。</li><li><code>length</code>：需要复制的数据长度。</li><li><code>data</code>：指向你想要复制到新 <code>Buffer</code> 的数据。</li><li><code>result</code>：是一个指针，用于返回新创建的 <code>Buffer</code> 对象。</li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h3><p>假设在你的 C/C++扩展中，你想要创建一个包含特定数据的 <code>Buffer</code> 实例，你可以这样使用 <code>napi_create_buffer_copy</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateBufferExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    char data[] = &quot;Hello, world!&quot;; // 数据源</span></span>
<span class="line"><span>    size_t data_length = sizeof(data) - 1; // 计算数据长度，不包括末尾的空字符</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value buffer;</span></span>
<span class="line"><span>    // 调用 napi_create_buffer_copy 创建 Buffer 并复制数据</span></span>
<span class="line"><span>    napi_status status = napi_create_buffer_copy(env, data_length, data, &amp;buffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to create buffer&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return buffer; // 返回新创建的 Buffer 实例</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个名为 <code>CreateBufferExample</code> 的函数，它会创建一个包含 &quot;Hello, world!&quot; 文本的 Node.js <code>Buffer</code> 实例。首先，我们声明了一个包含文本信息的 <code>char</code> 数组，然后计算出没有包括末尾空字符的数据长度。通过调用 <code>napi_create_buffer_copy</code> 函数，我们将数据复制到新创建的 <code>Buffer</code> 中，并将其返回给 JavaScript 环境。</p><p>在您的 Node.js 扩展模块中导出该函数并从 JavaScript 调用时，您就可以得到一个包含 &quot;Hello, world!&quot; 的 <code>Buffer</code> 对象。例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/myAddon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CreateBufferExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: Hello, world!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，由于这是一个低级操作，正常情况下你不需要直接使用 N-API 来处理 <code>Buffer</code>，除非你正在编写一个本地扩展模块来增强 Node.js 的能力。在纯 JavaScript 代码中，你可以简单地通过 <code>Buffer.from</code> 方法来创建 <code>Buffer</code> 实例。</p><h4 id="napi-create-date" tabindex="-1"><a class="header-anchor" href="#napi-create-date"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_date" target="_blank" rel="noopener noreferrer">napi_create_date</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。原生插件通常是一些用 C 或 C++编写的扩展，可以直接调用 Node.js 的底层 API，这样你就可以在 Node.js 中执行更高效率的操作，比如直接与硬件交互，或者运行一些 CPU 密集型的计算任务。</p><p><code>napi_create_date</code> 是 N-API 中的一个函数，它允许你在原生模块中创建一个 JavaScript 的 Date 对象。JavaScript 的 Date 对象是用于处理日期和时间的。</p><p>首先，我们来看一下<code>napi_create_date</code>的签名（即定义）:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_date(napi_env env,</span></span>
<span class="line"><span>                             double time,</span></span>
<span class="line"><span>                             napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数接受三个参数：</p><ul><li><code>env</code>：当前环境的句柄，它代表了 Node.js 运行时的上下文。每当你想要使用 N-API 进行任何操作时，你都需要通过这个环境与 Node.js 的运行时环境交流。</li><li><code>time</code>：表示自 1970 年 1 月 1 日 00:00:00 UTC 以来经过的毫秒数，也就是一个时间戳。</li><li><code>result</code>：是一个指向 napi_value 的指针，这个指针将被赋值为新创建的 Date 对象。</li></ul><p>如果函数执行成功，它会返回<code>napi_ok</code>，这表示没有错误发生。然后，<code>result</code>指针所指向的内存地址会包含一个指向新创建的 Date 对象的引用。</p><p>现在，让我们举个例子，假设你正在编写一个原生插件，你想创建一个表示当前时间的 Date 对象：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是你的原生函数实现</span></span>
<span class="line"><span>napi_value CreateCurrentDate(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value date;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取当前时间</span></span>
<span class="line"><span>    double currentTime = (double)time(NULL) * 1000;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的Date对象</span></span>
<span class="line"><span>    status = napi_create_date(env, currentTime, &amp;date);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否有错误发生</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 如果有错误，返回undefined</span></span>
<span class="line"><span>        napi_get_undefined(env, &amp;date);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回新创建的Date对象</span></span>
<span class="line"><span>    return date;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化你的插件，注册`CreateCurrentDate`函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value current_date_fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 把C函数包装为JavaScript可调用的函数</span></span>
<span class="line"><span>    napi_create_function(env, &quot;createCurrentDate&quot;, NAPI_AUTO_LENGTH, CreateCurrentDate, NULL, &amp;current_date_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置导出的函数</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;createCurrentDate&quot;, current_date_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们的<code>CreateCurrentDate</code>函数调用了<code>napi_create_date</code>函数来创建一个新的 Date 对象，并返回它给 JavaScript。JavaScript 代码就能够像下面这样调用你的原生函数，并得到一个 Date 对象：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;你的原生插件名称&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> currentDate</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createCurrentDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">currentDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打印当前日期和时间</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，你可以在原生插件中创建并操作 JavaScript 对象，这为 Node.js 应用程序提供了更大的灵活性和性能。</p><h4 id="napi-create-external" tabindex="-1"><a class="header-anchor" href="#napi-create-external"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_external" target="_blank" rel="noopener noreferrer">napi_create_external</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API，它允许你在 Node.js 环境中使用 C 或 C++ 代码来创建可以由 JavaScript 代码直接调用的功能。这种方式非常有用，尤其是当你需要执行一些性能敏感或者需要直接与系统资源交互的任务时。</p><p><code>napi_create_external</code> 是 N-API 中的一个函数，它允许你在 JavaScript 中创建一个特殊类型的对象，称为 &quot;外部&quot; 对象。这个外部对象可以用来包装 C/C++ 中的某些数据或资源，以便它们可以在 JavaScript 中被引用和使用，而不必担心如何在 JavaScript 和 C/C++ 数据结构之间进行转换。</p><p>下面是 <code>napi_create_external</code> 函数的基本使用方法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_external(napi_env env,</span></span>
<span class="line"><span>                                 void* data,</span></span>
<span class="line"><span>                                 napi_finalize finalize_cb,</span></span>
<span class="line"><span>                                 void* finalize_hint,</span></span>
<span class="line"><span>                                 napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>: 当前的 N-API 环境句柄，代表了当前的 Node.js 上下文。</li><li><code>data</code>: 指向你想要在 JavaScript 中表示的 C/C++ 数据的指针。</li><li><code>finalize_cb</code>: 一个可选的回调函数，当外部对象被垃圾回收时会被调用，用于清理那些不再需要的资源。</li><li><code>finalize_hint</code>: 提供给 <code>finalize_cb</code> 的可选数据，通常用于传递额外的信息。</li><li><code>result</code>: 指向 <code>napi_value</code> 变量的指针，创建成功后此变量将包含对应于外部对象的引用。</li></ul><p>实际运用例子：</p><p>假设你有一个 C 结构体，代表了一个简单的用户信息：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct {</span></span>
<span class="line"><span>    char* name;</span></span>
<span class="line"><span>    int age;</span></span>
<span class="line"><span>} UserInfo;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们希望在 Node.js 插件中创建一个包装这个 <code>UserInfo</code> 的外部对象，并且在 JavaScript 中使用它。</p><p>首先，我们需要一个清理函数，在外部对象被垃圾回收时清理资源：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void finalize_user_info(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    UserInfo* user_info = (UserInfo*)finalize_data;</span></span>
<span class="line"><span>    // 清理操作，例如释放内存</span></span>
<span class="line"><span>    free(user_info-&gt;name);</span></span>
<span class="line"><span>    free(user_info);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们可以编写一个函数来创建外部对象并返回给 JavaScript：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_user_info(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    UserInfo* user_info = malloc(sizeof(UserInfo));</span></span>
<span class="line"><span>    // 假设我们通过某种方式填充了 user_info 结构体</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value user_info_external;</span></span>
<span class="line"><span>    napi_status status = napi_create_external(env, user_info, finalize_user_info, NULL, &amp;user_info_external);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return user_info_external;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，在 Node.js 代码中，我们可以像这样使用这个外部对象：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> userInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createUserInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 此时 userInfo 是一个外部对象，包装了 C 结构体 UserInfo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样你就可以在 JavaScript 中保存一个指向 C 数据的引用，而且当这个外部对象不再被需要时，N-API 会调用 <code>finalize_user_info</code> 来清理相关资源。这是一个高效管理原生资源的方法，并且允许你在 JavaScript 中利用原生性能。</p><h4 id="napi-create-external-arraybuffer" tabindex="-1"><a class="header-anchor" href="#napi-create-external-arraybuffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_external_arraybuffer" target="_blank" rel="noopener noreferrer">napi_create_external_arraybuffer</a></span></a></h4><p>Node.js 的 N-API (Node.js API) 是一个用来构建原生插件的 API。原生插件是一种可以直接使用系统资源和内存的代码，通常用 C 或 C++编写，并且可以被 Node.js 代码直接调用。<code>napi_create_external_arraybuffer</code> 是 N-API 中的一个函数，它允许你创建一个所谓的“外部” ArrayBuffer。</p><p>在 JavaScript 中，ArrayBuffer 是一种代表固定大小的原始二进制数据缓冲区的对象。它们常用于处理像文件、图像或其他二进制流数据这样的底层数据。</p><p><code>napi_create_external_arraybuffer</code>具体来说，它可以让你将一个 C/C++中的已经存在的数据（比如堆上分配的一块内存）作为一个 ArrayBuffer 暴露给 JavaScript 代码，而无需复制数据。这可以提高性能和效率，因为避免了不必要的内存复制。</p><p>下面我们将详细解释这个函数和如何使用它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_external_arraybuffer(napi_env env,</span></span>
<span class="line"><span>                                             void* external_data,</span></span>
<span class="line"><span>                                             size_t byte_length,</span></span>
<span class="line"><span>                                             napi_finalize finalize_cb,</span></span>
<span class="line"><span>                                             void* finalize_hint,</span></span>
<span class="line"><span>                                             napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明：</p><ul><li><code>env</code>: 表示当前的 N-API 环境，它是一个表示 Node.js 运行时上下文的句柄。</li><li><code>external_data</code>: 这是指向你要暴露给 JavaScript 的那块已有数据的指针。</li><li><code>byte_length</code>: 数据块的大小，以字节为单位。</li><li><code>finalize_cb</code>: 当 ArrayBuffer 被垃圾回收时，将会调用这个回调函数。它可以用来释放<code>external_data</code>。</li><li><code>finalize_hint</code>: 一个传递给<code>finalize_cb</code>的可选提示值，可以用于确定如何清理<code>external_data</code>。</li><li><code>result</code>: 这个函数执行成功后，将返回新创建的 ArrayBuffer 的 N-API 引用。</li></ul><p>实际例子：</p><p>假设你有一个 C/C++库，它处理了一些图像操作，并且有一个函数可以生成一个图像数据的数组，你想把这些数据以 ArrayBuffer 的形式暴露给 Node.js：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void FreeImageData(void* data, void* hint) {</span></span>
<span class="line"><span>  free(data); // 假设这里我们通过malloc分配了图像数据，现在释放它</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateImageBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 假设这个函数获取图像数据和大小</span></span>
<span class="line"><span>  int image_width, image_height;</span></span>
<span class="line"><span>  unsigned char* image_data = GetImageData(&amp;image_width, &amp;image_height);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 图像数据的大小（以字节为单位）</span></span>
<span class="line"><span>  size_t byte_length = image_width * image_height * sizeof(unsigned char);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个对这块已有数据的引用的ArrayBuffer</span></span>
<span class="line"><span>  status = napi_create_external_arraybuffer(env, image_data, byte_length, FreeImageData, NULL, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Unable to create external ArrayBuffer&quot;);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 接下来需要将&#39;CreateImageBuffer&#39;注册到模块当中等更多步骤...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Node.js 中，你可能会这么使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设nativeAddon有一个方法叫createImageBuffer，它就是上面定义的CreateImageBuffer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> imageBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createImageBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 现在你拥有了一个ArrayBuffer，其中包含着你的图像数据</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 你可以用TypedArray或者Buffer对象来管理这些数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子演示了如何使用<code>napi_create_external_arraybuffer</code>将 C/C++中的数据安全且高效地暴露给 Node.js。记住，在实际应用中，需要考虑线程安全和同步问题，特别是如果你打算从多个线程访问数据的话。</p><h4 id="napi-create-external-buffer" tabindex="-1"><a class="header-anchor" href="#napi-create-external-buffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_external_buffer" target="_blank" rel="noopener noreferrer">napi_create_external_buffer</a></span></a></h4><p><code>napi_create_external_buffer</code> 是 Node.js 在其 Native API（N-API）中提供的一个函数，用于创建一个&quot;外部&quot;缓冲区（external buffer）。理解这个函数前，我们首先需要知道 Node.js 中的 Buffer 和 N-API 是什么。</p><p>在 Node.js 中，Buffer 类是用来处理二进制数据的，它可以用来读写文件、网络通信等操作中传输的数据。而 N-API 则是 Node.js 提供的一个稳定的 API 集，允许你使用 C 或 C++编写原生插件，这些插件可以直接与 Node.js 的 JavaScript 运行时交互。</p><p>现在来具体讲解一下 <code>napi_create_external_buffer</code> 函数：</p><ul><li><p><strong>功能</strong>：该函数用于创建一个 Buffer 对象，但其内存是由开发者自己管理的，而不是由 Node.js 的垃圾回收机制来管理。这意味着你可以用这个方法将已经存在的数据（比如 C++分配的堆上的数据）包装成一个 Node.js 可用的 Buffer 对象，而无需复制数据。</p></li><li><p><strong>参数</strong>：</p><ol><li><code>env</code>: 当前的 napi 环境，代表了 Node.js 环境的一个句柄。</li><li><code>length</code>: 要创建的 Buffer 的长度。</li><li><code>data</code>: 指向预先分配好的数据的指针。</li><li><code>finalize_cb</code>: 一个可选的回调函数，当这个 Buffer 被垃圾回收时会被调用，这个函数通常用来释放外部分配的内存。</li><li><code>finalize_hint</code>: 传递给<code>finalize_cb</code>的可选参数。</li><li><code>result</code>: 这是一个输出参数，创建成功后返回的 Buffer 对象。</li></ol></li><li><p><strong>返回值</strong>：如果成功，返回<code>napi_ok</code>，否则返回一个错误码。</p></li></ul><p>下面通过一个例子来说明 <code>napi_create_external_buffer</code> 的使用：</p><p>想象一下，你在 C++中有一块内存，里面存放着音频数据，现在你希望在一个 Node.js 应用中处理这些数据，但你不希望进行数据的复制以避免额外的性能开销。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的音频数据和清理函数</span></span>
<span class="line"><span>const size_t AUDIO_DATA_SIZE = 1024;</span></span>
<span class="line"><span>char* audioData = new char[AUDIO_DATA_SIZE];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void FreeAudioData(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>  char* data = reinterpret_cast`&lt;`char*&gt;(finalize_data);</span></span>
<span class="line"><span>  delete[] data;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将被暴露给Node.js</span></span>
<span class="line"><span>napi_value CreateExternalBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_value externalBuffer;</span></span>
<span class="line"><span>  // 创建一个外部缓冲区，将音频数据包装成Node.js的Buffer对象</span></span>
<span class="line"><span>  napi_status status = napi_create_external_buffer(env,</span></span>
<span class="line"><span>                                                   AUDIO_DATA_SIZE,</span></span>
<span class="line"><span>                                                   audioData,</span></span>
<span class="line"><span>                                                   FreeAudioData,</span></span>
<span class="line"><span>                                                   nullptr,</span></span>
<span class="line"><span>                                                   &amp;externalBuffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return externalBuffer;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化代码和模块注册...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们创建了一个外部缓冲区来引用我们已经有的音频数据，并且定义了一个清理函数<code>FreeAudioData</code>，当 Node.js 判断这个 Buffer 不再被需要时，它会自动调用这个清理函数来释放内存。这样我们就可以有效地在 Node.js 中处理我们的音频数据而不需要拷贝它。</p><p>最后在 Node.js 中，你可以像这样使用这个新建的 Buffer：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/nativeAddon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 获取由C++创建的外部Buffer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> audioBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CreateExternalBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 做一些处理，比如播放或者修改音频数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，我们实现了 C++和 Node.js 之间高效的二进制数据交换。这对于性能敏感型的应用非常重要，比如处理多媒体内容、大量科学计算数据等场景。</p><h4 id="napi-create-object" tabindex="-1"><a class="header-anchor" href="#napi-create-object"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_object" target="_blank" rel="noopener noreferrer">napi_create_object</a></span></a></h4><p>好的，既然你对编程还比较新，我会尽量用简单的语言来解释。首先，<code>napi_create_object</code> 是 Node.js 中 N-API 的一部分，N-API 是一个 C 语言的接口，允许你创建和操作 JavaScript 对象从 C 或者 C++代码中。</p><p>在 Node.js 中，许多时候我们想要使用 C 或 C++扩展性能或者访问一些底层系统资源，这就是 N-API 发挥作用的地方。通过 N-API，你可以构建原生的插件，而<code>napi_create_object</code> 就是用来创建一个空的 JavaScript 对象的函数。</p><p>现在我会通过一个实际的例子来说明<code>napi_create_object</code> 是如何工作的。假设我们正在编写一个原生模块，我们需要从 C 代码中创建一个新的 JavaScript 对象返回给 JavaScript 环境。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数是暴露给JavaScript的功能</span></span>
<span class="line"><span>napi_value CreateObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value myObject;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用 napi_create_object 创建一个新的 JavaScript 对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;myObject);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 如果创建对象失败，抛出一个错误</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to create object&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们在这个对象上设置了一些属性...</span></span>
<span class="line"><span>    // napi_set_named_property(env, myObject, &quot;key&quot;, someValue);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回这个新创建的对象</span></span>
<span class="line"><span>    return myObject;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，将CreateObject绑定到exports上，让JS可以调用它</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个函数值</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, CreateObject, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to wrap native function&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个函数作为一个属性添加到exports对象上</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;createObject&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to populate exports&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义模块，其中 &quot;addon&quot; 是模块名</span></span>
<span class="line"><span>NAPI_MODULE(addon, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中：</p><ol><li><code>CreateObject</code> 函数是我们想要在 JavaScript 环境中调用的 C 函数。</li><li>我们使用<code>napi_create_object</code> 来创建一个新的空白 JavaScript 对象。</li><li>然后我们可以使用其它 N-API 函数像<code>napi_set_named_property</code> 给这个对象设置属性或者方法。</li><li>最后，<code>CreateObject</code> 返回这个新创建的对象到 JavaScript 环境。</li></ol><p>这样，当你在 Node.js 环境中安装并引入这个原生模块时，你可以这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 代码中，<code>addon.createObject()</code> 调用了我们用 C 语言编写的函数，并且返回了一个新的 JavaScript 对象。</p><p>理解<code>napi_create_object</code>和其它 N-API 函数的关键点在于：它们提供了 JavaScript 和 C/C++之间的桥梁，允许开发者利用 C/C++的性能和系统级访问权限来扩展 Node.js 的功能。</p><h4 id="napi-create-symbol" tabindex="-1"><a class="header-anchor" href="#napi-create-symbol"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_symbol" target="_blank" rel="noopener noreferrer">napi_create_symbol</a></span></a></h4><p><code>napi_create_symbol</code> 是 Node.js 中 N-API 的一个函数，它允许原生模块创建 JavaScript 的 Symbol 类型的值。在 ES6 (ECMAScript 2015) 中引入的 Symbol 是一个基本数据类型，用于创建唯一的标识符。Symbols 非常适合用作对象属性的键，因为每个 Symbol 都是唯一的，不会与其他属性的键发生冲突。</p><p>首先，我们来了解下 JavaScript 中的 Symbol 是什么：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 在 JavaScript 中创建 Symbol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> mySymbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my unique identifier&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">mySymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：Symbol(my unique identifier)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码展示了在 JavaScript 中如何创建一个 Symbol。Symbols 通常用于创建独一无二的标识符。</p><p>现在，如果你正在编写一个 Node.js 的原生扩展模块（可能使用 C 或者 C++），你可能会需要在这些低级语言中创建 JavaScript 对象和类型。N-API 是 Node.js 提供的一个 C API，让你能够构建这类原生插件，并且保证与 Node.js 版本之间的兼容性。</p><p>使用 <code>napi_create_symbol</code> 函数可以在原生代码中创建一个新的 JavaScript Symbol。下面是一个实际的例子，展示如何在一个原生模块中使用 <code>napi_create_symbol</code>：</p><p>假设你有以下的 C 代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数被调用以创建一个新的 Symbol</span></span>
<span class="line"><span>napi_value CreateSymbol(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value symbolDescription;</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 首先，我们创建一个带有描述的 JS 字符串</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;my unique identifier&quot;, NAPI_AUTO_LENGTH, &amp;symbolDescription);</span></span>
<span class="line"><span>    if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 接下来，使用该描述创建一个 Symbol</span></span>
<span class="line"><span>    status = napi_create_symbol(env, symbolDescription, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) return NULL;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回这个新创建的 Symbol</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将上面的 CreateSymbol 函数暴露给 JavaScript</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, CreateSymbol, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        napi_set_named_property(env, exports, &quot;createSymbol&quot;, fn);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码演示了如何在原生模块中创建一个函数 <code>CreateSymbol</code> ，这个函数当从 JavaScript 调用时会返回一个新的 Symbol。在模块初始化函数 <code>Init</code> 中，我们将 <code>CreateSymbol</code> 函数导出为模块的一个属性，使得 JavaScript 代码可以调用它。</p><p>在 JavaScript 中使用这个原生模块可能像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 从原生模块中创建一个 Symbol</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> sym</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">sym</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：Symbol(my unique identifier)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这个例子，你可以看到 <code>napi_create_symbol</code> 如何在原生模块中被用来创建 JavaScript 中的 Symbol 类型，同时使得这个功能可以被 JavaScript 代码所调用。</p><h4 id="node-api-symbol-for" tabindex="-1"><a class="header-anchor" href="#node-api-symbol-for"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_symbol_for" target="_blank" rel="noopener noreferrer">node_api_symbol_for</a></span></a></h4><p>Node.js 中的 <code>napi_symbol_for</code> 是一个函数，它属于 Node.js 的 N-API（原生 API），这是一套用于构建原生插件的 API。在详细解释这个函数之前，我们得先理解几个概念。</p><h3 id="关键概念" tabindex="-1"><a class="header-anchor" href="#关键概念"><span>关键概念：</span></a></h3><ol><li><p><strong>Symbol</strong>: 在 JavaScript 中，Symbol 是一种原始数据类型，像 Number、String 或 Boolean 一样。每个 Symbol 值都是唯一不变的，通常用作对象属性的键，以保证不会与其他属性键发生冲突。</p></li><li><p><strong>N-API</strong>：N-API 是 Node.js 提供的一套 C 语言 API，它允许你编写能够与 Node.js 交互的本地插件。通过 N-API，你可以创建一些性能更高、更接近操作系统底层的代码。</p></li><li><p><strong>node_api_symbol_for</strong>：这个函数是 N-API 提供的，用来创建或获取全局符号注册表中的 Symbol，这意味着当你在不同的模块或者插件中使用相同名称创建 Symbol 时，通过 <code>napi_symbol_for</code> 总是能够拿到同一个 Symbol 实例。</p></li></ol><h3 id="node-api-symbol-for-函数的作用和运用" tabindex="-1"><a class="header-anchor" href="#node-api-symbol-for-函数的作用和运用"><span><code>node_api_symbol_for</code> 函数的作用和运用:</span></a></h3><p><code>node_api_symbol_for</code> 函数的目的是让不同的原生插件共享相同的 Symbol 值，而不是每个插件独立创建自己的 Symbol。这有助于避免意外的命名冲突，因为 Symbol 值即使名称相同，如果独立创建，也会是不同的值。</p><h4 id="实际应用例子" tabindex="-1"><a class="header-anchor" href="#实际应用例子"><span>实际应用例子：</span></a></h4><p>假设你正在开发两个不同的 Node.js 原生插件，它们都需要引用一个名为 <code>&quot;shared_event&quot;</code> 的事件名称。为了确保这两个插件引用的是同一个事件名称，你可以在每个插件中使用 <code>napi_symbol_for</code> 来获取这个事件的 Symbol 值。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 插件A中的代码</span></span>
<span class="line"><span>napi_value symbol_for_plugin_a;</span></span>
<span class="line"><span>napi_status status = napi_symbol_for(env, &quot;shared_event&quot;, &amp;symbol_for_plugin_a);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 插件B中的代码</span></span>
<span class="line"><span>napi_value symbol_for_plugin_b;</span></span>
<span class="line"><span>napi_status status = napi_symbol_for(env, &quot;shared_event&quot;, &amp;symbol_for_plugin_b);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 以上两段代码即使在不同的插件中，通过 napi_symbol_for 获取到的 symbol_for_plugin_a 和 symbol_for_plugin_b 是相同的。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，无论哪个插件发布或监听 <code>&quot;shared_event&quot;</code> 事件，它们都会指向同一个事件标识符，确保了通信的一致性。</p><h3 id="使用场景总结" tabindex="-1"><a class="header-anchor" href="#使用场景总结"><span>使用场景总结：</span></a></h3><ul><li>当多个原生插件需要对某个特定的功能或事件进行协作时。</li><li>当你想要避免全局空间中的命名冲突。</li><li>当在原生插件中实现跨模块的符号共享时。</li></ul><p>希望以上解释和例子能帮助你理解 <code>node_api_symbol_for</code> 在 Node.js 中的作用和如何使用它。</p><h4 id="napi-create-typedarray" tabindex="-1"><a class="header-anchor" href="#napi-create-typedarray"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_typedarray" target="_blank" rel="noopener noreferrer">napi_create_typedarray</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API 层，它提供了与 V8 和其他 Node.js 内部组件相互操作的接口，并且是跨 Node 版本稳定的。<code>napi_create_typedarray</code> 函数是 N-API 的一部分，它允许你在原生代码中创建一个 TypedArray 对象，这个对象可以被 JavaScript 代码使用。</p><p>TypedArray 是 JavaScript 的一种数据类型，用于表示一个固定长度的二进制数据缓冲区。对于需要处理二进制数据（如文件系统操作、网络通信、或者图像处理等）的应用来说非常有用。</p><p>下面将详细解释 <code>napi_create_typedarray</code> 函数和一个简单实例。</p><p>函数的定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_typedarray(</span></span>
<span class="line"><span>    napi_env env,                  // [in] N-API 环境句柄</span></span>
<span class="line"><span>    napi_typedarray_type type,     // [in] 要创建的 TypedArray 类型</span></span>
<span class="line"><span>    size_t length,                 // [in] 数组中元素的数量</span></span>
<span class="line"><span>    napi_value arraybuffer,        // [in] ArrayBuffer 对象</span></span>
<span class="line"><span>    size_t byte_offset,            // [in] 在 ArrayBuffer 中开始的字节偏移量</span></span>
<span class="line"><span>    napi_value* result             // [out] 新创建的 TypedArray 引用</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明：</p><ol><li><code>env</code>: 这是一个代表当前 N-API 环境的句柄，每次调用 N-API 函数时都需要传递。</li><li><code>type</code>: 指定你想创建的 TypedArray 的具体类型，比如 <code>napi_uint8_array</code>, <code>napi_int16_array</code> 等。</li><li><code>length</code>: 数组的长度，即你希望创建的数组中会有多少个元素。</li><li><code>arraybuffer</code>: 一个已存在的 ArrayBuffer 对象，TypedArray 将会使用这个 ArrayBuffer 作为数据源。</li><li><code>byte_offset</code>: 在给定的 ArrayBuffer 中的起始位置，也就是从哪里开始创建 TypedArray。</li><li><code>result</code>: 这是一个输出参数，创建成功后，新的 TypedArray 的引用将会被存储在这里。</li></ol><p>返回值：返回一个 <code>napi_status</code> 枚举值，表示函数调用是否成功。</p><p>示例：</p><p>假设我们想在原生模块中创建一个长度为 10 的 <code>Uint8Array</code>（无符号 8 位整数数组），并填充一些数据然后返回给 JavaScript 使用。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数是被触发的原生函数</span></span>
<span class="line"><span>napi_value CreateUint8Array(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 定义一个指向结果 TypedArray 的变量</span></span>
<span class="line"><span>    napi_value result_array;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 ArrayBuffer。假设我们已经创建了一个 buffer 变量。</span></span>
<span class="line"><span>    napi_value buffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 我们假设 buffer 已经被正确创建，并且有足够的空间 (至少 10 bytes)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建 TypedArray</span></span>
<span class="line"><span>    napi_status status = napi_create_typedarray(env, napi_uint8_array, 10, buffer, 0, &amp;result_array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检测是否创建成功</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回新创建的 TypedArray 给 JavaScript</span></span>
<span class="line"><span>    return result_array;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册原生函数等...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们首先声明了一个 <code>napi_value</code> 类型的 <code>result_array</code> 来存放我们创建好的 TypedArray。之后，我们调用 <code>napi_create_typedarray</code>，指定了我们要创建的是 <code>napi_uint8_array</code> 类型的数组，长度为 10，基于已有的 <code>buffer</code> <code>ArrayBuffer</code>，从第 0 个字节开始创建。如果一切顺利，我们将得到一个指向新 Uint8Array 的引用，并将其返回给 JavaScript 代码使用。</p><p>在 JavaScript 层面，你可以像使用常规的 <code>Uint8Array</code> 那样使用这个原生模块返回的对象，比如遍历元素或者将它传递给其他需要二进制数据的 API。</p><h4 id="napi-create-dataview" tabindex="-1"><a class="header-anchor" href="#napi-create-dataview"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_dataview" target="_blank" rel="noopener noreferrer">napi_create_dataview</a></span></a></h4><p>好的，我会尽量通俗易懂地解释给你。</p><p><code>napi_create_dataview()</code> 是 Node.js 中 N-API（Native API）的一个函数，这个 API 允许原生插件作者用 C 或 C++写代码，然后可以在 Node.js 中调用这些代码。N-API 的目的是提供一个与 Node.js 版本无关的 API，这样编写的原生代码就不需要针对不同版本的 Node.js 重新编译。</p><p>现在，来看<code>napi_create_dataview()</code>这个函数。DataView 是 JavaScript 的一种对象，用于读取和写入二进制数据缓冲区（ArrayBuffer）。在 JavaScript 中，ArrayBuffer 是一种固定长度的原始二进制数据缓冲区，而 DataView 则提供了一个更灵活的接口来操作这些二进制数据。</p><p><code>napi_create_dataview()</code> 函数就是用来在原生模块代码中创建一个与 JavaScript 层面上的 DataView 对象相对应的 N-API 版本的 DataView。通过这个函数，你可以指定你想要操作的 ArrayBuffer 的哪一部分，以及开始操作的字节偏移量和长度。</p><p>下面是一个简单的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个原生函数，想要创建一个DataView</span></span>
<span class="line"><span>napi_value CreateDataView(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t byte_offset = 0; // 我们从缓冲区的起始位置开始</span></span>
<span class="line"><span>    size_t length = 8; // 假设我们想操作8个字节</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 我们需要一个已经存在的ArrayBuffer</span></span>
<span class="line"><span>    napi_value arraybuffer;</span></span>
<span class="line"><span>    // ... 这里省略了创建或者获取ArrayBuffer的过程</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建DataView</span></span>
<span class="line"><span>    napi_value dataview;</span></span>
<span class="line"><span>    napi_status status = napi_create_dataview(env, length, arraybuffer, byte_offset, &amp;dataview);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的DataView对象</span></span>
<span class="line"><span>    return dataview;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个<code>CreateDataView</code>函数，它会创建一个字节长度为 8 的 DataView，并且从给定的 ArrayBuffer 的起始位置开始。返回的<code>dataview</code>对象可以在随后的原生代码中使用，或者传递回 JavaScript 进行进一步的操作。</p><p>实际上，您可能会使用<code>napi_create_dataview()</code>来构建能够处理图像数据、音频流、网络包或任何其他需要精确字节级别操作的二进制数据的库。总之，这是一个连接 JavaScript 高级功能与底层二进制数据操作之间的桥梁。</p><h3 id="functions-to-convert-from-c-types-to-node-api" tabindex="-1"><a class="header-anchor" href="#functions-to-convert-from-c-types-to-node-api"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#functions-to-convert-from-c-types-to-node-api" target="_blank" rel="noopener noreferrer">Functions to convert from C types to Node-API</a></span></a></h3><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎的 JavaScript 运行环境。Node.js 允许你在服务器端运行 JavaScript，而 Node-API（之前称为 N-API）是一个用来构建原生插件的 API。原生插件是用 C 或 C++编写的模块，它们可以被 Node.js 直接调用。</p><p>通常情况下，当你使用 JavaScript 开发 Node.js 应用时，你不需要关心 C/C++代码或者 Node-API。但如果你想要提高性能，访问系统底层特性，或者复用现有的 C/C++库，你可能会需要编写原生插件。</p><p>Node-API 中的 &quot;Functions to convert from C types to Node-API&quot; 部分提供了一系列函数，这些函数允许你将 C 语言中的数据类型转换为 Node-API 能够识别的类型。这样，你就可以在 Node.js 中使用 C/C++代码定义的数据了。</p><p>例如：</p><ol><li>假设你有一个 C 函数，它计算两个整数的和，并且返回结果。为了让这个 C 函数能够和 Node.js 交互，你需要将 C 中的整型（<code>int</code>）转换为 Node-API 中的数值类型（<code>napi_value</code>）：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原始的C函数</span></span>
<span class="line"><span>int add(int a, int b) {</span></span>
<span class="line"><span>    return a + b;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 为Node.js封装的函数</span></span>
<span class="line"><span>napi_value AddWrapped(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传入的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 转换JavaScript参数到C类型</span></span>
<span class="line"><span>    int value1, value2;</span></span>
<span class="line"><span>    status = napi_get_value_int32(env, args[0], &amp;value1);</span></span>
<span class="line"><span>    status = napi_get_value_int32(env, args[1], &amp;value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用原始的C函数</span></span>
<span class="line"><span>    int result = add(value1, value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将C的结果转换回Node-API类型</span></span>
<span class="line"><span>    napi_value sum;</span></span>
<span class="line"><span>    status = napi_create_int32(env, result, &amp;sum);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>napi_get_value_int32</code> 函数用于从 JavaScript 传递的参数中获取 C 的 <code>int</code> 类型值，而 <code>napi_create_int32</code> 则用来创建一个新的 Node-API 类型的整数。</p><ol start="2"><li>如果你有一个 C 结构体，表示一个二维的点，你也可以将这个结构体通过 Node-API 暴露给 JavaScript：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>    double x;</span></span>
<span class="line"><span>    double y;</span></span>
<span class="line"><span>} Point;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 相应的转换函数可能会这样写：</span></span>
<span class="line"><span>napi_value PointToNapiObject(napi_env env, Point* point) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value obj;</span></span>
<span class="line"><span>    napi_value x, y;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个空对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将Point结构体的x和y属性转换为napi_value</span></span>
<span class="line"><span>    status = napi_create_double(env, point-&gt;x, &amp;x);</span></span>
<span class="line"><span>    status = napi_create_double(env, point-&gt;y, &amp;y);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置JavaScript对象的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, obj, &quot;x&quot;, x);</span></span>
<span class="line"><span>    status = napi_set_named_property(env, obj, &quot;y&quot;, y);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return obj;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：在实际编码过程中，你应该总是检查 <code>napi_status</code> 返回值以确保每个 API 调用都成功了。</p><p>上述示例展示了如何将 C 语言数据类型转换为 JavaScript 可以理解的数据类型。通过这种方式，Node.js 可以与原生模块互操作，同时 Node-API 提供的抽象层可以使得模块编写更为简单，同时还具备跨 Node.js 版本的兼容性。</p><h4 id="napi-create-int32" tabindex="-1"><a class="header-anchor" href="#napi-create-int32"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_int32" target="_blank" rel="noopener noreferrer">napi_create_int32</a></span></a></h4><p>当然，我乐意帮助你。首先，我们需要了解几个关键点：</p><ol><li><strong>Node.js</strong>：这是一个使用 JavaScript 语言来编写服务器端程序的平台。</li><li><strong>N-API</strong>：这是 Node.js 提供的一个底层 API，用于构建本地插件。本地插件是用 C 或 C++等语言编写的模块，可以直接调用 Node.js 的各种功能。</li></ol><p><code>napi_create_int32</code> 是 N-API 中的一个函数，它用于创建一个包含 32 位整数值的<code>N-API</code>值。在 JavaScript 中，当我们处理数字时，通常不需要考虑数字的具体类型，但在 C 或 C++等低级语言中，我们需要明确指定使用哪一种类型的数字，因为每种类型的数字在内存中占用的空间和表达的范围都有所不同。<code>int32</code>是指一个 32 位的整数。</p><p>现在，让我们给出一个实际的场景，比如说你想要编写一个 Node.js 本地插件来执行一些性能敏感的数学运算。此时，你可能会选择使用 C++来实现这些运算，以便利用它的性能优势。</p><p>在 C++代码中，你希望建立一个与 JavaScript 代码交互的桥梁，以便将计算结果传递回 JavaScript 环境。<code>napi_create_int32</code>就是在这里发挥作用的函数之一。以下是一个简化的例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数将被暴露给JavaScript，并且它返回一个计算结果</span></span>
<span class="line"><span>napi_value CalculateSomething(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int32_t value = 123; // 假设这是通过某种计算得到的32位整数结果</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用napi_create_int32来创建一个N-API表示的32位整数</span></span>
<span class="line"><span>    napi_status status = napi_create_int32(env, value, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 如果创建失败，抛出一个错误</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Failed to create int32 value&quot;);</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建好的整数值给JavaScript</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 其他必要的注册代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个<code>CalculateSomething</code>函数，它通过<code>napi_create_int32</code>创建了一个 32 位整数的 N-API 值，并返回给 JavaScript。如果操作成功，JavaScript 代码就可以接收到这个整数值并利用它做进一步的处理。如果创建失败，则会抛出一个错误。</p><p>在 JavaScript 端，调用这个本地模块可能看起来像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CalculateSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: 123</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>nativeAddon.CalculateSomething()</code> 调用了我们刚才用 C++编写并暴露给 JavaScript 的函数，并打印出了从 C++返回的整数<code>123</code>。</p><p>希望这个解释和例子能帮助你更好地理解<code>napi_create_int32</code>函数在 Node.js 的 N-API 中的运用。</p><h4 id="napi-create-uint32" tabindex="-1"><a class="header-anchor" href="#napi-create-uint32"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_uint32" target="_blank" rel="noopener noreferrer">napi_create_uint32</a></span></a></h4><p>Node.js 的 N-API 是一个用于构建原生插件的 API，它提供了一组用 C 或 C++ 编写与 JavaScript 交互的函数。在 Node.js 中，原生插件是一种使用其他语言编写的模块，能够直接运行在操作系统级别，通常用于执行那些对性能要求较高的任务。</p><p><code>napi_create_uint32</code> 是 N-API 中的一个函数，其作用是创建一个包含无符号 32 位整数（uint32）的 JavaScript 数值。</p><p>以下是 <code>napi_create_uint32</code> 函数的定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_uint32(napi_env env,</span></span>
<span class="line"><span>                                uint32_t value,</span></span>
<span class="line"><span>                                napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明：</p><ul><li><code>env</code>：表示当前的 N-API 环境上下文，这通常在函数调用时由 Node.js 自动传递。</li><li><code>value</code>：这是你想要创建的 JavaScript 数值中存储的实际的无符号 32 位整数值。</li><li><code>result</code>：这是一个指向 <code>napi_value</code> 的指针，用于接收创建出来的 JavaScript 数值。</li></ul><p>返回值：<br> 这个函数会返回一个类型为 <code>napi_status</code> 的状态码，表示操作成功或失败的状态。如果函数执行成功，状态码将会是 <code>napi_ok</code>。</p><p>让我们举一个例子来说明它的作用：</p><p>假设你正在编写一个原生插件，需要从 C/C++ 层面计算某种资源的数量，并将这个数量传递给 JavaScript。</p><p>在 C/C++ 插件代码中，你可能会有如下的函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他必要的头文件和代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value GetResourceCount(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 假设我们通过某种方式计算得到了资源数量</span></span>
<span class="line"><span>    uint32_t resourceCount = CalculateResourceCount();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 JavaScript 数值来保存这个无符号32位整数</span></span>
<span class="line"><span>    napi_value jsResourceCount;</span></span>
<span class="line"><span>    napi_status status = napi_create_uint32(env, resourceCount, &amp;jsResourceCount);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否成功创建 JavaScript 数值</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 如果创建失败，则抛出错误</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to create uint32 number&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回这个 JavaScript 数值</span></span>
<span class="line"><span>    return jsResourceCount;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数到 Node.js</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value exportFn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, GetResourceCount, NULL, &amp;exportFn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;getResourceCount&quot;, exportFn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 代码中，你可以加载并使用这个插件：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 获取资源数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> resourceCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getResourceCount</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;资源数量:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">resourceCount</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述例子展示了如何在原生插件中使用 <code>napi_create_uint32</code> 来创建一个无符号 32 位整数并将其以 JavaScript 数值的形式传递给 JavaScript 代码。这使得原生代码与 JavaScript 代码之间的数据交换变得简单、安全。</p><h4 id="napi-create-int64" tabindex="-1"><a class="header-anchor" href="#napi-create-int64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_int64" target="_blank" rel="noopener noreferrer">napi_create_int64</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎执行 JavaScript 代码的平台。而 N-API 则是 Node.js 提供的一套 C API，允许原生插件的作者编写不依赖于 JavaScript 运行时版本的代码，这样可以大大提高原生模块的稳定性和兼容性。</p><p><code>napi_create_int64</code> 是 N-API 中的一个函数，它用于在原生代码中创建一个表示 64 位整数的 JavaScript 数值。在 JavaScript 中虽然所有数字都是以双精度浮点数的形式存储的，但在与操作系统或者其他低级系统交互时，我们经常需要处理整数值，尤其是范围较大的整数（比如文件大小、内存地址等），这时候就需要使用像 <code>napi_create_int64</code> 这样的 API 来确保数字的准确性。</p><p>下面我会给你展示一个使用 <code>napi_create_int64</code> 的简单例子：</p><p>假设我们想在 Node.js 的原生扩展中创建一个函数，它会接收一个 64 位整数作为参数，并返回它的值。首先，我们需要编写 C 代码来实现这个原生函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义一个原生的 N-API 函数</span></span>
<span class="line"><span>napi_value GetInt64Value(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value the_number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们要返回的 64 位整数是 123456789012345</span></span>
<span class="line"><span>    int64_t my_int64 = 123456789012345;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用 napi_create_int64 创建一个 JavaScript 数值</span></span>
<span class="line"><span>    status = napi_create_int64(env, my_int64, &amp;the_number);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Failed to create 64-bit integer&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的整数值</span></span>
<span class="line"><span>    return the_number;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册上面定义的 &#39;GetInt64Value&#39; 函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 JavaScript 函数</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, GetInt64Value, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 给这个函数命名为 &quot;getInt64Value&quot; 并导出</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;getInt64Value&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们需要编译这个原生扩展使之成为 Node.js 可以加载的模块。编译后，我们可以在 JavaScript 代码中这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 加载原生模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用我们刚才实现的原生方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> int64Value</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getInt64Value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">int64Value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：123456789012345</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个简单的例子中，我们编写了一个 C 函数，通过 <code>napi_create_int64</code> 创建了一个 JavaScript 能够识别的 64 位整数，并将其作为函数的返回值。然后在 JavaScript 代码中，我们加载并调用了这个原生模块函数，最终打印出这个整数的值。</p><p>需要注意的是，这个过程涉及到对 Node.js 原生模块开发的理解，包括 C/C++ 编程知识、构建工具（如 node-gyp）的使用，以及 Node.js 的 N-API。如果你仅仅是 JavaScript 开发者，通常不需要深入了解这一层，除非你需要编写或维护 Node.js 的原生扩展。</p><h4 id="napi-create-double" tabindex="-1"><a class="header-anchor" href="#napi-create-double"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_double" target="_blank" rel="noopener noreferrer">napi_create_double</a></span></a></h4><p>在 Node.js 中，N-API 是一个用来构建原生插件的 API。原生插件是用 C 或 C++编写的模块，它们可以直接调用 Node.js 提供的 API，实现一些 JavaScript 难以做到的性能优化或直接与操作系统底层交互的功能。</p><p><code>napi_create_double</code>是 N-API 中的一个函数，它的作用是创建一个表示双精度浮点数（double）的 JavaScript 数值。当你在原生插件中使用 C 或 C++处理双精度浮点数时，如果你想将这个数值传递回 JavaScript，就需要把它转换成 JavaScript 能够识别和处理的数值类型。</p><p>下面是一个简单的例子说明如何使用<code>napi_create_double</code>函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数是C/C++扩展暴露给JavaScript的一个函数.</span></span>
<span class="line"><span>// 假设我们要计算一个C语言中的双精度浮点数，并将结果返回给JavaScript.</span></span>
<span class="line"><span>napi_value CalculatePi(napi_env env, napi_callback_info args) {</span></span>
<span class="line"><span>  double pi = 3.14159265359; // 在C语言中定义一个双精度浮点数pi</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 声明一个napi_value变量，这将是我们创建的JavaScript数值的句柄</span></span>
<span class="line"><span>  napi_value js_pi;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 使用napi_create_double将C语言中的pi转换成JavaScript数值</span></span>
<span class="line"><span>  napi_status status = napi_create_double(env, pi, &amp;js_pi);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否成功创建了数值</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 如果创建失败，返回错误</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;Unable to create a double value&quot;);</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 如果成功，返回创建的JavaScript数值</span></span>
<span class="line"><span>  return js_pi;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册CalculatePi函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value export_fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个JavaScript函数，当JavaScript代码调用它时，会执行CalculatePi</span></span>
<span class="line"><span>  napi_create_function(env, &quot;calculatePi&quot;, NAPI_AUTO_LENGTH, CalculatePi, NULL, &amp;export_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将这个函数作为模块的导出</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;calculatePi&quot;, export_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，我们定义了一个名为<code>CalculatePi</code>的 C 函数，该函数会计算圆周率 π 的一个近似值，并通过使用<code>napi_create_double</code>函数将这个双精度浮点数值封装为 JavaScript 可以理解的数值类型。之后，我们可以在 JavaScript 代码中调用这个函数并得到 π 的值。</p><p>例如，在 Node.js 中，你可以像这样使用这个扩展：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/my_addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 替换成你的扩展名</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">calculatePi</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：3.14159265359</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个 JavaScript 代码示例中，我们加载了我们刚才编写的原生模块，并调用<code>calculatePi</code>方法，它会输出我们从 C 扩展中获取的 π 值。</p><h4 id="napi-create-bigint-int64" tabindex="-1"><a class="header-anchor" href="#napi-create-bigint-int64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_bigint_int64" target="_blank" rel="noopener noreferrer">napi_create_bigint_int64</a></span></a></h4><p>Node.js 中的<code>napi_create_bigint_int64</code>是一个 N-API 函数，它允许你在原生插件代码中创建一个新的 BigInt 类型的变量。这个函数特别适用于需要处理大整数（超出 JavaScript Number 能精确表示的范围）的情况。</p><p>N-API 是 Node.js 提供的一个稳定的 API 层，它允许开发者用 C 或 C++编写扩展模块，与 Node.js 进行交互。使用 N-API 编写的模块不依赖于特定版本的 V8 引擎，这意味着模块更容易保持跨 Node.js 版本的兼容性。</p><p>下面我们详细解释一下<code>napi_create_bigint_int64</code>：</p><h3 id="函数签名-3" tabindex="-1"><a class="header-anchor" href="#函数签名-3"><span>函数签名</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_bigint_int64(napi_env env,</span></span>
<span class="line"><span>                                      int64_t value,</span></span>
<span class="line"><span>                                      napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数有三个参数：</p><ol><li><code>napi_env env</code>: 当前的环境句柄，它代表了当前的执行上下文。</li><li><code>int64_t value</code>: 你想要转换成 BigInt 的 64 位整数值。</li><li><code>napi_value* result</code>: 这是一个指针，函数会把创建的 BigInt 赋值到这里。</li></ol><p>函数返回一个<code>napi_status</code>类型的值，这代表操作的结果。如果一切顺利，返回<code>napi_ok</code>。</p><h3 id="实际例子-5" tabindex="-1"><a class="header-anchor" href="#实际例子-5"><span>实际例子</span></a></h3><p>假设你正在开发一个 Node.js 原生模块，这个模块需要处理大量的数据，例如加密或者文件系统操作。而这些操作涉及到的数字可能非常大，大到不能用标准的 JavaScript 数字类型（Number）来精确地表示。</p><p>例如，我们需要创建一个表示文件大小的 BigInt，文件大小为<code>9223372036854775807</code>字节（这个值接近 64 位整型的最大值），以下是在 C++中使用<code>napi_create_bigint_int64</code>的示例代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数作为一个原生模块导出给JS调用</span></span>
<span class="line"><span>napi_value GetFileSizeAsBigInt(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 存储最终BigInt结果的变量</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 文件大小</span></span>
<span class="line"><span>  int64_t fileSize = 9223372036854775807;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建BigInt</span></span>
<span class="line"><span>  napi_status status = napi_create_bigint_int64(env, fileSize, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否成功创建BigInt</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 创建失败，可能需要处理错误</span></span>
<span class="line"><span>    // 例如抛出异常等</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回创建好的BigInt给JavaScript</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 其他将函数导出到JS的代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 JavaScript 代码调用这个原生模块时，它将会得到一个 BigInt 对象，可以安全地表示和操作这个巨大的数字。</p><p>总结一下，<code>napi_create_bigint_int64</code>在 Node.js 的原生模块开发中用于创建能表示超大整数的 BigInt 对象，从而使得这些模块能够处理超出 JavaScript Number 类型能力范围的数据。</p><h4 id="napi-create-bigint-uint64" tabindex="-1"><a class="header-anchor" href="#napi-create-bigint-uint64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_bigint_uint64" target="_blank" rel="noopener noreferrer">napi_create_bigint_uint64</a></span></a></h4><p>当然，让我来详细解释一下 Node.js 中的 <code>napi_create_bigint_uint64</code> 这个函数。</p><p>在 Node.js 中，N-API（Node API）是一个用于构建本地插件（native addons）的 API 层，它允许 C 和 C++代码与 JavaScript 交互。这意味着你可以用 C 或 C++编写一些性能密集或者系统级别的操作，并通过 N-API 暴露给你的 Node.js 应用程序使用。</p><p><code>napi_create_bigint_uint64</code> 是 N-API 的一部分，它用于创建一个表示大整数（BigInt）的 JavaScript 值。由于 JavaScript 中的 Number 类型不能安全地表示所有的 64 位整数（因为其双精度浮点格式只能精确表示到 53 位），BigInt 类型就出现了，它可以表示任意大小的整数。</p><h3 id="函数原型" tabindex="-1"><a class="header-anchor" href="#函数原型"><span>函数原型：</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_bigint_uint64(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    uint64_t value,</span></span>
<span class="line"><span>    napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是 N-API 调用的环境上下文，用于代表当前的 Node.js 环境。</li><li><code>value</code>: 这是你想要转换为 BigInt 的无符号 64 位整数（uint64_t）。</li><li><code>result</code>: 这是一个指向 napi_value 的指针，该函数会将创建的 BigInt 值存储在这里返回。</li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景：</span></a></h3><p>假设你正在编写一个 Node.js 本地插件，需要处理非常大的整数，比如文件系统中大文件的字节大小，或者某些高精度时间戳等。在 C/C++中，你可以使用标准的 64 位整数来精确表示这些值，但是如果你需要将这些值传递给 JavaScript，就会遇到精度问题。使用 <code>napi_create_bigint_uint64</code> 函数，你可以将 C/C++中的 64 位整数安全地转换为 JavaScript 的 BigInt。</p><h3 id="实际例子-6" tabindex="-1"><a class="header-anchor" href="#实际例子-6"><span>实际例子：</span></a></h3><p>想象一下，你有一个 C 函数，它返回了一个很大的文件的大小（以字节为单位），这个数字可能会超过 JavaScript Number 类型的安全整数范围。你可以使用 <code>napi_create_bigint_uint64</code> 将这个值转换为 BigInt：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数是从某处获取文件大小的</span></span>
<span class="line"><span>uint64_t get_large_file_size() {</span></span>
<span class="line"><span>    // 返回一个大于2^53的文件大小</span></span>
<span class="line"><span>    return (uint64_t)9007199254740993;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是暴露给Node.js的N-API函数</span></span>
<span class="line"><span>napi_value GetFileSizeAsBigInt(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    uint64_t file_size = get_large_file_size();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建BigInt</span></span>
<span class="line"><span>    napi_value big_int_value;</span></span>
<span class="line"><span>    napi_status status = napi_create_bigint_uint64(env, file_size, &amp;big_int_value);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return big_int_value; // 返回BigInt给JavaScript</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在你的 Node.js 代码中，你可以调用这个函数并获得一个能够安全表示大数字的 BigInt：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这将调用我们上面定义的C函数并返回一个BigInt</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fileSize</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">GetFileSizeAsBigInt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">fileSize</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出类似于：9007199254740993n</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在 JavaScript 端，BigInt 值末尾会有一个 &quot;n&quot; 来表示它是一个 BigInt 类型，而不是普通的 Number。</p><h4 id="napi-create-bigint-words" tabindex="-1"><a class="header-anchor" href="#napi-create-bigint-words"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_bigint_words" target="_blank" rel="noopener noreferrer">napi_create_bigint_words</a></span></a></h4><p>好的，让我们来聊一下 Node.js 中的<code>napi_create_bigint_words</code>这个功能。</p><p>首先解释一下，什么是 N-API。N-API 是一个 C 语言的 API，它允许你使用 C 或者 C++代码编写扩展，这些扩展可以直接被 Node.js 调用。这有助于提高性能，并允许重用已有的 C/C++库。</p><p>现在，谈到<code>napi_create_bigint_words</code>，这个函数是 N-API 提供的一部分，专门用来创建 JavaScript 中的 BigInt 类型。在 JavaScript 中，BigInt 是一种新的数值类型，它允许你安全地存储和操作大整数，甚至是超过了 Number 类型能表示的范围。</p><p>具体到<code>napi_create_bigint_words</code>，这个函数使得你可以从 C/C++层面创建一个 BigInt 对象，而不是从 JavaScript 创建。这在某些情况下非常有用，比如当你在一个 node 扩展中处理大整数时，或者当你想要将一个底层的数值库结果转换为 BigInt 使其在 JavaScript 中可用时。</p><p>让我们来看一个简单的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们的任务是创建一个代表2^64的BigInt</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateBigInt(napi_env env) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // BigInt由两部分组成：低位(low word)和高位(high word)</span></span>
<span class="line"><span>    // 通过二进制可以表示为 high_word `&lt;``&lt;` 64 | low_word。</span></span>
<span class="line"><span>    uint64_t low_word = 0; // 在我们的示例中，低位是0</span></span>
<span class="line"><span>    uint64_t high_word = 1; // 高位是1，因为2^64相当于1后面跟着64个0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 我们需要创建一个napi_value来存放我们即将创建的BigInt</span></span>
<span class="line"><span>    napi_value big_int_value;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用napi_create_bigint_words来创建BigInt</span></span>
<span class="line"><span>    // 参数解读：</span></span>
<span class="line"><span>    // env: 当前的环境上下文</span></span>
<span class="line"><span>    // sign_bit: 表示number是正还是负，0代表正数</span></span>
<span class="line"><span>    // word_count: 我们传递的words数量</span></span>
<span class="line"><span>    // words: 指向我们数值的指针</span></span>
<span class="line"><span>    // result: 输出参数，创建好的BigInt将被赋值到这里</span></span>
<span class="line"><span>    status = napi_create_bigint_words(env, 0, 1, &amp;high_word, &amp;big_int_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否创建成功</span></span>
<span class="line"><span>    if(status != napi_ok){</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to create BigInt&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return big_int_value;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个表示 2^64 的 BigInt 对象。我们首先声明了 <code>low_word</code> 和 <code>high_word</code>，然后调用<code>napi_create_bigint_words</code>来实际创建 BigInt 对象。注意，我们的<code>sign_bit</code>设置为 0，因为我们要创建的是一个正数。</p><p>如果你在构建更复杂的 node 扩展，在处理大整数问题时，就可能会用到这个函数。例如，你可能正在封装一个金融计算库，需要处理比标准 js Number 类型更大的数字，那么你就会在 C/C++层面使用<code>napi_create_bigint_words</code>来创建 BigInt，然后在你的 node 应用中使用它。</p><h4 id="napi-create-string-latin1" tabindex="-1"><a class="header-anchor" href="#napi-create-string-latin1"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_string_latin1" target="_blank" rel="noopener noreferrer">napi_create_string_latin1</a></span></a></h4><p>好的，我来解释一下 Node.js 中的<code>napi_create_string_latin1</code>这个函数。</p><p>在 Node.js 里，N-API 提供了一个与 JavaScript 引擎无关的原生（native）API，它允许你编写可以在不同版本的 Node.js 上运行的 C/C++扩展。<code>napi_create_string_latin1</code>是 N-API 中的一个功能，它允许你从 C/C++代码中创建一个新的 JavaScript 字符串。</p><p>当你在 C/C++中使用<code>napi_create_string_latin1</code>时，你可以将一个标准的以 null 结尾的 C 字符串（使用 Latin-1/ISO-8859-1 编码）转化成一个 JavaScript 字符串。Latin-1 编码包括英文字符和欧洲常用的其他一些字符。</p><p>这里有一些参数需要了解：</p><ul><li><code>env</code>: 这是一个表示 N-API 环境的句柄，它用于大多数 N-API 调用以提供 Node.js 运行时的上下文。</li><li><code>str</code>: 是 C 字符串的指针，表示要转换成 JavaScript 字符串的原始 Latin-1 编码的字符序列。</li><li><code>length</code>: 这是字符串的长度，如果你传递<code>-1</code>，函数将假定字符串是以 null 结尾的，并计算长度。</li><li><code>result</code>: 这是一个输出参数，用于接收创建的 JavaScript 字符串。</li></ul><p>现在举例说明：<br> 假设你想在 C/C++扩展中创建一个表示&quot;hello&quot;的 JavaScript 字符串。下面是如何使用<code>napi_create_string_latin1</code>实现的伪代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你已经有了napi_env env变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 要转换成JavaScript字符串的C字符串</span></span>
<span class="line"><span>const char* c_str = &quot;hello&quot;;</span></span>
<span class="line"><span>size_t str_length = 5; // 字符串&quot;hello&quot;的长度</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用napi_create_string_latin1来创建一个JavaScript字符串</span></span>
<span class="line"><span>napi_status status = napi_create_string_latin1(env, c_str, str_length, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 检查操作是否成功</span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>    // 如果成功，此时result就是一个JavaScript字符串</span></span>
<span class="line"><span>    // 可以在你的N-API函数中返回它，或者用它进行其他操作</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 错误处理</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实际应用中，你可能会在一个 N-API 模块的函数内部使用这种方式来创建 JavaScript 字符串，然后将其返回给 JavaScript 层的代码。例如，如果你正在编写一个读取某个硬件设备状态并返回一个字符串描述的扩展，你可能会从该设备读取数据，然后使用<code>napi_create_string_latin1</code>来创建一个相应的 JavaScript 字符串来描述那个状态。</p><h4 id="node-api-create-external-string-latin1" tabindex="-1"><a class="header-anchor" href="#node-api-create-external-string-latin1"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_create_external_string_latin1" target="_blank" rel="noopener noreferrer">node_api_create_external_string_latin1</a></span></a></h4><p><code>node_api_create_external_string_latin1</code> 是 Node.js 中的一个 N-API 函数。N-API 是一种用于构建本地插件的 API，它提供了与底层 Node.js JavaScript 运行时进行交互的方法。此函数特别用于创建“外部”字符串，这意味着它允许你将现有的字符数据作为 Node.js 中的 JavaScript 字符串使用，而不必复制数据。</p><p>在详细解释之前，先来理解几个概念：</p><ul><li><strong>N-API</strong>: Node.js 的一个稳定、版本无关的 API，用于构建原生插件。</li><li><strong>外部字符串（External string）</strong>: JavaScript 中的字符串，其内存是由开发者管理的，而非由 JavaScript 引擎管理。</li><li><strong>Latin1</strong>: 也称为 ISO-8859-1，是一个 8 位的单字节编码方案，可以表示西欧语系中的大多数字符。</li></ul><h3 id="功能" tabindex="-1"><a class="header-anchor" href="#功能"><span>功能</span></a></h3><p><code>node_api_create_external_string_latin1</code> 允许你把已经存在的 Latin1 编码的字符数组创建成一个 Node.js 的字符串。这样做的好处是避免了将现有字符串复制到新的内存位置，节省了时间和空间。</p><h3 id="参数" tabindex="-1"><a class="header-anchor" href="#参数"><span>参数</span></a></h3><p>这个函数接收以下参数：</p><ul><li><code>env</code>: 当前执行环境的句柄，提供给所有 N-API 调用。</li><li><code>data</code>: 指向你想要转换成 JavaScript 字符串的 Latin1 编码数据的指针。</li><li><code>length</code>: 数据的长度，单位是字节。</li><li><code>result</code>: 用来存放创建好的 JavaScript 字符串的变量。</li></ul><h3 id="使用场景举例-1" tabindex="-1"><a class="header-anchor" href="#使用场景举例-1"><span>使用场景举例</span></a></h3><p>假设你在 C/C++扩展模块中有一个以 Latin1 编码的字符串，并希望将它传递给 Node.js 中的 JavaScript 代码使用：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你有一个Latin1编码的字符串数据</span></span>
<span class="line"><span>const char* latin1_string = &quot;Hello, World!&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数会被调用来创建一个Node.js的String</span></span>
<span class="line"><span>napi_value CreateLatin1String(napi_env env) {</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 把外部Latin1编码的字符串转换为Node.js字符串</span></span>
<span class="line"><span>  napi_status status = node_api_create_external_string_latin1(</span></span>
<span class="line"><span>    env,</span></span>
<span class="line"><span>    latin1_string,</span></span>
<span class="line"><span>    NAPI_AUTO_LENGTH, // 自动计算字符串长度</span></span>
<span class="line"><span>    &amp;result</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result; // 返回创建的字符串</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 接下来，你需要将上面的函数暴露给Node.js ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码示例中，我们定义了一个名为 <code>CreateLatin1String</code> 的函数，它使用 <code>node_api_create_external_string_latin1</code> 来创建一个 Node.js 的字符串。我们传入了一个指向 Latin1 编码字符串的指针，告诉函数自动计算字符串的长度，并且提供了一个用于存放结果字符串的变量。成功调用后，<code>result</code> 将包含一个 Node.js 字符串，可以像任何其他字符串那样在 JavaScript 中使用。</p><h3 id="注意事项-2" tabindex="-1"><a class="header-anchor" href="#注意事项-2"><span>注意事项</span></a></h3><p>使用外部字符串时，需要确保在字符串仍然被使用时不要释放或修改底层的内存块。如果底层的数据被改变或删除，那么 JavaScript 中的字符串也会受到影响，可能导致程序崩溃或出现不可预测的行为。</p><p>总之，<code>node_api_create_external_string_latin1</code> 是一个强大的功能，它能够高效地将本地代码中的字符串数据转换为 JavaScript 字符串，但它需要开发者在内存管理方面进行额外的注意。</p><h4 id="napi-create-string-utf16" tabindex="-1"><a class="header-anchor" href="#napi-create-string-utf16"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_string_utf16" target="_blank" rel="noopener noreferrer">napi_create_string_utf16</a></span></a></h4><p>当然，我来帮你解释一下 <code>napi_create_string_utf16</code> 这个函数。</p><p>在 Node.js 中，<code>napi_create_string_utf16</code> 是 N-API 的一部分，而 N-API 是一个 C 语言的接口，让你可以创建本地插件。这些插件是用 C 或 C++写的，它们可以直接和 Node.js 的运行时进行交互，通常用于性能敏感的操作或者是调用系统级别、硬件相关的库。</p><p><code>napi_create_string_utf16</code> 函数用于在原生代码中创建一个 UTF-16 编码的 JavaScript 字符串。UTF-16 是一种字符编码方式，它能表示 Unicode 标准中的大部分字符，并且在 JavaScript 内部是默认的字符串编码。</p><p>下面是这个函数具体的描述：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_string_utf16(napi_env env,</span></span>
<span class="line"><span>                                     const char16_t* str,</span></span>
<span class="line"><span>                                     size_t length,</span></span>
<span class="line"><span>                                     napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数参数解释：</p><ul><li><code>env</code>: 当前 native API 的环境句柄，它是操作 N-API 的上下文。</li><li><code>str</code>: 指向 UTF-16 编码字符串的指针。</li><li><code>length</code>: 字符串的长度，用字符数表示。如果长度设置为 -1，则假定字符串以 null 终止符结束。</li><li><code>result</code>: 是一个出参，用于返回创建的 JavaScript 字符串。</li></ul><p>函数会返回一个<code>napi_status</code>枚举值，表示操作成功与否。如果函数执行成功，<code>result</code>将包含对应的 JavaScript 字符串值。</p><p>例子：</p><p>假设我们要在本地插件中创建一个 JavaScript 字符串 &quot;Hello, World!&quot; 并返回给 Node.js。首先，我们需要将这个字符串转换成 UTF-16 编码。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateUtf16String(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // UTF-16编码的 &quot;Hello, World!&quot; 字符串</span></span>
<span class="line"><span>  // 在C语言中，UTF-16字符串通常使用 char16_t 类型表示</span></span>
<span class="line"><span>  const char16_t str[] = u&quot;Hello, World!&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 我们知道这个字符串的长度，所以我们可以直接传入，</span></span>
<span class="line"><span>  // 如果不知道，也可以通过类似于计算null终止符的方式来获取长度</span></span>
<span class="line"><span>  size_t length = sizeof(str) / sizeof(char16_t) - 1; // 减去null终止符</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  // 调用函数创建JS字符串</span></span>
<span class="line"><span>  napi_status status = napi_create_string_utf16(env, str, length, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否成功</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回创建的字符串</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他代码用于注册该函数，使得它可以从Node.js中调用 ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Node.js 代码中，你可能会调用这个本地插件提供的函数像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./path_to_native_addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CreateUtf16String</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 应该打印出 &quot;Hello, World!&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在 C 代码中创建了一个 Javascript 字符串，然后在 Node.js 中打印出来。这只是一个简单的例子展示了如何利用<code>napi_create_string_utf16</code>函数在原生模块中创建和返回 JavaScript 字符串。</p><h4 id="node-api-create-external-string-utf16" tabindex="-1"><a class="header-anchor" href="#node-api-create-external-string-utf16"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_create_external_string_utf16" target="_blank" rel="noopener noreferrer">node_api_create_external_string_utf16</a></span></a></h4><p><code>node_api_create_external_string_utf16</code> 函数是 Node.js 中 N-API 提供的一个功能，它允许你在原生插件中创建一个新的 JavaScript 字符串，而这个字符串的内容实际上存储在外部分配的内存中（也就是说，不是由 V8 管理的内存）。使用这个函数可以帮助你高效地在原生代码和 JavaScript 之间传递大量文本数据，而无需复制字符串数据。</p><p>在了解如何使用 <code>node_api_create_external_string_utf16</code> 前，你需要知道几个基本概念：</p><ol><li><p><strong>UTF-16</strong>：这是一种编码方式，用于将字符表示为数字代码。UTF-16 可以编码世界上绝大多数的字符，并且每个字符使用 2 个或者更多的字节来表示。</p></li><li><p><strong>N-API</strong>：是 Node.js 提供的一个稳定的 API 层，让你可以构建原生插件，这样的插件可以直接运行在 Node.js 的底层引擎 V8 之上。</p></li><li><p><strong>原生插件</strong>：是使用 C 或 C++ 编写的模块，它们可以通过 Node.js 的 N-API 被加载和执行，提供比纯 JavaScript 更高效的性能，尤其是在处理大量数据时。</p></li></ol><p>下面是 <code>node_api_create_external_string_utf16</code> 函数的基本用法示例和解释：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个 UTF-16 编码的字符串，存在于外部分配的内存中</span></span>
<span class="line"><span>const char16_t* external_data = u&quot;Hello, World!&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数会被用来在后续清理外部分配的内存</span></span>
<span class="line"><span>void MyFinalizer(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    free(finalize_data);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateExternalStringUtf16(napi_env env) {</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 JavaScript 字符串，其内容链接到外部的 UTF-16 编码数据</span></span>
<span class="line"><span>    napi_status status = napi_create_external_string_utf16(</span></span>
<span class="line"><span>        env,</span></span>
<span class="line"><span>        external_data,</span></span>
<span class="line"><span>        NAPI_AUTO_LENGTH,   // 让 N-API 自动计算字符串长度</span></span>
<span class="line"><span>        &amp;result</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否正确执行</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的 JavaScript 字符串</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们首先包含了 <code>node_api.h</code> 头文件，这是使用 N-API 必须做的。然后，我们声明了一个 UTF-16 编码的字符串 <code>external_data</code> 和一个清理函数 <code>MyFinalizer</code>，当 JavaScript 字符串不再被需要时，<code>MyFinalizer</code> 会被调用来释放外部分配的内存。</p><p><code>CreateExternalStringUtf16</code> 函数是创建字符串的实际工作地方。我们调用了 <code>napi_create_external_string_utf16</code>，向它传递环境句柄 <code>env</code>、指向外部数据的指针 <code>external_data</code>、使用 <code>NAPI_AUTO_LENGTH</code> 让 API 自动计算字符串长度，最后传入一个指向 <code>napi_value</code> 变量的指针来接收创建出的 JavaScript 字符串。</p><p>注意，在实际应用中，你需要确保传递给 <code>napi_create_external_string_utf16</code> 的内存在字符串不再使用后得到释放，否则会产生内存泄漏。这通常是通过注册一个“finalizer”函数完成的，就像示例中的 <code>MyFinalizer</code> 那样。</p><p>通过这样的机制，Node.js 的 N-API 允许你在原生插件中处理字符串时，既可以达到高效率，又能够防止内存泄漏。</p><h4 id="napi-create-string-utf8" tabindex="-1"><a class="header-anchor" href="#napi-create-string-utf8"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_string_utf8" target="_blank" rel="noopener noreferrer">napi_create_string_utf8</a></span></a></h4><p><code>napi_create_string_utf8</code> 是 Node.js 中的一个 N-API 函数。N-API（Node API）是 Node.js 提供的一套 C 语言的 API，使得原生插件（通常用 C 或 C++编写）能够与 JavaScript 代码相互交互。这样，开发者就可以在 Node.js 环境中使用 C 或 C++ 编写高性能的本地插件。</p><h3 id="解释-napi-create-string-utf8" tabindex="-1"><a class="header-anchor" href="#解释-napi-create-string-utf8"><span>解释 <code>napi_create_string_utf8</code></span></a></h3><p><code>napi_create_string_utf8</code> 的作用是创建一个新的 UTF-8 编码的字符串，并将其表示为 N-API 中的 <code>napi_value</code> 类型。该函数允许你把一个 C 语言中的字符串（char* 类型），转换成可以在 Node.js 代码中作为 JavaScript 字符串使用的值。</p><h3 id="参数-1" tabindex="-1"><a class="header-anchor" href="#参数-1"><span>参数</span></a></h3><p>该函数通常接收以下几个参数：</p><ol><li><strong>env</strong>: 这是一个 <code>napi_env</code> 句柄，代表当前的 Node.js 环境。它是执行 N-API 调用的上下文。</li><li><strong>str</strong>: 指向以 null 结尾的 UTF-8 编码的字符串的指针。</li><li><strong>length</strong>: 字符串的长度（以字节为单位）。如果长度未知，可以传递 <code>-1</code>，函数会自动计算字符串长度。</li><li><strong>result</strong>: 指向 <code>napi_value</code> 的指针，用来接收创建好的 JavaScript 字符串。</li></ol><h3 id="返回值-2" tabindex="-1"><a class="header-anchor" href="#返回值-2"><span>返回值</span></a></h3><p>该函数返回一个 <code>napi_status</code> 枚举值，表示操作成功或失败的状态。</p><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><p>假设你已经有了一个 C 插件，并想要创建一个 JavaScript 字符串并返回给 JavaScript 端，以下是如何使用 <code>napi_create_string_utf8</code> 的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 示例函数，用于创建字符串返回</span></span>
<span class="line"><span>napi_value CreateString(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value str;</span></span>
<span class="line"><span>    // 创建一个 UTF-8 编码的 JavaScript 字符串 &quot;Hello, World!&quot;</span></span>
<span class="line"><span>    napi_status status = napi_create_string_utf8(env, &quot;Hello, World!&quot;, NAPI_AUTO_LENGTH, &amp;str);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否成功创建字符串</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误</span></span>
<span class="line"><span>        // 在实际应用中，你可能需要调用另一个 N-API 函数来抛出错误</span></span>
<span class="line"><span>        return nullptr;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果成功，返回创建的字符串</span></span>
<span class="line"><span>    return str;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册上面的示例函数到 Node.js</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 CreateString 包装为 JavaScript 可调用的函数</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, CreateString, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个函数作为模块导出</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;createString&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码创建了一个简单的函数 <code>CreateString</code>，这个函数可以在 JavaScript 中被调用，返回一个 &quot;Hello, World!&quot; 字符串。<code>NAPI_MODULE</code> 宏用于注册初始化函数，确保在模块载入时运行 <code>Init</code> 函数，这样 <code>createString</code> 就可以导出并在 Node.js 代码中使用了。</p><p>在 JavaScript 端，你可以像下面这样调用 <code>createString</code> 函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打印 &quot;Hello, World!&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，在实际应用中，处理 <code>napi_status</code> 返回值和错误检查非常重要，因为他们可以帮助识别问题所在。此外，在引入和使用原生模块前，需要先编译它们，通常是使用 node-gyp 这种工具。</p><h4 id="node-api-create-property-key-utf16" tabindex="-1"><a class="header-anchor" href="#node-api-create-property-key-utf16"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_create_property_key_utf16" target="_blank" rel="noopener noreferrer">node_api_create_property_key_utf16</a></span></a></h4><p><code>node_api_create_property_key_utf16</code> 是 Node.js 中的一个函数，它属于 N-API 的一部分。N-API（Node API）是一个用来构建原生插件的 API 层，允许你用 C 或 C++编写可以与 Node.js JavaScript 代码直接互操作的模块。</p><p>在 JavaScript 中，对象通常由键值对组成，即每个属性都有一个名称（键）和与之关联的值。在使用原生代码与 JavaScript 交互时，我们需要能够创建这些键，以便我们可以读取和设置 JavaScript 对象上的属性。</p><p>函数 <code>node_api_create_property_key_utf16</code> 具体用途是：创建一个 UTF-16 编码的字符串作为属性名，并将其注册到 JavaScript 运行时环境中，使得原生模块可以使用这个字符串作为对象的属性键。</p><p>详细解释：</p><ul><li>UTF-16 是 Unicode 字符集的一种编码方式，它采用 2 个字节或者更多来表示一个字符。</li><li>当你想要从原生模块（例如 C/C++模块）中定义一个新的属性并且给 JavaScript 对象赋值时，你需要使用这个函数来创建属性名。</li></ul><p>实际应用例子：<br> 假设你正在编写一个原生模块，该模块需要给 JavaScript 中的某个对象添加一个名为“exampleProperty”的新属性。你可以通过以下步骤使用 <code>node_api_create_property_key_utf16</code>：</p><ol><li>在你的 C/C++代码中，你首先定义一个 UTF-16 编码的字符串，表示你要创建的属性名。</li><li>然后，你调用 <code>node_api_create_property_key_utf16</code> 函数，传入你的 N-API 环境、UTF-16 字符串及其长度，该函数会返回一个用于标识这个属性的 N-API 值。</li><li>最后，你可以使用这个属性键在 JavaScript 对象上设置或获取对应的属性值。</li></ol><p>下面是一个简化的代码示例，演示如何使用 <code>node_api_create_property_key_utf16</code> 创建属性键：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateExampleProperty(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 定义UTF-16字符串，代表你想要的属性名称，比如“exampleProperty”。</span></span>
<span class="line"><span>  const char16_t property_name[] = u&quot;exampleProperty&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个属性键变量。</span></span>
<span class="line"><span>  napi_value property_key;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用函数创建属性键。</span></span>
<span class="line"><span>  napi_status status = napi_create_property_key_utf16(env,</span></span>
<span class="line"><span>                                                      property_name,</span></span>
<span class="line"><span>                                                      sizeof(property_name) - 1, // 减去字符串结束符 \0 的长度</span></span>
<span class="line"><span>                                                      &amp;property_key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查是否成功创建了属性键。</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 这里假设 &quot;object&quot; 是已经在其他地方创建好的JavaScript对象。</span></span>
<span class="line"><span>  napi_value object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 使用属性键在对象上设置属性。</span></span>
<span class="line"><span>  // 这里只是示例流程，你还需要创建实际的值（value）并设置到对象上。</span></span>
<span class="line"><span>  napi_value value;</span></span>
<span class="line"><span>  // ...创建或获取value...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  status = napi_set_property(env, object, property_key, value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回新创建的属性值，或者其他什么东西。</span></span>
<span class="line"><span>  return value;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，在实际编写的过程中，还需要考虑错误处理和确保正确调用 N-API 提供的其他函数进行完整的功能实现。上述代码仅展示了如何使用<code>node_api_create_property_key_utf16</code>函数。</p><h3 id="functions-to-convert-from-node-api-to-c-types" tabindex="-1"><a class="header-anchor" href="#functions-to-convert-from-node-api-to-c-types"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#functions-to-convert-from-node-api-to-c-types" target="_blank" rel="noopener noreferrer">Functions to convert from Node-API to C types</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。它允许你在服务器端运行 JavaScript 代码。Node-API（之前称为 N-API）是 Node.js 的一个功能，它提供了一组 API，使得原生模块（通常用 C 或 C++编写）能够与 JavaScript 代码进行互操作。</p><p>在 Node-API 中，“Functions to convert from Node-API to C types”意味着有一组特定的函数可以帮助开发者将从 JavaScript 接收的数据转换成 C 语言中的数据类型，以便在 C/C++ 编写的原生模块中使用。</p><p>这些函数通常涉及以下几个方面：</p><ol><li><strong>转换数字</strong>：比如把 JavaScript 中的 <code>Number</code> 转换为 C 中的 <code>int</code>, <code>float</code>, <code>double</code> 等。</li><li><strong>转换字符串</strong>：将 JavaScript 字符串转换成 C 风格的字符串（即以 null 结尾的字符数组）。</li><li><strong>转换对象</strong>：如果 JavaScript 对象需要在 C 代码中处理，可能需要转换为对应的 C 结构体。</li><li><strong>转换函数</strong>：将 JavaScript 中的函数转换为可以在 C 代码中调用的回调。</li></ol><p>现在，让我们通过一些例子来说明如何使用 Node-API 进行类型转换。</p><h3 id="示例-1-转换数字" tabindex="-1"><a class="header-anchor" href="#示例-1-转换数字"><span>示例 1：转换数字</span></a></h3><p>假设您的 JavaScript 代码传递了一个数字给原生模块，并且您想要在 C 代码中以 <code>double</code> 类型使用它。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    double number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 传入的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将第一个参数转换为 C 的 double 类型</span></span>
<span class="line"><span>    status = napi_get_value_double(env, argv[0], &amp;number);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 现在你可以在 C 代码中使用变量 number 了</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果到 JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_create_double(env, number * 2, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="示例-2-转换字符串" tabindex="-1"><a class="header-anchor" href="#示例-2-转换字符串"><span>示例 2：转换字符串</span></a></h3><p>假设您接收到了一个 JavaScript 字符串，并希望在原生模块中作为 C 字符串处理。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>#include `&lt;`string.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    size_t str_length, str_length_in_bytes;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 传入的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 第一步，获取字符串长度</span></span>
<span class="line"><span>    status = napi_get_value_string_utf8(env, argv[0], NULL, 0, &amp;str_length_in_bytes);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 准备足够大小的缓冲区来存储 C 字符串</span></span>
<span class="line"><span>    char* c_str = (char*)malloc(str_length_in_bytes + 1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 第二步，实际复制字符串内容</span></span>
<span class="line"><span>    status = napi_get_value_string_utf8(env, argv[0], c_str, str_length_in_bytes + 1, &amp;str_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 现在您可以使用 c_str 作为 C 字符串</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 清理分配的内存</span></span>
<span class="line"><span>    free(c_str);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 处理结束后返回 undefined 给 JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="示例-3-转换函数-回调" tabindex="-1"><a class="header-anchor" href="#示例-3-转换函数-回调"><span>示例 3：转换函数（回调）</span></a></h3><p>如果 JavaScript 传递了一个函数作为回调给原生模块，我们可能希望在某个事件发生时调用它。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CallJavaScriptCallback(napi_env env, napi_value js_callback) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们想要回调 JavaScript 函数并传递一个参数给它</span></span>
<span class="line"><span>    napi_value arg;</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;Hello from native!&quot;, NAPI_AUTO_LENGTH, &amp;arg);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value global;</span></span>
<span class="line"><span>    status = napi_get_global(env, &amp;global);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_call_function(env, global, js_callback, 1, &amp;arg, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 回调函数已调用</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 传入的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保传入的参数是一个函数</span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    status = napi_typeof(env, argv[0], &amp;valuetype);</span></span>
<span class="line"><span>    if (valuetype != napi_function) {</span></span>
<span class="line"><span>        // 抛出错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 存储或直接使用 JavaScript 提供的回调函数</span></span>
<span class="line"><span>    CallJavaScriptCallback(env, argv[0]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 处理结束后返回 undefined 给 JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些例子演示了如何使用 Node-API 提供的函数将 JavaScript 中的数据类型转换为适合 C/C++ 使用的数据类型。这是创建原生插件和模块时非常重要的一个步骤，因为这样才能确保数据在不同语言间正确无误地传递和处理。</p><h4 id="napi-get-array-length" tabindex="-1"><a class="header-anchor" href="#napi-get-array-length"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_array_length" target="_blank" rel="noopener noreferrer">napi_get_array_length</a></span></a></h4><p>好的，Node.js 的 N-API 是一个用于构建原生插件的接口。N-API 旨在提供一个与 JavaScript 运行时无关的抽象层，这样您编写的代码就可以在不同版本的 Node.js 中运行，而无需重新编译。</p><p><code>napi_get_array_length</code> 函数是 N-API 提供的一个功能，它允许你在原生模块中获取一个 JavaScript 数组的长度。当你在 C 或 C++ 编写的扩展中与 JavaScript 数组打交道时，你可能需要知道数组有多少项，这个函数正是用来帮助你这么做的。</p><p>这里有一个简单的例子说明 <code>napi_get_array_length</code> 是如何工作的：</p><p>假设你有一个 JavaScript 数组，并且你想通过一个原生插件来处理这个数组。在原生插件的代码中，你将获得一个 <code>napi_value</code> 类型的引用，指向这个数组。要获取该数组的长度，你将使用 <code>napi_get_array_length</code> 函数。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 函数用于获取数组长度</span></span>
<span class="line"><span>napi_status GetArrayLength(napi_env env, napi_value array, uint32_t* result) {</span></span>
<span class="line"><span>    return napi_get_array_length(env, array, result);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中:</p><ul><li><code>env</code> 是一个 <code>napi_env</code> 句柄，它代表了 N-API 调用上下文。</li><li><code>array</code> 是一个 <code>napi_value</code>，表示你想获取长度的 JavaScript 数组。</li><li><code>result</code> 是一个指向 <code>uint32_t</code> 变量的指针，在调用此函数后，它将被设置为数组的长度。</li></ul><p>假设你已经在 JavaScript 中创建了一个数组并传递给了这个原生函数:</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当你在原生代码中调用 <code>GetArrayLength</code> 并将 <code>myArray</code> 作为参数传递时，<code>result</code> 将会被设置为 <code>5</code>，因为 <code>myArray</code> 包含五个元素。</p><p>请注意，这只是展示 <code>napi_get_array_length</code> 功能的一个简化的例子，实际上在原生模块中使用时，你还需要进行错误检查和合适的异常处理来确保代码的健壮性。</p><h4 id="napi-get-arraybuffer-info" tabindex="-1"><a class="header-anchor" href="#napi-get-arraybuffer-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_arraybuffer_info" target="_blank" rel="noopener noreferrer">napi_get_arraybuffer_info</a></span></a></h4><p><code>napi_get_arraybuffer_info</code> 是 Node.js 中的 Native API（N-API）的一部分，它允许原生插件与 JavaScript 代码交互。Node.js 的 N-API 是一个用于构建原生插件的稳定层，使得开发者可以不受 Node.js 版本更迭影响的情况下编写和维护扩展模块。</p><p>在解释 <code>napi_get_arraybuffer_info</code> 之前，我们需要了解一下 JavaScript 中的 ArrayBuffer 对象。ArrayBuffer 是一种用来表示一个固定长度的二进制数据缓冲区的对象，在这个缓冲区中，你可以存储任何类型的二进制数据。这对于处理像文件、图像或其他二进制流的数据是非常有用的。</p><p>现在，让我们来详细看看 <code>napi_get_arraybuffer_info</code> 这个函数做什么：</p><p>当你使用 N-API 编写原生代码时（比如 C 或者 C++），并且需要操作或访问由 JavaScript 代码创建的 ArrayBuffer 对象时，你就会用到 <code>napi_get_arraybuffer_info</code> 这个函数。这个函数帮助你从一个给定的 N-API 值中检索 ArrayBuffer 相关的信息，并提供对实际的二进制数据的直接访问权限。</p><p>函数原型大概是这样的：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_arraybuffer_info(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    napi_value arraybuffer,</span></span>
<span class="line"><span>    void** data,</span></span>
<span class="line"><span>    size_t* length);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明：</p><ul><li><code>env</code>: 当前环境的句柄，它是 N-API 函数进行交互的上下文。</li><li><code>arraybuffer</code>: 一个 N-API 值，代表 JavaScript 中的 ArrayBuffer 对象。</li><li><code>data</code>: 这是一个输出参数，用来接收缓冲区的指针，即 ArrayBuffer 中数据的开始地址。</li><li><code>length</code>: 这也是一个输出参数，用来接收 ArrayBuffer 的长度（字节为单位）。</li></ul><p>返回值：</p><ul><li>这个函数返回一个 <code>napi_status</code> 枚举，表示函数调用是否成功。如果返回 <code>napi_ok</code>，则表示没有错误。</li></ul><h3 id="实战例子" tabindex="-1"><a class="header-anchor" href="#实战例子"><span>实战例子</span></a></h3><p>假设我们正在编写一个 Node.js 插件，该插件需要读取通过 JavaScript 传递过来的二进制图像数据，并且我们想要获取这些数据以及它们的大小，那么 <code>napi_get_arraybuffer_info</code> 就派上了用场。</p><p>首先，JavaScript 端可能有以下代码来创建一个 ArrayBuffer，并将其传递给原生模块：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设我们有一个图像文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> imageBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;path/to/image.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 创建 ArrayBuffer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> arrayBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">imageBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 将 Node.js Buffer 数据复制到 ArrayBuffer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">arrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Uint8Array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">imageBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用原生模块处理图像</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">processImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">arrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在原生模块中，我们可能会这样使用 <code>napi_get_arraybuffer_info</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个 N-API 应用程序中由 JavaScript 调用的函数</span></span>
<span class="line"><span>napi_value ProcessImage(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保我们获得了正确的参数数目</span></span>
<span class="line"><span>    if (status != napi_ok || argc `&lt;` 1) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void* bufferData;</span></span>
<span class="line"><span>    size_t bufferLength;</span></span>
<span class="line"><span>    status = napi_get_arraybuffer_info(env, args[0], &amp;bufferData, &amp;bufferLength);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保 ArrayBuffer 成功被获取</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 在这里，我们可以使用 bufferData 和 bufferLength 来操作图像数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一些值或 `undefined`</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化代码，注册上述函数...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们定义了一个 <code>ProcessImage</code> 函数，这个函数首先从 JavaScript 传递的参数中获取 ArrayBuffer 对象，然后用 <code>napi_get_arraybuffer_info</code> 来获取指向实际数据的指针和数据的长度。这样一来，我们就可以在原生代码中直接操作这些数据了。</p><h4 id="napi-get-buffer-info" tabindex="-1"><a class="header-anchor" href="#napi-get-buffer-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_buffer_info" target="_blank" rel="noopener noreferrer">napi_get_buffer_info</a></span></a></h4><p>当然，我会详细地解释 <code>napi_get_buffer_info</code> 这个函数。首先，让我们了解下什么是 N-API 和 Node.js 中的 Buffer。</p><p>N-API 是 Node.js 的一个 C API，它用于创建本地插件。这意味着如果你想在 Node.js 中使用 C/C++编写的代码，你可能会使用到 N-API。Buffer 在 Node.js 中通常被用来处理二进制数据流，比如读取文件、网络通信等场景。</p><p>现在，谈谈 <code>napi_get_buffer_info</code> 函数。这个函数是 N-API 提供的一个接口，它允许你从一个 JavaScript Buffer 对象中获取原始的内存信息。内存信息指的是数据存储的位置（一个指向内存的指针）和数据的长度。</p><p><code>napi_get_buffer_info</code> 的具体作用是：</p><ul><li>它帮助你从 Node.js 的 Buffer 对象获取到底层的字节数据和大小。</li><li>它通常在编写本地插件时使用，当需要直接操作或访问 Buffer 对象内部数据时。</li></ul><p>函数的签名大致如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_buffer_info(</span></span>
<span class="line"><span>  napi_env env,            // [in] N-API环境句柄</span></span>
<span class="line"><span>  napi_value value,        // [in] 要检索信息的Buffer对象</span></span>
<span class="line"><span>  void** data,             // [out] 指向Buffer数据的指针的指针</span></span>
<span class="line"><span>  size_t* length           // [out] Buffer数据长度的指针</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举个例子，假设你有一个 Node.js Buffer 对象，你正在编写一个本地插件，并且想要得到这个 Buffer 的数据和它的长度，以便进行一些底层的操作。</p><p>你可以这样使用 <code>napi_get_buffer_info</code>：</p><ol><li>创建一个 Buffer 对象，在 JavaScript 环境中。</li><li>在你的 C/C++ 插件代码中，调用 <code>napi_get_buffer_info</code>。</li><li><code>napi_get_buffer_info</code> 将返回指向 Buffer 数据的指针和数据的长度。</li><li>使用这些信息，你可以在你的插件中对数据进行处理。</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 args[0] 是传递给本地函数的 Buffer 对象</span></span>
<span class="line"><span>napi_value SomeNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  void* buffer_data;</span></span>
<span class="line"><span>  size_t buffer_length;</span></span>
<span class="line"><span>  napi_get_buffer_info(env, args[0], &amp;buffer_data, &amp;buffer_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在我们拿到了 buffer_data 指针和 buffer_length，</span></span>
<span class="line"><span>  // 可以进行后续操作，比如读取数据或者修改数据。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return NULL; // 根据情况返回相应的值或对象</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这段代码，你可以操作 JS 层面的 Buffer 对象在内存中的数据。记住，直接操作内存数据可以提高性能，因为避免了不必要的复制，但同时也需要小心处理，防止破坏数据结构，引发安全问题或造成内存泄漏。</p><p><code>napi_get_buffer_info</code> 是 Node.js 中用于本地插件开发的重要工具，特别是当处理性能敏感型操作或需要将数据在 Node.js 和本地代码之间传递时。</p><h4 id="napi-get-prototype" tabindex="-1"><a class="header-anchor" href="#napi-get-prototype"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_prototype" target="_blank" rel="noopener noreferrer">napi_get_prototype</a></span></a></h4><p>当然，很乐意为你解释。N-API（Node.js API）是一个用来构建原生插件的 API。在 Node.js 中，原生插件指的是用 C 或者 C++编写的模块，这些模块可以直接调用 Node.js 底层 API 以及 V8（Node.js 的 JavaScript 引擎）提供的功能。</p><p><code>napi_get_prototype</code>是 N-API 的一个函数，它允许你取得某个 JavaScript 对象的原型。&quot;原型&quot;是 JavaScript 中的一个重要概念，几乎所有的 JavaScript 对象都有一个与之关联的原型对象，该原型对象定义了一系列可被继承的属性和方法。</p><p>在 JavaScript 中，通常使用<code>object.__proto__</code>或者<code>Object.getPrototypeOf(object)</code>获取对象的原型。但是在 C/C++编码的原生模块中，我们需要使用 N-API 提供的函数，比如<code>napi_get_prototype</code>，来实现相同的操作。</p><p>以下是<code>napi_get_prototype</code>函数的简单说明：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_prototype(napi_env env, napi_value js_object, napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是表示当前 N-API 环境的句柄，它是与当前回调相关联的上下文。</li><li><code>js_object</code>: 这是你想要获取原型的 JavaScript 对象。</li><li><code>result</code>: 这是一个指向<code>napi_value</code>的指针，函数执行成功后，它会指向输入对象的原型。</li></ul><p>如果函数调用成功，返回值会是<code>napi_ok</code>，表明没有错误发生。</p><p>现在让我们通过一个假设的例子来看<code>napi_get_prototype</code>是如何工作的：</p><p>假设在 JavaScript 中，你有一个基于类<code>Animal</code>创建的实例<code>dog</code>。在这个类中，有一个方法叫<code>makeSound</code>。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  makeSound</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Some sound&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> dog</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在一个原生 Node.js 模块中，你可能想要获取这个<code>dog</code>对象的原型，并检查是否存在<code>makeSound</code>方法。你可以这样做：</p><ol><li>你首先使用<code>napi_create_reference</code>将<code>dog</code>对象包裹起来，使其可以在原生代码中安全地使用。</li><li>然后，你调用<code>napi_get_prototype</code>来获取<code>dog</code>对象的原型。</li><li>最后，你可能会使用<code>napi_has_property</code>来检查这个原型对象上是否有<code>makeSound</code>这个方法。</li></ol><p>在 C/C++代码中大致的步骤如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设你已经从某处获得了 &#39;dog&#39; 对象的 napi_value 表示.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value dog_prototype;</span></span>
<span class="line"><span>napi_status status = napi_get_prototype(env, dog, &amp;dog_prototype);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool has_makeSound;</span></span>
<span class="line"><span>status = napi_has_property(env, dog_prototype, &quot;makeSound&quot;, &amp;has_makeSound);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在 you can do something with the information whether the prototype has makeSound method.</span></span>
<span class="line"><span>if (has_makeSound) {</span></span>
<span class="line"><span>    // Prototype has the makeSound method.</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // Prototype does not have the makeSound method.</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这只是一个抽象的例子，实际上你可能还需要进行更多的错误检查和资源管理。希望这个解释对你有所帮助，让你更好地理解<code>napi_get_prototype</code>的作用和如何在原生 Node.js 模块中使用它。</p><h4 id="napi-get-typedarray-info" tabindex="-1"><a class="header-anchor" href="#napi-get-typedarray-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_typedarray_info" target="_blank" rel="noopener noreferrer">napi_get_typedarray_info</a></span></a></h4><p>Node.js 中的 N-API 是一个底层的 API，允许你用 C 语言编写的代码与 JavaScript 代码进行交互，这在创建或使用原生插件时非常有用。<code>napi_get_typedarray_info</code>是 N-API 提供的一个函数，让你能够从 C 语言的角度获取 JavaScript 中的 TypedArray（类型化数组）的相关信息。</p><p>在 JavaScript 中，TypedArray 是一种特殊的数组，它允许你用一个固定类型的数据来创建一个数组。例如，一个<code>Float32Array</code>就是只包含 32 位浮点数的数组。这对于需要高性能处理如音频数据、图像处理等场景非常有用。</p><p>现在，如果你在一个原生模块中需要操作一个从 JavaScript 传递过来的 TypedArray，你就可以使用<code>napi_get_typedarray_info</code>函数来了解这个 TypedArray 的详细信息，比如它的类型、长度、以及内存中的位置。</p><p>下面是<code>napi_get_typedarray_info</code>的基本使用方法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设 napi_env env 和 napi_value typed_array 是已经提供的参数。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_typedarray_type type;</span></span>
<span class="line"><span>size_t length;</span></span>
<span class="line"><span>void* data;</span></span>
<span class="line"><span>size_t byte_offset;</span></span>
<span class="line"><span>size_t byte_length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>status = napi_get_typedarray_info(</span></span>
<span class="line"><span>  env,           // N-API环境句柄</span></span>
<span class="line"><span>  typed_array,   // JavaScript中的类型化数组</span></span>
<span class="line"><span>  &amp;type,         // 这里将返回类型化数组的类型</span></span>
<span class="line"><span>  &amp;length,       // 这里将返回元素的个数</span></span>
<span class="line"><span>  &amp;data,         // 这里将返回指向数据的指针</span></span>
<span class="line"><span>  NULL,          // 如果不关心 ArrayBuffer，这里可以传 NULL</span></span>
<span class="line"><span>  &amp;byte_offset,  // 数据在 ArrayBuffer 中的字节偏移量</span></span>
<span class="line"><span>  &amp;byte_length   // 数据的字节长度</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  // 现在你可以根据 type 来知道数组中的数据类型，</span></span>
<span class="line"><span>  // 使用 data 指针访问数组中的实际数据，</span></span>
<span class="line"><span>  // 并通过 length 获取数组中元素的数量。</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是几个实际的运用例子：</p><ol><li><p><strong>处理图形数据</strong>：假设你正在编写一个 Node.js 的图像处理模块，JavaScript 传递了一个包含图像像素数据的<code>Uint8Array</code>给你的原生模块。你可以用<code>napi_get_typedarray_info</code>来获取这个数组的具体信息，并进行图像处理算法的应用，如滤镜、颜色调整等。</p></li><li><p><strong>音频编码/解码</strong>：如果你的原生模块是用来处理音频数据的，JavaScript 可能会传递一个<code>Float32Array</code>包含音频样本。你可以用<code>napi_get_typedarray_info</code>获得所需信息并对音频数据进行编码或解码处理。</p></li><li><p><strong>科学计算</strong>：科学计算往往需要处理大量的数值数据，JavaScript 端可能会传输<code>Float64Array</code>类型的 TypedArray 作为数据集。你的原生模块可以使用<code>napi_get_typedarray_info</code>来访问这些数据执行复杂的数学计算，如矩阵运算、统计分析等。</p></li></ol><h4 id="napi-get-dataview-info" tabindex="-1"><a class="header-anchor" href="#napi-get-dataview-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_dataview_info" target="_blank" rel="noopener noreferrer">napi_get_dataview_info</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API，它允许 JavaScript 代码和 C/C++代码之间进行交互。这样你可以在 Node.js 程序中使用 C/C++编写的高性能代码。<code>napi_get_dataview_info</code>是 N-API 的一部分，它用来获取<code>DataView</code>对象的详细信息。</p><p>那么，什么是 DataView 呢？在 JavaScript 中，<code>ArrayBuffer</code>是一种存储二进制数据的方式，而<code>DataView</code>提供了一个低级别的接口来读取和写入<code>ArrayBuffer</code>的不同类型的数据。</p><p>函数<code>napi_get_dataview_info</code>会告诉我们一个<code>DataView</code>对象里面有关于<code>ArrayBuffer</code>的哪些信息：</p><ul><li><code>byte_offset</code>：这是<code>DataView</code>开始读数据的地方在<code>ArrayBuffer</code>中的偏移量。</li><li><code>byte_length</code>：这是<code>DataView</code>可以读数据的长度。</li><li><code>arraybuffer</code>：这实际上就是底层的<code>ArrayBuffer</code>对象。</li></ul><p>现在，让我们通过例子来说明这个函数是怎么工作的。</p><p>假设你在 C/C++扩展模块中有以下的 N-API 函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设某个已经绑定好的函数，当从JS调用时候执行</span></span>
<span class="line"><span>napi_value GetDataviewInfo(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取DataView相关信息</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span>    size_t byte_offset;</span></span>
<span class="line"><span>    size_t byte_length;</span></span>
<span class="line"><span>    napi_value arraybuffer;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    status = napi_get_dataview_info(</span></span>
<span class="line"><span>        env,</span></span>
<span class="line"><span>        args[0], // 这里args[0]是从JS传进来的DataView对象</span></span>
<span class="line"><span>        &amp;byte_length,</span></span>
<span class="line"><span>        &amp;data,</span></span>
<span class="line"><span>        &amp;arraybuffer,</span></span>
<span class="line"><span>        &amp;byte_offset</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保调用成功</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Unable to get DataView information&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 根据获取到的信息可以做进一步处理，比如读取或者写入数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果给JS...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册GetDataviewInfo到exports对象</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value dataview_info_func;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, GetDataviewInfo, NULL, &amp;dataview_info_func);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;getDataviewInfo&quot;, dataview_info_func);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 中，你可能会这样使用这个扩展模块来获取<code>DataView</code>的信息：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/my-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> view</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> DataView</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用我们的C/C++扩展函数来获取DataView的信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> info</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getDataviewInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这里将打印出DataView的偏移量、长度等信息</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子显示了如何在 Node.js 的 N-API 中使用<code>napi_get_dataview_info</code>函数来从 JavaScript 传递的<code>DataView</code>对象中提取信息。这在你需要在本地扩展模块中处理二进制数据时非常有用。</p><h4 id="napi-get-date-value" tabindex="-1"><a class="header-anchor" href="#napi-get-date-value"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_date_value" target="_blank" rel="noopener noreferrer">napi_get_date_value</a></span></a></h4><p>好的，我来解释一下 <code>napi_get_date_value</code> 函数在 Node.js 中的作用及其运用。</p><p>首先我们需要知道 N-API 是什么。简单来说，N-API 是 Node.js 提供的一个 C 语言 API 层，它允许你用 C 或者 C++编写代码来构建原生插件。原生插件是指直接与底层操作系统进行交互的模块，这通常用于性能关键的操作或者调用系统级别的 API。</p><p>现在，介绍 <code>napi_get_date_value</code> 函数：</p><p>这个函数的目的是从一个 JavaScript Date 对象中提取出表示日期和时间的数值。在 JavaScript 中，日期和时间被存储为自 1970 年 1 月 1 日 UTC（协调世界时）以来的毫秒数，这也被称作时间戳。</p><p><code>napi_get_date_value</code> 函数作为 N-API 的一部分，允许你在编写扩展代码时（比如用 C/C++），获取 JavaScript Date 对象所代表的时间戳。</p><p>函数的定义大致如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_date_value(napi_env env,</span></span>
<span class="line"><span>                                napi_value value,</span></span>
<span class="line"><span>                                double* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：当前执行环境的句柄。</li><li><code>value</code>：一个 napi_value 类型的变量，它应该是一个 JavaScript Date 对象。</li><li><code>result</code>：一个指向 double 类型变量的指针，函数会将 Date 对象的时间戳以毫秒为单位存储在这个变量里。</li></ul><p>如果函数成功执行，它会返回 <code>napi_ok</code>。</p><p>现在让我们举一个例子：</p><p>假设你正在编写一个 Node.js 的原生插件，这个插件需要处理 JavaScript 传递过来的日期数据，然后进行一些复杂的操作，例如与其他系统的日期/时间交互，或者执行一些性能密集型的日期计算。</p><p>在 C++代码中，你可能会这样使用 <code>napi_get_date_value</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数被假定为N-API暴露给JavaScript的函数</span></span>
<span class="line"><span>napi_value ProcessDate(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取JavaScript传递的参数</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, args, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 确保获得了一个参数，并且该参数是一个Date对象</span></span>
<span class="line"><span>  if (status != napi_ok || argc `&lt;` 1) {</span></span>
<span class="line"><span>    // Handle error...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 提取Date对象的时间戳</span></span>
<span class="line"><span>  double dateValue;</span></span>
<span class="line"><span>  status = napi_get_date_value(env, args[0], &amp;dateValue);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // Handle error...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 在这里，你可以利用dateValue变量（它包含了时间戳）来执行你的操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 做完所有处理后，返回结果到JavaScript</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  status = napi_create_double(env, dateValue, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // Handle error...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码展示了如何在一个 N-API 函数内部获取 JavaScript 传递的 Date 对象参数，并将其转换为表示时间戳的数字，然后用这个值做进一步的处理。</p><p>在 JavaScript 端的调用可能会是这样的：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> jsDate</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;2023-01-01T00:00:00Z&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> timestamp</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">ProcessDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">jsDate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">timestamp</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出对应的时间戳</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>native-addon</code> 是我们假设的原生模块名字，它通过 <code>ProcessDate</code> 函数暴露给 JavaScript，JavaScript 端创建了一个 Date 实例并传递给了这个函数，然后得到了相应的时间戳输出。</p><p>希望这个解释和例子能够帮助你理解 <code>napi_get_date_value</code> 函数在 Node.js 中的用法。</p><h4 id="napi-get-value-bool" tabindex="-1"><a class="header-anchor" href="#napi-get-value-bool"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_bool" target="_blank" rel="noopener noreferrer">napi_get_value_bool</a></span></a></h4><p>好的，我来解释一下 Node.js 中 <code>napi_get_value_bool</code> 这个 API 的作用和应用场景。</p><p>首先，<code>napi_get_value_bool</code> 是 Node.js 的 N-API 接口中的一个函数，它用于将一个 JavaScript 值从 JavaScript 环境转换成 C 或者 C++ 环境中的原生布尔值类型（即 <code>bool</code> 类型）。</p><p>在 JavaScript 中，有五种数据类型被称为 &quot;Falsy&quot; 值，它们包括：<code>false</code>, <code>0</code>, <code>-0</code>, <code>&quot;&quot;</code> (空字符串), <code>null</code>, <code>undefined</code>, 和 <code>NaN</code>。除这些之外的其他所有值都被视为 &quot;Truthy&quot; 值，即在布尔上下文中会被当作真值处理。当我们使用 <code>napi_get_value_bool</code> 函数时，JavaScript 中的值会被转换为它对应的布尔值。</p><p>现在，让我们通过一个简单的例子来理解这个函数的工作原理。</p><p>假设你有如下的 JavaScript 代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 在 JavaScript 中定义了两个变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> jsTruthyValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这是一个 Truthy 值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> jsFalsyValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这是一个 Falsy 值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你正在编写一个 Node.js 的扩展模块，并希望在你的 C++ 代码中获取这些 JavaScript 变量的布尔值表示形式，你可以使用 <code>napi_get_value_bool</code> 函数来实现。</p><p>以下是一个如何在 C++ 扩展模块中使用 <code>napi_get_value_bool</code> 函数的大致示例：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 args[0] 是传递给我们扩展函数的第一个参数</span></span>
<span class="line"><span>napi_status status;</span></span>
<span class="line"><span>bool cBoolValue;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取 JavaScript 中传入的第一个参数的布尔值</span></span>
<span class="line"><span>status = napi_get_value_bool(env, args[0], &amp;cBoolValue);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在 cBoolValue 就包含了传入的 JavaScript 值的布尔值表示</span></span>
<span class="line"><span>printf(&quot;The boolean value is: %s\n&quot;, cBoolValue ? &quot;true&quot; : &quot;false&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，你可以看到 <code>napi_get_value_bool</code> 是如何工作的。它接收三个参数：</p><ul><li><code>env</code>：当前的 N-API 环境句柄。</li><li><code>args[0]</code>：你想转换成布尔值的 JavaScript 值。</li><li><code>&amp;cBoolValue</code>：一个指向原生 <code>bool</code> 变量的指针，函数执行成功后，这个变量就会包含转换后的布尔值。</li></ul><p>一旦调用 <code>napi_get_value_bool</code> 成功执行，原生的 <code>bool</code> 变量 <code>cBoolValue</code> 就会被设置为 <code>true</code> 或 <code>false</code>，取决于传入的 JavaScript 值是 Truthy 还是 Falsy。</p><p>在你的 Node.js 项目中，如果你需要在原生 C/C++ 代码里正确处理 JavaScript 环境传入的布尔值，这个功能就非常重要。通过这种方式，你可以确保 JavaScript 层面上的逻辑在 C/C++ 层面上得到正确的反映，进而在扩展模块中使用这些布尔值进行逻辑控制或配置。</p><h4 id="napi-get-value-double" tabindex="-1"><a class="header-anchor" href="#napi-get-value-double"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_double" target="_blank" rel="noopener noreferrer">napi_get_value_double</a></span></a></h4><p><code>napi_get_value_double</code> 是 Node.js 中的 N-API 函数，N-API 是一套用于构建本地插件的 C API。Node.js 允许你使用 C, C++ 等语言编写扩展模块，这些扩展模块可以直接操作底层资源或执行高性能计算任务。</p><p><code>napi_get_value_double</code> 的目的是在一个本地插件（C/C++代码）中从 JavaScript 传来的 <code>Number</code> 类型的值中提取出双精度浮点数（即 C/C++ 中的 <code>double</code> 类型）。当你的插件从 JavaScript 接收一个数字，并希望将其用作 C/C++ 中的 <code>double</code> 类型时需要用到它。</p><p>函数原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_value_double(napi_env env, napi_value value, double* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>: 表示当前的环境，通常是每个函数都会有的上下文参数。</li><li><code>value</code>: 是一个 <code>napi_value</code> 类型，它代表了 JavaScript 中的一个 Number 值。</li><li><code>result</code>: 是指向 <code>double</code> 变量的指针，用于存储转换后的双精度浮点数。</li></ul><p>返回值：</p><ul><li>返回 <code>napi_status</code>，表示函数调用成功与否的状态码。如果函数执行成功，它通常会返回 <code>napi_ok</code>。</li></ul><p>下面举一个实际的例子：</p><p>假设你正在编写一个本地插件，该插件需要从 JavaScript 接收一个数字，然后使用这个数字进行一些计算。</p><p>首先，在你的 C/C++ 源文件中，你可能会有类似下面的代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个是你的函数实现，它将被 JavaScript 调用</span></span>
<span class="line"><span>napi_value CalculateSomething(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    double number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 从args[0]中提取double值</span></span>
<span class="line"><span>    if (napi_get_value_double(env, args[0], &amp;number) != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 接下来你可以使用 number 进行计算</span></span>
<span class="line"><span>    double result = number * 2.0; // 假设我们只是简单地将其乘以2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 最后你需要将计算结果返回给 JavaScript</span></span>
<span class="line"><span>    napi_value returnValue;</span></span>
<span class="line"><span>    napi_create_double(env, result, &amp;returnValue);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return returnValue;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，将上面的函数暴露给 JavaScript</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, CalculateSomething, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;calculate&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 端，你可以像这样调用这个插件的函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">calculate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3.14</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: 6.28</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，JavaScript 代码调用了本地插件的 <code>calculate</code> 函数，并传入了一个数字 <code>3.14</code>。C/C++ 插件接收这个数字，通过 <code>napi_get_value_double</code> 提取为 <code>double</code> 类型，然后将其乘以 2 后返回结果 <code>6.28</code> 给 JavaScript。</p><p>这种机制允许 Node.js 扩展其功能并处理高性能计算或更直接地与系统资源交互，同时保持 JavaScript 代码的清晰和简洁。</p><h4 id="napi-get-value-bigint-int64" tabindex="-1"><a class="header-anchor" href="#napi-get-value-bigint-int64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_bigint_int64" target="_blank" rel="noopener noreferrer">napi_get_value_bigint_int64</a></span></a></h4><p>好的，让我们来简单深入地了解一下 Node.js 中的<code>napi_get_value_bigint_int64</code>函数。</p><p>首先，N-API 是 Node.js 的一个 C 语言 API，它用于构建本地插件。本地插件是直接与 Node.js 运行时进行交互的动态链接共享对象，通常用于性能敏感的操作或是对已有 C/C++库的封装。</p><p>现在，让我们聚焦在<code>napi_get_value_bigint_int64</code>这个具体的 N-API 函数上。这个函数允许你从 JavaScript 层面传递的一个 BigInt 值转换为 C 语言层面的 int64_t 值。BigInt 是一个 JavaScript 的数据类型，用于表示任意精度的整数。而在 C 语言中，int64_t 则是一个固定大小（64 位）的整型数据类型。</p><p>这是<code>napi_get_value_bigint_int64</code>函数的基本声明：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_value_bigint_int64(napi_env env,</span></span>
<span class="line"><span>                                        napi_value value,</span></span>
<span class="line"><span>                                        int64_t* result,</span></span>
<span class="line"><span>                                        bool* lossless);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是一个代表 Node.js 环境的句柄，所有的 N-API 调用都需要这个参数。</li><li><code>value</code>: 这是一个代表 JavaScript 中 BigInt 值的<code>napi_value</code>。</li><li><code>result</code>: 这是一个指向<code>int64_t</code>变量的指针，在函数执行后，该变量将存储转换得到的 64 位整数值。</li><li><code>lossless</code>: 这是一个指向布尔值的指针，它会告诉你转换是否“无损”，即 BigInt 是否可以完全不丢失任何信息地转换为 64 位整数。</li></ul><p>如果 BigInt 值太大，无法以无损方式放入 64 位整数，则<code>lossless</code>指针所指向的值会被设置为<code>false</code>，并且结果可能是截断后的值。</p><p>以下是如何在实际的 C 代码中使用该函数的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们已经获得了代表BigInt的napi_value, named js_bigint</span></span>
<span class="line"><span>napi_value js_bigint;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... js_bigint 被赋值的代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int64_t my_number;</span></span>
<span class="line"><span>bool is_lossless;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用napi_get_value_bigint_int64来转换BigInt到int64_t</span></span>
<span class="line"><span>napi_status status = napi_get_value_bigint_int64(env, js_bigint, &amp;my_number, &amp;is_lossless);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>    if (is_lossless) {</span></span>
<span class="line"><span>        // 转换成功，并且是无损的</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 转换成功，但是有损的，BigInt值太大，不能完全放入int64_t</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 调用失败，处理错误</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，我们首先定义了一个<code>int64_t</code>类型的变量<code>my_number</code>，以及一个布尔变量<code>is_lossless</code>。然后，我们调用了<code>napi_get_value_bigint_int64</code>函数，期望将一个 BigInt 值转换为一个<code>int64_t</code>值，并通过<code>is_lossless</code>来检测转换是否无损。</p><p>请注意，真实世界的情况可能更复杂，因为还涉及到从 JavaScript 传递 BigInt 值到 C 插件等过程，但上述代码展示了如何使用这个特定的 N-API 函数进行基本转换。</p><h4 id="napi-get-value-bigint-uint64" tabindex="-1"><a class="header-anchor" href="#napi-get-value-bigint-uint64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_bigint_uint64" target="_blank" rel="noopener noreferrer">napi_get_value_bigint_uint64</a></span></a></h4><p>Node.js 中的 <code>napi_get_value_bigint_uint64</code> 是 N-API 的一部分。N-API 是一个 C 语言的 API，允许原生插件（通常用 C 或 C++编写）与 JavaScript 代码进行交互，而不受 Node.js 版本变化的影响。</p><p>在 JavaScript 中，<code>BigInt</code>是一种数值类型，可以表示大于<code>Number.MAX_SAFE_INTEGER</code>的整数。相反，在 C/C++等语言中，通常使用特定的数据类型来表示大整数，例如<code>uint64_t</code>（一个无符号的 64 位整数）。</p><p>函数<code>napi_get_value_bigint_uint64</code>允许你从一个 JavaScript <code>BigInt</code>对象获取其值，并将这个值作为一个 64 位无符号整数（<code>uint64_t</code>）存放到原生代码变量中。</p><p>以下是<code>napi_get_value_bigint_uint64</code>函数的基本用途：</p><ol><li>从 JavaScript 传递一个大整数到原生插件。</li><li>在原生插件中，使用<code>napi_get_value_bigint_uint64</code>提取这个大整数的值。</li><li>使用这个值进行一些 C/C++层面的操作，比如算术操作、二进制操作等。</li></ol><p>现实应用示例：</p><ol><li><p><strong>文件系统访问</strong>：想象一个 Node.js 应用，需要处理文件的大小。有时候，文件可能非常大，超过了标准 JavaScript 数值能够安全表示的范围。这时，你可能会用到<code>BigInt</code>。如果你正在编写一个扩展模块来优化文件大小的检索，那么你可能需要用到<code>napi_get_value_bigint_uint64</code>来正确地处理这些大的数值。</p></li><li><p><strong>高精度时间戳</strong>：某些应用程序可能需要高精度时间戳，这些时间戳的精度超出了 JavaScript 普通数字类型的范围。例如，当你要与一些需要高精度计时的硬件设备交互时，可能会用到<code>BigInt</code>来表示这些时间戳。在原生模块中，你将使用<code>napi_get_value_bigint_uint64</code>来接收和处理这些高精度的值。</p></li><li><p><strong>大整数运算</strong>：假如你的应用需要执行大整数加密算法，如 RSA 加密，这通常涉及到很大的数值运算。在这种情况下，JavaScript 的<code>BigInt</code>可用于表示这些大数，而<code>napi_get_value_bigint_uint64</code>则可用于将它们传递给执行加密算法的原生插件代码。</p></li></ol><p>举一个简单的代码例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数被调用时，info[0] 是一个 BigInt 对象。</span></span>
<span class="line"><span>napi_value GetBigIntAsUint64(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  uint64_t result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取 JavaScript 函数中的参数列表</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将 BigInt 转换为 uint64_t</span></span>
<span class="line"><span>  bool lossless; // 这个变量表示转换是否损失精度</span></span>
<span class="line"><span>  status = napi_get_value_bigint_uint64(env, args[0], &amp;result, &amp;lossless);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在 result 变量中包含了 BigInt 的值，并可以在 C/C++ 代码中使用它</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ... 你的代码逻辑 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回一个新的 BigInt 给 JavaScript</span></span>
<span class="line"><span>  napi_value new_bigint;</span></span>
<span class="line"><span>  status = napi_create_bigint_uint64(env, result, &amp;new_bigint);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return new_bigint;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述例子中，我们定义了一个函数<code>GetBigIntAsUint64</code>，它从 JavaScript 接收一个<code>BigInt</code>对象，然后使用<code>napi_get_value_bigint_uint64</code>将其转换为<code>uint64_t</code>类型，并可以在 C/C++中对它进行操作。最后，我们创建了一个新的<code>BigInt</code>对象，将其返回给 JavaScript。</p><p>请注意，为了确保类型安全和数据精度，你需要检查<code>lossless</code>变量。如果<code>lossless</code>为<code>false</code>，说明转换过程中损失了精度，这通常发生在<code>BigInt</code>值超出了<code>uint64_t</code>能够表示的范围的情况。</p><h4 id="napi-get-value-bigint-words" tabindex="-1"><a class="header-anchor" href="#napi-get-value-bigint-words"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_bigint_words" target="_blank" rel="noopener noreferrer">napi_get_value_bigint_words</a></span></a></h4><p><code>napi_get_value_bigint_words</code> 是 Node.js 中 N-API（原生 API）的一部分，它让你可以从 JavaScript 的 <code>BigInt</code> 类型中提取数据并在 C 或者 C++ 原生模块中使用。<code>BigInt</code> 是 JavaScript 中一种可以表示任意大整数的数据类型。</p><p>在 Node.js v21.7.1 的文档中，<code>napi_get_value_bigint_words</code> 函数允许你将一个 JavaScript 的 <code>BigInt</code> 对象转换成由多个数字组成的数组（通常是 64 位长整数），这样你就可以在原生代码中处理非常大的整数。</p><p>下面我会详细解释这个函数是如何工作的，并给出一个实际应用的例子。</p><h3 id="函数声明" tabindex="-1"><a class="header-anchor" href="#函数声明"><span>函数声明</span></a></h3><p>这个函数在 C 或 C++代码中的声明类似于：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_value_bigint_words(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    napi_value value,</span></span>
<span class="line"><span>    int* sign_bit,</span></span>
<span class="line"><span>    size_t* word_count,</span></span>
<span class="line"><span>    uint64_t* words);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 当前的 N-API 环境，它代表了 Node.js 运行时的上下文。</li><li><code>value</code>: 一个 <code>napi_value</code> 类型的变量，它包装了一个 JavaScript 的 <code>BigInt</code> 对象。</li><li><code>sign_bit</code>: 指向一个 <code>int</code> 的指针，函数会设置该值为 0 或 1 来表示 <code>BigInt</code> 的正负。</li><li><code>word_count</code>: 一个指向 <code>size_t</code> 的指针，在调用函数之前，你需要设置它为 <code>words</code> 数组可以容纳的元素数量。调用后，它会被设置为实际需要的元素数量。</li><li><code>words</code>: 指向一个 <code>uint64_t</code> 数组的指针，这个数组用来存储大整数的二进制表示。</li></ul><h3 id="示例-2" tabindex="-1"><a class="header-anchor" href="#示例-2"><span>示例</span></a></h3><p>假设你正在编写一个原生模块，需要操作一个非常大的整数。下面是如何在你的 C/C++ 代码中调用 <code>napi_get_value_bigint_words</code> 的一个简单例子。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 &#39;bigIntValue&#39; 是一个包含了 BigInt 的 napi_value</span></span>
<span class="line"><span>napi_value bigIntValue;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在其他地方获取到这个 bigIntValue ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 准备用于提取 BigInt 信息的变量</span></span>
<span class="line"><span>int signBit;</span></span>
<span class="line"><span>size_t wordCount = 2; // 假设我们知道 BigInt 不会超过 128 位</span></span>
<span class="line"><span>uint64_t words[2]; // 用于存储 BigInt 二进制表示的数组</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用函数提取 BigInt</span></span>
<span class="line"><span>napi_status status = napi_get_value_bigint_words(env, bigIntValue, &amp;signBit, &amp;wordCount, words);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 检查函数调用是否成功</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// &#39;signBit&#39; 现在代表了 BigInt 的符号 (0 为正, 1 为负)</span></span>
<span class="line"><span>// &#39;wordCount&#39; 已经被设置为实际需要的元素数量</span></span>
<span class="line"><span>// &#39;words&#39; 数组现在包含了 BigInt 的二进制表示</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>napi_get_value_bigint_words</code> 函数，你可以在 C/C++ 代码中获取到 JavaScript <code>BigInt</code> 的精确表示，然后进行各种计算，比如加密算法、大数运算等对大整数有特殊需求的场合。</p><p>总结起来，<code>napi_get_value_bigint_words</code> 是 Node.js 原生编程接口中与大整数互操作的重要工具，它让原生模块能够处理那些超出标准 JavaScript 数字范围的整数。</p><h4 id="napi-get-value-external" tabindex="-1"><a class="header-anchor" href="#napi-get-value-external"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_external" target="_blank" rel="noopener noreferrer">napi_get_value_external</a></span></a></h4><p>Node.js 中的 N-API（Node.js API）是一个 C 语言级别的 API，它允许本地插件（通常用 C 或 C++编写）与 JavaScript 代码进行互操作。<code>napi_get_value_external</code>是 N-API 提供的一个函数，它被用于从一个 JavaScript 值中检索一个在 C 环境下创建的外部数据指针。</p><p>当你在 JavaScript 和 C/C++混合编程时，并且需要在两者之间传递数据，尤其是不能直接在 JavaScript 中创建的非 JS 类型数据时，这个功能就显得特别重要。<code>napi_get_value_external</code>函数允许你在 JavaScript 层面上持有并操作 C/C++层面的数据对象。</p><p>下面通过几个步骤来解释它的工作原理：</p><ol><li><p><strong>在 C/C++层面创建数据</strong>：首先，在 C/C++插件中创建一个数据对象。这可能是任何类型的数据，比如一个自定义的结构体或者类的实例。</p></li><li><p><strong>将数据包装为<code>napi_value</code></strong>：使用<code>napi_create_external</code>等函数将这个 C/C++层面的数据转换成一个可以在 JavaScript 中使用的<code>napi_value</code>。这个过程称为“封装”（wrapping）。</p></li><li><p><strong>在 JavaScript 中使用这个值</strong>：一旦数据被封装为<code>napi_value</code>，它就可以作为一个 JS 变量传递到 JavaScript 代码中，并在那里被当做一个“外部”类型的值使用。</p></li><li><p><strong>从 JavaScript 值中检索数据</strong>：当你想要在 C/C++代码中再次获取原始数据时，你可以使用<code>napi_get_value_external</code>函数。这个函数将会从 JS 层面表示外部数据的<code>napi_value</code>中提取出 C/C++层面的指针。</p></li></ol><p>现在，让我们以具体的示例说明这一过程：</p><h3 id="示例-c-c-侧" tabindex="-1"><a class="header-anchor" href="#示例-c-c-侧"><span>示例 - C/C++侧</span></a></h3><p>假设你有一个 C++类，如下所示：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class MyData {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    int value;</span></span>
<span class="line"><span>    // 构造函数</span></span>
<span class="line"><span>    MyData(int val) : value(val) {}</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你创建了一个对象，并将它封装为<code>napi_value</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>MyData* myData = new MyData(42);</span></span>
<span class="line"><span>napi_value externalValue;</span></span>
<span class="line"><span>// 假设 `env` 是当前的napi环境，`myData` 是我们要封装的指针</span></span>
<span class="line"><span>napi_create_external(env, (void*)myData, nullptr, nullptr, &amp;externalValue);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="示例-javascript-侧" tabindex="-1"><a class="header-anchor" href="#示例-javascript-侧"><span>示例 - JavaScript 侧</span></a></h3><p>现在，在 JavaScript 代码中，你可以获得这个<code>externalValue</code>，它代表了一个外部数据：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这个externalValue是通过某种机制从C++传递到JS的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">externalValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这将不会显示实际数据，因为它是外部的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="示例-重新获取-c-c-数据" tabindex="-1"><a class="header-anchor" href="#示例-重新获取-c-c-数据"><span>示例 - 重新获取 C/C++数据</span></a></h3><p>最后，如果你希望在 C/C++插件中再次访问这个数据，你可以使用<code>napi_get_value_external</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void* data;</span></span>
<span class="line"><span>// 再次假设 `env` 是当前的napi环境</span></span>
<span class="line"><span>napi_get_value_external(env, externalValue, &amp;data);</span></span>
<span class="line"><span>MyData* originalData = static_cast`&lt;`MyData*&gt;(data); // 现在你又得到了原始的C++对象指针</span></span>
<span class="line"><span>std::cout `&lt;``&lt;` &quot;The value is: &quot; `&lt;``&lt;` originalData-&gt;value `&lt;``&lt;` std::endl; // 将输出：The value is: 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这个过程，你可以在 JavaScript 代码和 C/C++代码之间安全地传递复杂的数据结构，并在需要时对其进行操作。这使得 Node.js 能够通过本地扩展来执行高性能或低级操作，同时保持 JS 层面上的简介和易用性。</p><h4 id="napi-get-value-int32" tabindex="-1"><a class="header-anchor" href="#napi-get-value-int32"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_int32" target="_blank" rel="noopener noreferrer">napi_get_value_int32</a></span></a></h4><p>在 Node.js 中，N-API 是一个用于构建原生插件的 API 层。原生插件是用 C 或 C++编写的模块，可以直接调用 Node.js 内部和 V8（JavaScript 引擎）的功能。N-API 的目的是减少原生插件与 Node.js 版本之间的兼容性问题，并简化原生模块的编写。</p><p><code>napi_get_value_int32</code>函数就是 N-API 提供的一种功能，其作用是从一个 N-API 的<code>napi_value</code>类型中提取出一个 32 位整数（即 C 语言中的<code>int32_t</code>类型）。<code>napi_value</code>是表示 JavaScript 值的 N-API 结构体，在本地代码中不能直接操作 JavaScript 值，所以需要通过这类函数来进行转换。</p><h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1"><span>使用场景</span></a></h3><p>假设你正在编写一个 Node.js 原生插件，你想要创建一个函数，它接受一个 JavaScript 数字并将其翻倍。在这个过程中，你需要从 JavaScript 传入的参数中获取实际的数字值，并在 C/C++代码中使用这个值。</p><h3 id="函数原型-1" tabindex="-1"><a class="header-anchor" href="#函数原型-1"><span>函数原型</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_value_int32(napi_env env,</span></span>
<span class="line"><span>                                 napi_value value,</span></span>
<span class="line"><span>                                 int32_t* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>napi_env env</code>: 当前环境的句柄，代表了当前的 Node.js 环境。</li><li><code>napi_value value</code>: 你想要转换的 JavaScript 值。</li><li><code>int32_t* result</code>: 这是结果参数的指针，在函数执行后，整数值会被存储在这里。</li></ul><h3 id="返回值-3" tabindex="-1"><a class="header-anchor" href="#返回值-3"><span>返回值</span></a></h3><p>该函数返回<code>napi_status</code>枚举值，告诉我们函数调用是否成功。如果返回值不是<code>napi_ok</code>，则意味着有错误发生。</p><h3 id="实例代码" tabindex="-1"><a class="header-anchor" href="#实例代码"><span>实例代码</span></a></h3><p>下面是一个简单的例子，展示了如何在一个 Native 插件的函数中使用<code>napi_get_value_int32</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原生函数，将输入的JavaScript整数翻倍</span></span>
<span class="line"><span>napi_value DoubleInt(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    int32_t number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将第一个参数转换为int32</span></span>
<span class="line"><span>    status = napi_get_value_int32(env, args[0], &amp;number);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 计算翻倍后的值</span></span>
<span class="line"><span>    int32_t doubledNumber = number * 2;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果给JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_create_int32(env, doubledNumber, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册DoubleInt到exports对象</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, DoubleInt, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置导出的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;doubleInt&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个名为<code>DoubleInt</code>的函数，它接收一个 JavaScript 传的整数参数，将其翻倍，并返回结果。<code>napi_get_value_int32</code>就是用于获取传入参数并将其转换为一个本地的<code>int32_t</code>类型的整数值。</p><p>开发者需要明白的是，当使用 N-API 编写原生插件时，他们通常需要处理类型转换，因为 JavaScript 中的数据类型和 C/C++中的数据类型是不同的。而<code>napi_get_value_int32</code>正是帮助我们进行这种类型转换的工具之一。</p><h4 id="napi-get-value-int64" tabindex="-1"><a class="header-anchor" href="#napi-get-value-int64"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_int64" target="_blank" rel="noopener noreferrer">napi_get_value_int64</a></span></a></h4><p>当然，我会尽力解释得通俗易懂。</p><h3 id="node-js-中的-napi-get-value-int64" tabindex="-1"><a class="header-anchor" href="#node-js-中的-napi-get-value-int64"><span>Node.js 中的 <code>napi_get_value_int64</code></span></a></h3><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行时。它允许你在服务器端运行 JavaScript 代码。Node.js 提供了一套丰富的 API 来与操作系统交互，这些 API 集合称为 N-API。N-API 是 Node.js 的一个功能，允许你用 C 或 C++ 编写扩展模块。这些扩展模块可以直接调用 Node.js 提供的各种底层 API，以此来创建高性能的应用程序。</p><h4 id="napi-get-value-int64-是什么" tabindex="-1"><a class="header-anchor" href="#napi-get-value-int64-是什么"><span><code>napi_get_value_int64</code> 是什么？</span></a></h4><p><code>napi_get_value_int64</code> 是 Node.js 提供的 N-API 中的一个函数，它允许你将一个 JavaScript 数值（Number）转换成一个 C 语言中的 <code>int64_t</code> 类型。<code>int64_t</code> 是一个表示 64 位整数的数据类型，在 C/C++ 中就相当于长整型（long integer），它能够存储非常大或非常小的整数值。</p><h4 id="napi-get-value-int64-使用场景" tabindex="-1"><a class="header-anchor" href="#napi-get-value-int64-使用场景"><span><code>napi_get_value_int64</code> 使用场景：</span></a></h4><p>假设你正在编写一个 Node.js 扩展，需要处理来自 JavaScript 端的大整数，并且要在 C/C++ 插件中进行一些复杂的计算或者系统调用，那么你可能就需要使用 <code>napi_get_value_int64</code> 函数。</p><h4 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码：</span></a></h4><p>假如我们有一个 JavaScript 中的数字，我们要在扩展模块中处理它。下面是一个简化的例子：</p><p>JavaScript 端调用扩展模块的示例代码：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myExtension</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-native-extension&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> bigNumber</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1234567890123456789</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设这是一个大整数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myExtension</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">processLargeNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">bigNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C/C++ 扩展模块中的相关部分：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数就是被 JavaScript 调用的</span></span>
<span class="line"><span>napi_value ProcessLargeNumber(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 调用传递的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int64_t number;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 JavaScript 的 Number 转换为 C 的 int64_t</span></span>
<span class="line"><span>    status = napi_get_value_int64(env, args[0], &amp;number);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 现在我们有了一个 C 语言中的 int64_t 类型的整数，可以进行处理了</span></span>
<span class="line"><span>    // ... 做一些处理，例如：</span></span>
<span class="line"><span>    printf(&quot;Received number from JS: %lld\n&quot;, number);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回处理结果给 JavaScript</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化和注册 ProcessLargeNumber 函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, ProcessLargeNumber, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;processLargeNumber&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们创建了一个名为 <code>ProcessLargeNumber</code> 的函数，这个函数从 JavaScript 端接收一个参数，并使用 <code>napi_get_value_int64</code> 转换该参数为 <code>int64_t</code> 类型的变量。然后，我们可以在 C/C++ 代码中处理这个大整数。</p><p>请记住，这只是一个非常简化的例子，实际编写 Node.js 的 C/C++ 扩展涉及很多其他的注意事项和步骤。不过，希望这个例子能够帮助你理解 <code>napi_get_value_int64</code> 在 Node.js 扩展中的应用。</p><h4 id="napi-get-value-string-latin1" tabindex="-1"><a class="header-anchor" href="#napi-get-value-string-latin1"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_string_latin1" target="_blank" rel="noopener noreferrer">napi_get_value_string_latin1</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。它允许你在服务器端运行 JavaScript 代码。Node.js 提供了一组核心的库，用于处理文件、网络通信等功能。</p><p>N-API（Node.js API）是 Node.js 提供的一个稳定且独立于 JavaScript 运行时的 C API 层，它用于构建原生插件。原生插件是用 C 或 C++ 写的模块，它们可以直接与 Node.js 的底层 API 交互，提供比普通 JavaScript 更接近系统底层的性能和功能。</p><p><code>napi_get_value_string_latin1</code> 是 N-API 中的一个函数，它用于将 JavaScript 字符串转换成一个以 Latin-1 编码（也称为 ISO-8859-1）的 C 字符串。Latin-1 编码是一种单字节编码方案，能够表示 Western European（西欧）语言中的字符。</p><p>当你有一个 JavaScript 字符串，并且需要在原生插件中使用这个字符串的时候，你可能会使用 <code>napi_get_value_string_latin1</code> 函数。这个函数会把 JavaScript 字符串内的字符按照 Latin-1 编码复制到一个由你分配的缓冲区（buffer）中。</p><p>举例来说：</p><p>假设你在 Node.js 中创建了一个原生插件，它需要从 JavaScript 接收一个字符串参数并以某种方式处理这个字符串。在 C/C++ 的原生插件代码中，你可能会这样使用 <code>napi_get_value_string_latin1</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他必要的头文件和代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是一个被暴露给 JavaScript 的函数，它接受一个字符串参数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_value thisArg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取函数参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, argv, &amp;thisArg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保我们得到了一个字符串</span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    napi_typeof(env, argv[0], &amp;valuetype);</span></span>
<span class="line"><span>    if (valuetype != napi_string) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Argument must be a string.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 预先获取字符串长度</span></span>
<span class="line"><span>    size_t str_length;</span></span>
<span class="line"><span>    napi_get_value_string_latin1(env, argv[0], NULL, 0, &amp;str_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 分配足够大小的缓冲区来存储 Latin-1 字符串</span></span>
<span class="line"><span>    char* c_str = (char*) malloc((str_length + 1) * sizeof(char));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 JavaScript 字符串复制到缓冲区</span></span>
<span class="line"><span>    napi_get_value_string_latin1(env, argv[0], c_str, str_length + 1, &amp;str_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // c_str 包含了转换后的字符串，可以进行处理</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 处理完成后记得释放分配的内存</span></span>
<span class="line"><span>    free(c_str);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果或者 undefined...</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 注册 MyFunction 使其能够在 JavaScript 中调用 ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，<code>MyFunction</code> 是一个原生函数，它接受一个字符串参数。在函数内部，它先检查确保传入的参数确实是一个字符串，然后计算这个字符串的长度，之后为这个字符串分配足够的内存，并使用 <code>napi_get_value_string_latin1</code> 函数将 JavaScript 字符串的值复制到分配的内存中。这样我们就可以在原生代码中操作这个字符串了。</p><p>请注意，因为 Latin-1 只能表示范围有限的字符，如果你的 JavaScript 字符串包含不能用 Latin-1 编码表示的字符，那么这些字符将被替换为一个特殊的替换字符，通常是 <code>?</code>。因此，在处理多种字符集或者需要 Unicode 支持的应用程序中，你可能需要使用其他函数来获取 UTF-8 编码的字符串。</p><h4 id="napi-get-value-string-utf8" tabindex="-1"><a class="header-anchor" href="#napi-get-value-string-utf8"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_string_utf8" target="_blank" rel="noopener noreferrer">napi_get_value_string_utf8</a></span></a></h4><p>好的，Node.js 中 <code>napi_get_value_string_utf8</code> 是一个函数，属于 Node.js 的 N-API（原生 API）库。N-API 提供了一组用 C 语言写的接口，允许你创建可以直接与 JavaScript 交互的本地插件（native addons）。</p><p>在解释 <code>napi_get_value_string_utf8</code> 之前，有必要了解以下几个概念：</p><ol><li><strong>Native Addons</strong>: 这是指使用 C 或 C++等语言编写的模块，它们可以被 Node.js 加载，并提供比 JavaScript 更高性能的操作。</li><li><strong>N-API</strong>: 是一种稳定的 Node.js API 层，使得原生模块（native addons）隔离于底层的 V8 引擎，这样即使 V8 有更新，原生模块也不需要重新编译。</li><li><strong>JavaScript Values and N-API</strong>: 在使用 N-API 工作时，你通常需要处理从 JavaScript 传递到 C 层的值，例如字符串、数字等。</li></ol><p>现在让我们来看看 <code>napi_get_value_string_utf8</code> 函数：</p><h3 id="napi-get-value-string-utf8-1" tabindex="-1"><a class="header-anchor" href="#napi-get-value-string-utf8-1"><span>napi_get_value_string_utf8</span></a></h3><p><strong>功能</strong>：这个函数的作用是将一个 N-API 类型的字符串（<code>napi_value</code>），转换成 UTF-8 编码的 C 字符串。</p><p><strong>参数</strong>：</p><ul><li><code>env</code>: 代表 N-API 环境的句柄，它是每次调用 N-API 函数时必须提供的。</li><li><code>value</code>: 要读取的 N-API 字符串类型的值。</li><li><code>buf</code>: 指向预先分配的缓冲区的指针，用来存放 UTF-8 编码的字符串。</li><li><code>bufsize</code>: 缓冲区的大小（字节为单位）。</li><li><code>result</code>: 实际复制到缓冲区的字节数。</li></ul><p><strong>返回值</strong>：如果函数成功执行，则返回 <code>napi_ok</code>，否则返回错误码。</p><h3 id="例子-1" tabindex="-1"><a class="header-anchor" href="#例子-1"><span>例子</span></a></h3><p>假设你在 JavaScript 中有一个字符串，你想在 C 层处理这个字符串。首先你需要创建一个原生模块，然后在这个模块里使用 <code>napi_get_value_string_utf8</code> 来获取 UTF-8 编码的 C 字符串。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你已经定义了一个函数要从JS中获取字符串</span></span>
<span class="line"><span>napi_value GetStringFromJS(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取参数数量和参数数组</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保获取状态正确并且至少有一个参数</span></span>
<span class="line"><span>    if (status != napi_ok || argc `&lt;` 1) {</span></span>
<span class="line"><span>        // 错误处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取字符串长度</span></span>
<span class="line"><span>    size_t str_length;</span></span>
<span class="line"><span>    status = napi_get_value_string_utf8(env, argv[0], NULL, 0, &amp;str_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 错误处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 分配内存来存储字符串</span></span>
<span class="line"><span>    char* buf = (char*)malloc(str_length + 1); // 加1为了null-terminator</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    size_t copied_length;</span></span>
<span class="line"><span>    status = napi_get_value_string_utf8(env, argv[0], buf, str_length + 1, &amp;copied_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        free(buf);</span></span>
<span class="line"><span>        // 错误处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 此时buf中有了从JS传递过来的字符串内容</span></span>
<span class="line"><span>    // 可以继续进行其他操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 最后别忘记释放分配的内存</span></span>
<span class="line"><span>    free(buf);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一个undefined类型的值到JS</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此例中，首先确定了传入的参数数量和类型，然后通过 <code>napi_get_value_string_utf8</code> 函数获取了一个 JavaScript 字符串的 UTF-8 表示形式。需要注意的是，为了获得字符串实际字符数，首先调用了一次该函数并传递 NULL 作为缓冲区，这样就可以得到字符串长度，然后再进行实际的内存分配。</p><p>这个函数主要用于当你编写原生模块需要处理 JavaScript 层传递的字符串数据时。通过转换成 C 字符串，你就可以应用各种 C 语言的操作来处理这些数据。</p><h4 id="napi-get-value-string-utf16" tabindex="-1"><a class="header-anchor" href="#napi-get-value-string-utf16"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_string_utf16" target="_blank" rel="noopener noreferrer">napi_get_value_string_utf16</a></span></a></h4><p>Node.js 中的 <code>napi_get_value_string_utf16</code> 是一个函数，属于 Node.js 的 N-API（原生 API）。N-API 提供了一组底层的 API，使得 C/C++的插件模块编写者可以不用关心具体的 V8 或 Chakra 引擎的版本差异，编写出兼容性更强、稳定性更高的原生模块。</p><p><code>napi_get_value_string_utf16</code> 函数的作用是将一个 JavaScript 字符串转换为 UTF-16 编码的字符数组。UTF-16 是一种字符编码方式，它可以用来表示世界上大部分的书面语言。</p><p>在 Node.js 的原生模块中使用此函数通常需要完成以下步骤：</p><ol><li>接收一个从 JavaScript 传递过来的字符串参数。</li><li>使用 <code>napi_get_value_string_utf16</code> 函数将这个字符串参数转换成 C/C++ 中的 UTF-16 编码的字符数组。</li><li>在 C/C++ 代码中处理这个字符数组。</li><li>可能还需要将处理后的结果返回给 JavaScript。</li></ol><p>下面我会通过一个具体的例子来解释如何使用 <code>napi_get_value_string_utf16</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数是从 JavaScript 调用的原生函数</span></span>
<span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取从 JavaScript 传递过来的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否有一个参数，并且参数是字符串</span></span>
<span class="line"><span>    if (status == napi_ok &amp;&amp; argc == 1) {</span></span>
<span class="line"><span>        napi_valuetype valuetype;</span></span>
<span class="line"><span>        napi_typeof(env, args[0], &amp;valuetype);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (valuetype == napi_string) {</span></span>
<span class="line"><span>            // 首先获取字符串的长度</span></span>
<span class="line"><span>            size_t str_length;</span></span>
<span class="line"><span>            status = napi_get_value_string_utf16(env, args[0], NULL, 0, &amp;str_length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if (status == napi_ok) {</span></span>
<span class="line"><span>                // 分配足够的空间保存 UTF-16 字符串</span></span>
<span class="line"><span>                u_char16_t* buf = new u_char16_t[str_length + 1];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                // 将 JavaScript 字符串转换为 UTF-16 编码的字符数组</span></span>
<span class="line"><span>                size_t copied;</span></span>
<span class="line"><span>                status = napi_get_value_string_utf16(env, args[0], buf, str_length + 1, &amp;copied);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                if (status == napi_ok) {</span></span>
<span class="line"><span>                    // 这里可以对 buf 中的 UTF-16 编码的字符数组进行处理</span></span>
<span class="line"><span>                    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                    // 处理完毕后要释放之前分配的内存</span></span>
<span class="line"><span>                    delete[] buf;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回 undefined</span></span>
<span class="line"><span>    napi_value undef;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undef);</span></span>
<span class="line"><span>    return undef;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Initialize(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value my_function;</span></span>
<span class="line"><span>    // ... 创建和导出 MyNativeFunction 函数 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>MyNativeFunction</code> 是一个原生函数，它会被 JavaScript 代码调用。这个函数首先确定被调用时传入了一个参数，并且这个参数是字符串。然后，它使用 <code>napi_get_value_string_utf16</code> 函数来获取字符串的长度，并分配一个足够大的缓冲区来存储 UTF-16 编码的字符串。接着，再次调用 <code>napi_get_value_string_utf16</code> 函数实际读取字符串并将其拷贝到之前分配的缓冲区中。这样我们就可以在 C/C++ 中处理这个字符串了。处理完成后，记得释放分配的内存以避免内存泄露。</p><p>这个函数在开发 Node.js 原生扩展时非常有用，尤其是当你需要处理与文本相关的操作时。通过这种方式，你可以在 C/C++ 层面上操作 JavaScript 字符串，以高效地执行各种任务，比如字符串分析、转换或其他计算密集型任务。</p><h4 id="napi-get-value-uint32" tabindex="-1"><a class="header-anchor" href="#napi-get-value-uint32"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_value_uint32" target="_blank" rel="noopener noreferrer">napi_get_value_uint32</a></span></a></h4><p>当然，让我为你解释一下 Node.js 中的<code>napi_get_value_uint32</code>函数。</p><p>在 Node.js 中，N-API 是一个用来构建本地插件的 API 层。它允许你使用 C 或 C++代码与 Node.js 进行交互，这意味着你可以编写能够以机器代码速度运行的 JavaScript 扩展，这对于性能敏感的应用程序来说非常重要。</p><p>现在，我们谈到了<code>napi_get_value_uint32</code>，这个函数是 N-API 的一部分，它被用来将一个 JavaScript 数值转换成 C 语言中的无符号 32 位整数（即<code>uint32_t</code>类型的值）。</p><p>使用<code>napi_get_value_uint32</code>时，需要传入两个参数：</p><ol><li><code>napi_env env</code>: 这是 N-API 环境的句柄，它代表了 Node.js 运行时的上下文和状态。每次 N-API 函数调用都需要这个参数。</li><li><code>napi_value value</code>: 这是一个 N-API 值的句柄，它表示一个 JavaScript 值。在这种情况下，我们期望这个 JavaScript 值是一个数值，因为我们想把它转换成一个<code>uint32_t</code>整数。</li></ol><p>函数还需要一个地方来存放转换后的<code>uint32_t</code>值。我们通常会提供一个指向<code>uint32_t</code>变量的指针作为输出参数。</p><p>下面是一个简单的例子说明如何使用<code>napi_get_value_uint32</code>：</p><p>假设你有一个 Node.js 的本地插件函数，你想从 JavaScript 传递一个数字给这个函数，并且在 C 层将其读取为一个<code>uint32_t</code>类型的值。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的本地插件函数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    uint32_t number;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传入的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将第一个参数（应该是一个JavaScript数值）转换为uint32_t</span></span>
<span class="line"><span>    status = napi_get_value_uint32(env, args[0], &amp;number);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 现在可以使用number变量，它包含了从JavaScript传过来的数值</span></span>
<span class="line"><span>    // 执行一些操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回undefined给JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册上面的函数到Node.js</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>MyFunction</code>是一个将要暴露给 JavaScript 的本地插件函数。它尝试读取传递给它的第一个参数，并将其转换为一个无符号 32 位整数。如果转换成功，你就可以在 C/C++代码中使用这个值了。最后，如果没有错误发生，函数会返回 undefined 给 JavaScript（这是 Node.js 中函数不返回任何值的标准方式）。</p><p>请记住，这里只是一个简单的例子，实际情况可能更加复杂，而且会涉及到更多的错误检查和处理。希望这有助于你理解<code>napi_get_value_uint32</code>的作用和如何在实践中使用它。</p><h3 id="functions-to-get-global-instances" tabindex="-1"><a class="header-anchor" href="#functions-to-get-global-instances"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#functions-to-get-global-instances" target="_blank" rel="noopener noreferrer">Functions to get global instances</a></span></a></h3><p>Node.js 的 N-API 是一个用于构建原生插件的 API 层，它提供了一种在不同版本的 Node.js 之间保持兼容性的方式。N-API 是原生模块和 Node.js 运行时之间的桥梁，允许开发者使用 C 或 C++ 编写可以直接与 JavaScript 交互的代码。</p><p>在 Node.js v21.7.1 的文档中，&quot;Functions to get global instances&quot; 指的是一组特定的函数，这些函数允许你获取全局对象的引用，比如 <code>global</code> 对象本身或者某些像 <code>ArrayBuffer</code> 这样的全局构造函数。全局对象是在所有模块中始终可用的顶级对象。</p><p>这些函数通常在编写需要与全局对象直接交互的原生模块时使用。下面我会解释一些这样的函数，并提供一些实际应用的例子：</p><h3 id="napi-get-global" tabindex="-1"><a class="header-anchor" href="#napi-get-global"><span>napi_get_global</span></a></h3><p>这个函数用来获取对 JavaScript 全局对象的引用。在 Node.js 中，全局对象包含了像 <code>console</code>, <code>process</code> 等全局可用的变量和函数。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value global;</span></span>
<span class="line"><span>napi_status status = napi_get_global(env, &amp;global);</span></span>
<span class="line"><span>// 接下来可以使用global变量来调用全局方法或访问全局属性。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="napi-get-constructor" tabindex="-1"><a class="header-anchor" href="#napi-get-constructor"><span>napi_get_constructor</span></a></h3><p>这个函数可以用来获取 JavaScript 中某个内置对象（比如<code>Array</code>或<code>Object</code>）的构造函数的引用。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value constructor;</span></span>
<span class="line"><span>napi_status status = napi_get_constructor(env, object, &amp;constructor);</span></span>
<span class="line"><span>// object 是一个指向 JavaScript 对象的引用，比如 ArrayBuffer 实例。</span></span>
<span class="line"><span>// 构造函数可以用来创建新的实例或者调用与构造函数相关的静态方法。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="应用例子" tabindex="-1"><a class="header-anchor" href="#应用例子"><span>应用例子</span></a></h3><p>假设你正在编写一个原生模块，该模块需要在 JavaScript 环境中创建一个新的 <code>ArrayBuffer</code> 对象。你可以使用 <code>napi_get_global</code> 函数获取全局对象，然后使用 <code>napi_get_named_property</code> 来获得 <code>ArrayBuffer</code> 构造函数的引用，接着就可以通过这个构造函数创建 <code>ArrayBuffer</code> 实例。</p><p>以下是 C/C++代码的简化示例，展示了如何使用 N-API 创建一个新的 ArrayBuffer 实例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateArrayBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_value global, arrayBufferConstructor, arrayBufferInstance;</span></span>
<span class="line"><span>  size_t byteLength = 64; // 假设我们想创建一个64字节长度的ArrayBuffer</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取全局对象</span></span>
<span class="line"><span>  napi_get_global(env, &amp;global);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取ArrayBuffer的构造函数</span></span>
<span class="line"><span>  napi_get_named_property(env, global, &quot;ArrayBuffer&quot;, &amp;arrayBufferConstructor);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 使用构造函数创建一个新的ArrayBuffer实例</span></span>
<span class="line"><span>  napi_create_arraybuffer(env, byteLength, NULL, &amp;arrayBufferInstance);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return arrayBufferInstance;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 之后你需要注册这个函数到你的模块导出中，以便JavaScript可以调用它。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Node.js 中使用这个原生模块的 JavaScript 代码可能如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;your-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> arrayBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CreateArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">arrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">byteLength</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: 64</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这只是一个非常基本的例子。在实际开发中，使用 N-API 和原生模块可以执行更复杂的操作，比如性能优化、直接与操作系统 API 交互、处理图形和音频数据等。</p><h4 id="napi-get-boolean" tabindex="-1"><a class="header-anchor" href="#napi-get-boolean"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_boolean" target="_blank" rel="noopener noreferrer">napi_get_boolean</a></span></a></h4><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎构建的平台，它允许你在服务器端运行 JavaScript。N-API 是 Node.js 提供的一个稳定的 API 层，使得原生模块（用 C 或 C++ 写的扩展）可以不受 Node.js 版本影响的情况下编译和运行。</p><p>在 Node.js v21.7.1 的文档中，<code>napi_get_boolean</code> 是 N-API 中的一个函数，它的作用是在原生代码中创建一个新的 JavaScript 布尔值。</p><p>这个函数的定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_boolean(napi_env env, bool value, napi_value* result)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code>：这是一个表示 N-API 环境的句柄，你在调用任何 N-API 函数时都需要提供这个参数。</li><li><code>value</code>：这是你想要创建的布尔值，用 C 语言中的 <code>true</code> 或 <code>false</code> 表示。</li><li><code>result</code>：这是一个指向 napi_value 的指针，napi_get_boolean 函数会将创建好的 JavaScript 布尔值存放在其中。</li></ul><p>如果函数执行成功，它会返回 <code>napi_ok</code>，这表示操作成功完成。</p><p>下面是如何在一个原生模块中使用 <code>napi_get_boolean</code> 的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 示例函数，创建一个 JS 布尔值并返回给 JavaScript</span></span>
<span class="line"><span>napi_value GetTrueValue(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value true_value;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 napi_get_boolean 来创建一个表示 true 的 JavaScript 布尔值</span></span>
<span class="line"><span>    status = napi_get_boolean(env, true, &amp;true_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否调用成功</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的布尔值</span></span>
<span class="line"><span>    return true_value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，在模块加载时设置导出</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数对象</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, GetTrueValue, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将新创建的函数作为模块的导出</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;getTrue&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个名为 <code>GetTrueValue</code> 的函数，该函数使用 <code>napi_get_boolean</code> 创建一个表示 <code>true</code> 的 JavaScript 布尔值，并返回给调用它的 JavaScript 代码。然后我们在 <code>Init</code> 函数中将 <code>GetTrueValue</code> 作为模块的导出，这样 JavaScript 代码就可以通过 <code>require</code> 加载这个模块，并调用 <code>getTrue</code> 函数来获取一个 JavaScript 中的 <code>true</code> 值。</p><p>最终，当这个原生模块被加载到 Node.js 应用中时，JavaScript 开发者可以像这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myNativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myNativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getTrue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>&#39;my-native-module&#39;</code> 是假设的原生模块名称，在实际应用中应替换为相应模块的真实名称。</p><h4 id="napi-get-global-1" tabindex="-1"><a class="header-anchor" href="#napi-get-global-1"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_global" target="_blank" rel="noopener noreferrer">napi_get_global</a></span></a></h4><p>Node.js 中的 N-API 是一个用于创建本地插件（native addons）的 API。本地插件是用 C、C++等编程语言编写的，可以直接调用 Node.js 运行时和 V8 JavaScript 引擎的功能，通常用于性能关键型任务或者调用系统级别的 API。</p><p>当你使用 N-API 编写本地插件时，经常需要和 JavaScript 的全局对象进行交互。JavaScript 中的全局对象类似于一个大容器，它包含了 JavaScript 环境中所有的全局变量、函数等。在浏览器中，这个全局对象就是<code>window</code>；而在 Node.js 中，这个全局对象通常指的是<code>global</code>。</p><p><code>napi_get_global</code>是 N-API 提供的一个函数，用于获取当前环境的全局对象。你可能会问，为什么要通过 N-API 来获取全局对象呢？因为 N-API 保护了代码不受 V8 引擎版本更新的影响，增加了代码的兼容性和稳定性。</p><p>下面是一个如何使用<code>napi_get_global</code>的简单例子：</p><p>假设我们想要从 C++代码中创建一个新的 JavaScript 函数，并将其挂载到全局对象上，让 JavaScript 代码可以直接调用这个函数。</p><p>首先，在 C++文件中，我们需要包含必要的头文件并定义我们的方法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个是我们要暴露给JavaScript的函数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 在这里实现你的功能</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化方法，用来设置导出函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 首先获取全局对象</span></span>
<span class="line"><span>    napi_value global;</span></span>
<span class="line"><span>    napi_status status = napi_get_global(env, &amp;global);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数</span></span>
<span class="line"><span>    napi_value myFunction;</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;myFunction);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将函数挂载到全局对象上</span></span>
<span class="line"><span>    status = napi_set_named_property(env, global, &quot;myGlobalFunction&quot;, myFunction);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>Init</code>函数创建了一个 JavaScript 函数<code>MyFunction</code>，然后通过调用<code>napi_get_global</code>获得全局对象，并通过<code>napi_set_named_property</code>将<code>MyFunction</code>设置为全局对象的属性。这样一来，当这个本地插件被加载进 Node.js 时，JavaScript 代码就可以直接通过<code>myGlobalFunction()</code>来调用这个函数了。</p><p>最后，在 JavaScript 文件中，你可以像这样调用 C++函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设你的本地插件叫做&#39;addon&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 直接使用在全局对象上挂载的函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myGlobalFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这只是一个简化示例，真实情况下你可能需要处理更多的边缘情况和错误。但希望通过这个例子，你能理解<code>napi_get_global</code>在 Node.js 中的作用及其基本用法。</p><h4 id="napi-get-null" tabindex="-1"><a class="header-anchor" href="#napi-get-null"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_null" target="_blank" rel="noopener noreferrer">napi_get_null</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建原生插件的 API，它提供了一组用 C 语言编写的 API，允许你创建可以直接与 JavaScript 运行时交互的本地代码。这样做的好处是能够在本地代码中执行高性能或更底层操作，同时保持跨不同版本 Node.js 的兼容性。</p><p><code>napi_get_null</code> 是 N-API 中的一个函数，它用于获取 JavaScript 的 <code>null</code> 值的引用。在编写原生插件时，可能需要返回一个 <code>null</code> 值给 JavaScript 环境，<code>napi_get_null</code> 允许你做到这一点。</p><p>下面是一个使用 <code>napi_get_null</code> 函数的简单例子：</p><p>假设我们正在编写一个原生模块，该模块包含一个函数，当某个条件满足时要返回 <code>null</code> 给 JavaScript：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是我们将暴露给JavaScript的函数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查某个条件是否满足</span></span>
<span class="line"><span>    bool condition = true; // 假设条件为真</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (condition) {</span></span>
<span class="line"><span>        // 如果条件满足，我们想要返回 null 给 JavaScript。</span></span>
<span class="line"><span>        napi_status status = napi_get_null(env, &amp;result);</span></span>
<span class="line"><span>        if (status != napi_ok) {</span></span>
<span class="line"><span>            // 处理错误情况</span></span>
<span class="line"><span>            napi_throw_error(env, NULL, &quot;Unable to create null value&quot;);</span></span>
<span class="line"><span>            return NULL;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果条件不满足，我们返回其他值，比如数字0</span></span>
<span class="line"><span>        napi_create_int32(env, 0, &amp;result);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册上面的函数，使其可以从 JavaScript 代码中调用</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个JavaScript函数</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个函数设置为导出对象的属性</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，如果 <code>condition</code> 为真，则 <code>MyFunction</code> 函数将返回 JavaScript 中的 <code>null</code>; 如果不为真，则会返回数字 0。</p><p>要注意的是，以上代码是 C/C++ 代码，它必须与 Node.js 配合使用并通过特定的步骤来编译和绑定。创建完整的原生模块需要一些额外的配置和工具，例如 <code>node-gyp</code> 来编译模块，以及在项目中声明对 N-API 版本的依赖。</p><p>希望这个解释和例子帮助您理解 <code>napi_get_null</code> 在 Node.js 中的作用和如何使用！</p><h4 id="napi-get-undefined" tabindex="-1"><a class="header-anchor" href="#napi-get-undefined"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_undefined" target="_blank" rel="noopener noreferrer">napi_get_undefined</a></span></a></h4><p>当然，我很乐意帮助你理解<code>napi_get_undefined</code>这个函数。</p><p>N-API 是 Node.js 的一个 API，它允许 C 和 C++代码与 Node.js 交互，也就是说它提供了一系列的工具，使得原生模块（通常用 C 或 C++编写）能够与 JavaScript 代码沟通。<code>napi_get_undefined</code>是其中的一个函数，它的作用是获取 JavaScript 中的<code>undefined</code>值。</p><p>在 JavaScript 里，<code>undefined</code>是一个特殊的值，表示变量没有被赋值。在 Native Addon（原生扩展模块）中，经常需要创建 JavaScript 值以便于传递数据或者和 JavaScript 层面的代码进行互动。<code>napi_get_undefined</code>函数就是用来创建这样一个<code>undefined</code>值的。</p><p>现在我们来看一个例子。假设你正在编写一个 C++的扩展模块，你可能会需要创建一个函数，在某些条件下返回<code>undefined</code>给 JavaScript。示例代码如下：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将会被暴露给JavaScript，并在被调用时返回undefined</span></span>
<span class="line"><span>napi_value GetUndefinedExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 定义一个用于存放结果的napi_value变量</span></span>
<span class="line"><span>  napi_value undefined;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用napi_get_undefined获取JavaScript的undefined值</span></span>
<span class="line"><span>  napi_status status = napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查调用是否成功</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 如果有错误发生，可以根据实际情况处理错误</span></span>
<span class="line"><span>    // 这里我们简单地返回空值</span></span>
<span class="line"><span>    return nullptr;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回undefined值给JavaScript</span></span>
<span class="line"><span>  return undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册GetUndefinedExample函数到exports对象上</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个JavaScript函数</span></span>
<span class="line"><span>  status = napi_create_function(env, nullptr, 0, GetUndefinedExample, nullptr, &amp;fn);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    return nullptr;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将这个函数作为&quot;getUndefined&quot;属性添加到exports对象</span></span>
<span class="line"><span>  status = napi_set_named_property(env, exports, &quot;getUndefined&quot;, fn);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    return nullptr;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述的 C++代码中，我们定义了一个<code>GetUndefinedExample</code>函数，这个函数使用了<code>napi_get_undefined</code>来获取一个 undefined 值，并将其返回给调用它的 JavaScript 代码。</p><p>在 JavaScript 端，你能够像这样使用这个模块：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/nativeAddon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getUndefined</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：undefined</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段 JavaScript 代码里，我们首先加载了我们刚才写的原生模块，然后调用了<code>getUndefined</code>函数，并打印了它的返回值，它应该是<code>undefined</code>。</p><h2 id="working-with-javascript-values-and-abstract-operations" tabindex="-1"><a class="header-anchor" href="#working-with-javascript-values-and-abstract-operations"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#working-with-javascript-values-and-abstract-operations" target="_blank" rel="noopener noreferrer">Working with JavaScript values and abstract operations</a></span></a></h2><p>Node.js 是一个能让你使用 JavaScript 来编写服务器端代码的平台。它具备非阻塞 I/O 和事件驱动的特点，这意味着 Node.js 很擅长处理大量并发的数据交互，比如网络应用或实时系统。</p><p>N-API（Node API）是 Node.js 提供的一个稳定且版本无关的 API，允许原生插件开发者编译只需一次即可在不同版本的 Node.js 上运行。这就减少了因 Node.js 升级导致的插件兼容性问题。</p><p>在 Node.js v21.7.1 的文档中，“Working with JavaScript values and abstract operations”部分描述了如何通过 N-API 在原生代码中创建和操作 JavaScript 值，以及执行一些抽象操作。我们来逐个看一些基本概念和例子：</p><h3 id="javascript-值-values" tabindex="-1"><a class="header-anchor" href="#javascript-值-values"><span>JavaScript 值 (Values)</span></a></h3><p>JavaScript 中的值可以是数字、字符串、对象、数组等。在原生模块中与这些值进行交互需要使用 N-API 提供的函数。例如，如果你想从 C/C++ 代码中创建一个新的 JavaScript 数字，你可以使用 <code>napi_create_number</code> 函数。</p><h4 id="实例-创建一个-javascript-数字" tabindex="-1"><a class="header-anchor" href="#实例-创建一个-javascript-数字"><span>实例：创建一个 JavaScript 数字</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateNumber(napi_env env) {</span></span>
<span class="line"><span>    napi_value num;</span></span>
<span class="line"><span>    napi_status status = napi_create_double(env, 123.456, &amp;num);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return num; // 这是一个 JavaScript 数字</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="抽象操作-abstract-operations" tabindex="-1"><a class="header-anchor" href="#抽象操作-abstract-operations"><span>抽象操作 (Abstract Operations)</span></a></h3><p>“抽象操作”是指那些定义在 ECMAScript 规范里，对 JavaScript 值进行操作的步骤。在 N-API 中，有很多函数被提供出来以支持这些操作。</p><h4 id="实例-调用-javascript-函数" tabindex="-1"><a class="header-anchor" href="#实例-调用-javascript-函数"><span>实例：调用 JavaScript 函数</span></a></h4><p>如果你有一个 JavaScript 函数，想要从 C/C++ 代码中调用它，你可以使用 <code>napi_call_function</code>。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CallJsFunction(napi_env env, napi_value jsFunction) {</span></span>
<span class="line"><span>    // 假设我们已经有了一个 &#39;env&#39; 环境标识符和一个 &#39;jsFunction&#39; 表示 JavaScript 函数的值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 JavaScript 字符串参数</span></span>
<span class="line"><span>    napi_value arg;</span></span>
<span class="line"><span>    napi_status status = napi_create_string_utf8(env, &quot;Hello from native code!&quot;, -1, &amp;arg);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 JavaScript 函数，传递一个参数</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_call_function(env, global, jsFunction, 1, &amp;arg, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // &#39;result&#39; 现在包含了 JavaScript 函数的返回值</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们首先创建了一个表示 JavaScript 字符串的 <code>napi_value</code>，然后我们调用 JavaScript 函数，并将创建的字符串作为参数传递给它。</p><p>记住，每当你从 C/C++ 代码中操作 JavaScript 对象时，都需要检查返回的 <code>napi_status</code>。这是因为所有的 N-API 函数几乎都会返回状态码，告诉你操作是否成功，或者是否有错误发生。如果有错误发生，你通常需要采取某种措施来处理它，比如抛出一个错误或者停止当前操作。</p><p>总结一下，Node.js 中的 N-API 让你能够在原生模块中安全地创建和操作 JavaScript 值，并执行抽象操作。通过这样的方式，你可以构建更高效、跨 Node.js 版本兼容的原生插件。</p><h3 id="napi-coerce-to-bool" tabindex="-1"><a class="header-anchor" href="#napi-coerce-to-bool"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_coerce_to_bool" target="_blank" rel="noopener noreferrer">napi_coerce_to_bool</a></span></a></h3><p>Node.js 中的 <code>napi_coerce_to_bool</code> 是 N-API（原生 API）的一个函数，它用于将一个 JavaScript 值转换成一个布尔值。在 JavaScript 中，很多类型的值都可以有一个“真值”或“假值”的概念，这就是我们通常所说的 truthy 或 falsy 值。</p><h3 id="如何理解-bool" tabindex="-1"><a class="header-anchor" href="#如何理解-bool"><span>如何理解 bool</span></a></h3><p>在 JavaScript 中，以下值被认为是 falsy，也就是它们会被转换成布尔值 <code>false</code>：</p><ul><li><code>false</code></li><li><code>0</code></li><li><code>-0</code></li><li><code>0n</code> （BigInt 的零）</li><li><code>&quot;&quot;</code> （空字符串）</li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code></li></ul><p>其他所有值都被认为是 truthy，即转换成布尔值 <code>true</code>。例如：<code>true</code>, <code>1</code>, <code>&quot;hello&quot;</code>, <code>[]</code> （空数组）, <code>{}</code> （空对象）等。</p><h3 id="napi-coerce-to-bool-的作用" tabindex="-1"><a class="header-anchor" href="#napi-coerce-to-bool-的作用"><span><code>napi_coerce_to_bool</code> 的作用</span></a></h3><p>当你在使用 Node.js 的 N-API 编写原生插件时，你可能会处理来自 JavaScript 环境的值。<code>napi_coerce_to_bool</code> 允许你把这些值转换成一个确切的布尔值，这样你就可以在 C 或 C++ 代码中更容易地根据这个布尔值进行逻辑处理。</p><h3 id="使用-napi-coerce-to-bool" tabindex="-1"><a class="header-anchor" href="#使用-napi-coerce-to-bool"><span>使用 <code>napi_coerce_to_bool</code></span></a></h3><p>举个例子，在 Node.js 的原生模块中，你可能接收到了一个 JavaScript 值，并希望检查它是否为 &quot;truthy&quot; 或 &quot;falsy&quot;。你可以使用 <code>napi_coerce_to_bool</code> 来执行这个操作：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 `env` 是 napi_env 类型的变量，代表N-API环境。</span></span>
<span class="line"><span>// `value` 是 napi_value 类型的变量，代表JavaScript传递给原生函数的值。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>napi_status status = napi_coerce_to_bool(env, value, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在 `result` 包含了转换后的布尔值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>value</code> 是一个从 JavaScript 传过来的任意类型的值，<code>napi_coerce_to_bool</code> 函数会尝试将其转化为一个布尔值。转换结果存放在 <code>result</code> 中，这是一个 <code>napi_value</code> 类型的变量，它代表了一个 node.js 中的布尔值。</p><p>如果转换成功，你就可以继续使用这个布尔值进行逻辑判断。否则，如果出现了错误（比如传入的不是有效的 JavaScript 值），<code>status</code> 变量会包含表示错误状态的代码，你可以根据这个来进行相应的错误处理。</p><h3 id="实际运用示例-3" tabindex="-1"><a class="header-anchor" href="#实际运用示例-3"><span>实际运用示例</span></a></h3><p>如果你正在编写一个需要验证 JavaScript 参数并基于该参数决定行为的原生模块，你可能会像这样使用 <code>napi_coerce_to_bool</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 转换第一个参数为布尔值</span></span>
<span class="line"><span>    napi_coerce_to_bool(env, args[0], &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 基于布尔值的结果执行不同的操作</span></span>
<span class="line"><span>    bool c_result;</span></span>
<span class="line"><span>    napi_get_value_bool(env, result, &amp;c_result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (c_result) {</span></span>
<span class="line"><span>        // 如果是 true, 执行某些操作</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果是 false, 执行其他操作</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一些结果给 JavaScript 端</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>MyNativeFunction</code> 是一个会被 JavaScript 调用的函数。我们获取了调用这个函数时传递的第一个参数（<code>args[0]</code>），并尝试将其强制转换为布尔值。然后我们根据转换得到的布尔值来决定接下来的行为，并最终返回一个结果给 JavaScript。</p><h3 id="napi-coerce-to-number" tabindex="-1"><a class="header-anchor" href="#napi-coerce-to-number"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_coerce_to_number" target="_blank" rel="noopener noreferrer">napi_coerce_to_number</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建原生插件的 API，它不依赖于 JavaScript 引擎（如 V8）的变化，因此可以保持向后兼容性。<code>napi_coerce_to_number</code> 是其中的一个函数，它的作用是将任何 JavaScript 值转换成数字类型。</p><p>在 JavaScript 中，你可以有很多不同类型的值，比如字符串、布尔值、对象等。有时候我们希望把这些值转换成数字进行计算或比较。这就是 <code>napi_coerce_to_number</code> 函数存在的意义。当你创建一个原生插件，并希望接受一个 JavaScript 值并确保它为数字时，这个函数会特别有用。</p><p><strong>举几个例子：</strong></p><ol><li><p><strong>将字符串转换为数字</strong><br> 假设你在 JavaScript 中调用了一个原生插件的函数，传递了一个表示数字的字符串，比如 <code>&quot;123&quot;</code>。在原生插件中，你可以使用 <code>napi_coerce_to_number</code> 来确保你得到一个数字类型的值。</p></li><li><p><strong>将布尔值转换为数字</strong><br> 在 JavaScript 中，布尔值 <code>true</code> 和 <code>false</code> 可以被隐式地转换为数字 <code>1</code> 和 <code>0</code>。如果你传递了一个布尔值到原生插件，你可能需要使用 <code>napi_coerce_to_number</code> 把它转换为数字，然后再进行后续处理。</p></li><li><p><strong>处理 uncertain 类型数据</strong><br> 如果你的原生插件功能是做数学运算，但你不确定用户会传递什么类型的数据，你可以使用 <code>napi_coerce_to_number</code> 来尝试将传入的值转换为数字，而不用担心它实际上是不是数字。</p></li></ol><p><strong>代码示例</strong>:</p><p>假设我们要编写一个简单的原生插件函数 <code>add</code>, 它接收两个参数，把它们都转换为数字，然后相加。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Add(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span>    double value1, value2;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 强制转换第一个参数为数字</span></span>
<span class="line"><span>    napi_value numberValue1;</span></span>
<span class="line"><span>    status = napi_coerce_to_number(env, args[0], &amp;numberValue1);</span></span>
<span class="line"><span>    status = napi_get_value_double(env, numberValue1, &amp;value1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 强制转换第二个参数为数字</span></span>
<span class="line"><span>    napi_value numberValue2;</span></span>
<span class="line"><span>    status = napi_coerce_to_number(env, args[1], &amp;numberValue2);</span></span>
<span class="line"><span>    status = napi_get_value_double(env, numberValue2, &amp;value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 执行加法运算</span></span>
<span class="line"><span>    napi_value sum;</span></span>
<span class="line"><span>    status = napi_create_double(env, value1 + value2, &amp;sum);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return sum;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册 `Add` 函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value add_function;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, Add, NULL, &amp;add_function);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;add&quot;, add_function);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们首先通过 <code>napi_get_cb_info</code> 获取 JavaScript 传递来的参数，然后分别使用 <code>napi_coerce_to_number</code> 将这两个参数强制转换为数字。随后，我们使用 <code>napi_get_value_double</code> 获取它们的数值，执行加法操作，并最终返回结果。</p><p>要注意的是，在实际应用中，我们还需要检查 <code>status</code> 确保每步操作都成功执行，以及处理可能出现的错误，但为了简明起见，这里省略了这些步骤。</p><h3 id="napi-coerce-to-object" tabindex="-1"><a class="header-anchor" href="#napi-coerce-to-object"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_coerce_to_object" target="_blank" rel="noopener noreferrer">napi_coerce_to_object</a></span></a></h3><p>好的，让我们详细了解一下 Node.js 中的<code>napi_coerce_to_object</code>这个函数。</p><p>首先，<code>napi</code>代表的是 Node.js 的原生 API (N-API)，它允许你用 C 或 C++编写可加载到 Node.js 环境中的扩展。这样做的优点是可以构建性能更高的模块，并且可以直接使用系统级别的资源或者其他非 JavaScript 资源。</p><p><code>napi_coerce_to_object</code>是 N-API 提供的一个函数，它的作用是将一个 JavaScript 值强制转换成一个 JavaScript 对象。在 JavaScript 中，基本类型（如数字、字符串、布尔值）与对象是有区别的。但有些时候，我们需要将基本类型当作对象来处理。例如，当我们想调用某个基本类型的方法时，就需要将其转为对象。</p><p>在 Node.js 的 N-API 中，<code>napi_coerce_to_object</code>函数可以帮助我们做这样的转换。这个函数的签名如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_coerce_to_object(napi_env env, napi_value value, napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code>：表示当前的 N-API 环境。</li><li><code>value</code>：是要被转换的 JavaScript 值。</li><li><code>result</code>：是一个指针，指向转换后的 JavaScript 对象。</li></ul><p>现在我来举几个实例说明它的使用：</p><h3 id="实例-1-将数字转换为对象" tabindex="-1"><a class="header-anchor" href="#实例-1-将数字转换为对象"><span>实例 1：将数字转换为对象</span></a></h3><p>假设在 JavaScript 中，我们有一个数字 3.14，我们想调用它的<code>toFixed()</code>方法，将它格式化为 2 位小数的字符串。在纯 JavaScript 操作中，你可以直接调用<code>3.14.toFixed(2)</code>，而在 C++扩展中，如果你拥有的是一个<code>napi_value</code>类型的数字，你可能需要先将它转为对象才能对其进行操作。</p><p>在 C++扩展中的代码可能会像这样：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value number_value;</span></span>
<span class="line"><span>napi_value number_object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设number_value已经是一个包含数字3.14的napi_value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在将这个数字强制转换为JS对象</span></span>
<span class="line"><span>status = napi_coerce_to_object(env, number_value, &amp;number_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>    // 转换成功，number_object现在是一个封装了数字3.14的JS对象</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实例-2-将字符串转换为对象" tabindex="-1"><a class="header-anchor" href="#实例-2-将字符串转换为对象"><span>实例 2：将字符串转换为对象</span></a></h3><p>同理，如果你有一个 JavaScript 的字符串，并且你希望以对象的形式工作于它，比如获取字符长度或者使用正则表达式，则可以使用<code>napi_coerce_to_object</code>将其转为对象。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value string_value;</span></span>
<span class="line"><span>napi_value string_object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设string_value已经是一个包含字符串&quot;hello&quot;的napi_value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 现在将这个字符串强制转换为JS对象</span></span>
<span class="line"><span>status = napi_coerce_to_object(env, string_value, &amp;string_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>    // 转换成功，string_object现在是一个封装了字符串&quot;hello&quot;的JS对象</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总之，<code>napi_coerce_to_object</code>函数在你需要将 N-API 中的基本类型转换为 JavaScript 对象时非常有用，特别是当你需要对这些值执行一些只有对象才能执行的操作（如调用方法或访问属性）时。通过上述例子，我希望你能更好地理解这个函数的作用和如何在实际中使用它。</p><h3 id="napi-coerce-to-string" tabindex="-1"><a class="header-anchor" href="#napi-coerce-to-string"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_coerce_to_string" target="_blank" rel="noopener noreferrer">napi_coerce_to_string</a></span></a></h3><p>在 Node.js 中，<code>napi_coerce_to_string</code>是 N-API 框架的一部分，N-API 是一个用于构建本地插件的 API。<code>napi_coerce_to_string</code>这个函数被用来将其他类型的变量转换为字符串类型。</p><p>简单来说，当你在编写本地插件时，可能会遇到需要处理来自 JavaScript 层面的各种类型的数据，例如数字、布尔值或者对象。有时候，为了操作方便或者满足特定的需求，你需要将这些数据转换成字符串。</p><p><code>napi_coerce_to_string</code>函数就是用于执行这种转换的。当你调用这个函数，并传入一个 N-API 值（代表任意 JavaScript 值），它会尝试把这个值转换为一个 N-API 字符串。</p><p>下面是一个使用<code>napi_coerce_to_string</code>的例子：</p><p>假设我们正在编写一个 Node.js 本地插件，该插件提供了一个方法<code>printValueAsString</code>，这个方法接收一个参数，并将其打印出来，但是无论传入参数的实际类型如何，都要作为字符串进行打印。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是我们将要注册的Native方法</span></span>
<span class="line"><span>napi_value PrintValueAsString(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递给该方法的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将参数强制转换为字符串</span></span>
<span class="line"><span>    napi_coerce_to_string(env, args[0], &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们想要打印转换后的字符串</span></span>
<span class="line"><span>    // 通常情况下我们需要进一步从napi_value提取C字符串，然后使用printf</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result; // 返回转化后的字符串</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册我们的native方法</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, PrintValueAsString, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置导出对象的属性</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;printValueAsString&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 中使用这个插件可能看起来像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">printValueAsString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打印: &#39;123&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">printValueAsString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打印: &#39;true&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">printValueAsString</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> })); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 打印: &#39;[object Object]&#39; 或者更具体的字符串表示，这取决于对象的toString()方法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述例子中，不管我们传给<code>printValueAsString</code>函数什么类型的参数，它都会尝试将其转换为字符串再返回。这就是<code>napi_coerce_to_string</code>在实际应用中的一个典型用法。</p><h3 id="napi-typeof" tabindex="-1"><a class="header-anchor" href="#napi-typeof"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_typeof" target="_blank" rel="noopener noreferrer">napi_typeof</a></span></a></h3><p><code>napi_typeof</code> 是 Node.js 中的一个函数，属于 N-API（Node.js API）的一部分。N-API 是一个用来构建原生插件的 API，它允许你使用 C 或 C++ 代码编写可直接与 JavaScript 交互的扩展。</p><p>在解释 <code>napi_typeof</code> 之前，我们得先理解 JavaScript 中的类型系统。JavaScript 是一种动态类型语言，这意味着变量没有固定的类型，同一个变量可以被赋予不同类型的值。例如，一个变量可以开始时是一个数字，然后又被赋值为字符串。但在底层，JavaScript 引擎需要知道一个值具体是什么类型的数据。</p><p>当开发者使用 N-API 编写原生插件时，他们经常需要知道从 JavaScript 代码传递过来的值是什么类型。这时候 <code>napi_typeof</code> 函数就派上用场了。这个函数可以帮助开发者确定一个给定的 <code>napi_value</code>（表示 JavaScript 值的 C 类型）是哪种 JavaScript 数据类型。</p><p>下面是几个数据类型的例子：</p><ul><li>Number: 表示数字，比如 <code>42</code> 或 <code>3.14159</code>。</li><li>String: 表示文本，比如 <code>&quot;hello world&quot;</code>。</li><li>Boolean: 表示逻辑真或假，即 <code>true</code> 或 <code>false</code>。</li><li>Object: 表示对象，可以包含多个键值对。</li><li>Function: 表示函数，可以被调用。</li></ul><p>而 <code>napi_typeof</code> 函数正是用来检查这些类型。</p><p>举个实际例子，假设你正在编写一个原生插件，该插件提供了一个函数，这个函数接收一个参数，并根据这个参数的类型执行不同的操作：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是一个 N-API 调用的例子</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 传入的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数的类型</span></span>
<span class="line"><span>    napi_valuetype arg_type;</span></span>
<span class="line"><span>    napi_typeof(env, args[0], &amp;arg_type);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (arg_type == napi_string) {</span></span>
<span class="line"><span>        // 参数是字符串</span></span>
<span class="line"><span>        // ... 处理字符串逻辑 ...</span></span>
<span class="line"><span>    } else if (arg_type == napi_number) {</span></span>
<span class="line"><span>        // 参数是数字</span></span>
<span class="line"><span>        // ... 处理数字逻辑 ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // ... 其他类型的处理 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一个 JavaScript 的 undefined 值</span></span>
<span class="line"><span>    napi_value undefined_value;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined_value);</span></span>
<span class="line"><span>    return undefined_value;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>//文書は桜茶から来ています。商用目的では使用しないでください。</span></span>
<span class="line"><span>// 注册函数到 N-API</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们首先通过 <code>napi_get_cb_info</code> 获取到 JavaScript 传递给这个函数的参数。然后我们使用 <code>napi_typeof</code> 来判断这个参数的类型是否为字符串（<code>napi_string</code>）或数字（<code>napi_number</code>）。根据参数的类型，我们可以决定执行不同的代码逻辑。</p><p>最后，我们的函数返回了一个 <code>undefined</code> 值给 JavaScript 环境，因为我们没有指定其他的返回值。</p><p>通过这样的方式，<code>napi_typeof</code> 让我们能够在原生插件中更好地与 JavaScript 交互，并安全地处理不同类型的数据。</p><h3 id="napi-instanceof" tabindex="-1"><a class="header-anchor" href="#napi-instanceof"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_instanceof" target="_blank" rel="noopener noreferrer">napi_instanceof</a></span></a></h3><p><code>napi_instanceof</code> 是 Node.js 中的一个 N-API 函数，它用来判断一个对象是否是某个构造函数的实例。N-API 是一个 C 层面的 API，允许原生插件与 Node.js 进行交互，不受到特定版本 Node.js 的限制。</p><p>要理解 <code>napi_instanceof</code>，首先得知道 JavaScript 中的 <code>instanceof</code> 操作符做什么。在 JavaScript 中，我们使用 <code>instanceof</code> 来检查一个对象是否为特定构造函数创建的实例，例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Car</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">make</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">model</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">make</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">model</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> model</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myCar</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Car</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Toyota&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Corolla&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myCar</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Car</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myCar</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myCar</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>myCar</code> 是使用 <code>Car</code> 构造函数创建的，所以 <code>myCar instanceof Car</code> 返回 <code>true</code>。由于所有的 JavaScript 对象都默认继承自 <code>Object</code>，<code>myCar instanceof Object</code> 也返回 <code>true</code>。但是 <code>myCar</code> 不是数组，所以 <code>myCar instanceof Array</code> 返回 <code>false</code>。</p><p>现在，当我们使用 Node.js 的 N-API 编写本地插件时，我们会用到 C 或者 C++。在这些语言中，你不能直接使用 JavaScript 的 <code>instanceof</code> 操作符。而是需要使用 <code>napi_instanceof</code> 函数来完成相同的任务。</p><p><code>napi_instanceof</code> 函数的原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_instanceof(napi_env env,</span></span>
<span class="line"><span>                            napi_value object,</span></span>
<span class="line"><span>                            napi_value constructor,</span></span>
<span class="line"><span>                            bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的参数含义如下：</p><ul><li><code>env</code>: <code>napi_env</code> 类型，代表 Node.js 的运行环境，通过这个环境可以进行 API 调用。</li><li><code>object</code>: <code>napi_value</code> 类型，要检查的 JavaScript 对象。</li><li><code>constructor</code>: <code>napi_value</code> 类型，用作比较的构造函数。</li><li><code>result</code>: <code>bool*</code> 类型，指向布尔值的指针，函数调用后，该位置的值会更新为检查结果（<code>true</code> 或 <code>false</code>）。</li></ul><p>当你调用 <code>napi_instanceof</code> 后，如果 <code>object</code> 是 <code>constructor</code> 的实例，<code>result</code> 所指向的布尔值将被设置为 <code>true</code>，否则为 <code>false</code>。</p><p>让我们举一个简单的例子，假设我们已经有了 <code>Car</code> 构造函数和一个 <code>carObject</code> 实例，我们想在 C/C++ 的 N-API 插件中检查它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设在某处定义了 carObject 和 CarConstructor 的 napi_value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>bool isInstanceOf;</span></span>
<span class="line"><span>napi_status status = napi_instanceof(env, carObject, CarConstructor, &amp;isInstanceOf);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok &amp;&amp; isInstanceOf) {</span></span>
<span class="line"><span>    // carObject 是 CarConstructor 创建的实例</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // carObject 不是 CarConstructor 创建的实例或者检查失败</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述 C 代码中，我们检查 <code>carObject</code> 是否是 <code>CarConstructor</code> 的实例，并根据结果执行相应操作。</p><p>总结一下，<code>napi_instanceof</code> 允许你在编写 Node.js 原生插件时，在 C/C++ 代码中执行与 JavaScript 中 <code>instanceof</code> 类似的操作。通过 N-API，你能够安全地进行类型检查，从而保证你的插件可以正确处理传入的 JavaScript 对象。</p><h3 id="napi-is-array" tabindex="-1"><a class="header-anchor" href="#napi-is-array"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_array" target="_blank" rel="noopener noreferrer">napi_is_array</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。原生插件是指直接使用 C、C++等语言编写，然后可以在 Node.js 代码中调用的模块。这使得开发者能够在性能关键的场合下利用本地库的高效性能。</p><p><code>napi_is_array</code> 是 N-API 的一部分，它提供了一种方法来确定一个 <code>napi_value</code> 是否表示一个 JavaScript 数组。<code>napi_value</code> 是 N-API 中用来表示 JavaScript 值的一个抽象类型，不管这个值是数字、对象、函数还是数组。</p><p>下面的步骤将会详细介绍如何在原生插件中使用 <code>napi_is_array</code> 函数，并且给出一个简单的例子：</p><h3 id="使用-napi-is-array-函数的步骤" tabindex="-1"><a class="header-anchor" href="#使用-napi-is-array-函数的步骤"><span>使用 <code>napi_is_array</code> 函数的步骤</span></a></h3><ol><li><p><strong>获取 napi_env</strong>：为了使用任意 N-API 函数，你需要有一个 <code>napi_env</code> 环境变量。这个环境变量通常是作为原生函数的参数传入的，代表当前的 Node.js 运行时环境。</p></li><li><p><strong>准备 napi_value</strong>：你需要拥有或得到一个 <code>napi_value</code>，它代表想要检查的 JavaScript 值。</p></li><li><p><strong>调用 napi_is_array</strong>：使用 <code>napi_is_array</code> 来判断这个 <code>napi_value</code> 是否表示一个数组。函数会返回一个布尔值来告知你结果。</p></li><li><p><strong>处理结果</strong>：根据返回的布尔值，执行相应的逻辑。</p></li></ol><h3 id="实际运用的例子-6" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-6"><span>实际运用的例子</span></a></h3><p>假设我们正在编写一个原生插件的函数，该函数需要检查传入的 JavaScript 参数是否为数组。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义一个原生函数，它接收一个参数并判断这个参数是否为数组。</span></span>
<span class="line"><span>napi_value IsArray(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 定义必要的变量</span></span>
<span class="line"><span>    napi_value argv[1]; // 用于存放参数的数组</span></span>
<span class="line"><span>    size_t argc = 1;    // 参数的数量</span></span>
<span class="line"><span>    bool is_array = false;</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 解析参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 napi_is_array 判断第一个参数是否为数组</span></span>
<span class="line"><span>    napi_is_array(env, argv[0], &amp;is_array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 根据 is_array 的值创建一个 JavaScript 布尔值</span></span>
<span class="line"><span>    napi_get_boolean(env, is_array, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回这个布尔值</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 定义一个属性描述符，让 JavaScript 能够调用 IsArray 函数</span></span>
<span class="line"><span>    napi_property_descriptor desc = { &quot;isArray&quot;, 0, IsArray, 0, 0, 0, napi_default, 0 };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 IsArray 函数绑定到导出对象上</span></span>
<span class="line"><span>    napi_define_properties(env, exports, 1, &amp;desc);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 C 代码示例定义了一个名为 <code>IsArray</code> 的函数，它检查传入的参数是否为数组，并返回 true 或 false。这个函数之后被暴露给 JavaScript 代码，因此 JavaScript 代码可以像调用普通的 JavaScript 函数那样调用它。</p><p>JavaScript 代码可能长这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">])); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> })); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 代码中，我们首先通过 <code>require</code> 引入了构建好的原生插件模块。然后我们调用了 <code>nativeAddon.isArray</code> 方法，并向它传递了不同类型的参数进行测试。</p><p>通过这样的方式，我们实现了从 JavaScript 到原生代码再回到 JavaScript 的通信和操作，而 <code>napi_is_array</code> 在此过程中扮演了判断数组的关键角色。</p><h3 id="napi-is-arraybuffer" tabindex="-1"><a class="header-anchor" href="#napi-is-arraybuffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_arraybuffer" target="_blank" rel="noopener noreferrer">napi_is_arraybuffer</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，它允许你在服务器端运行 JavaScript 代码。N-API（Node.js API）是 Node.js 提供的一套用于构建原生插件的 API，使得你可以用 C 或 C++ 语言来写扩展模块，并且这些模块在 Node.js 的不同版本中保持兼容。</p><p><code>napi_is_arraybuffer</code> 是 N-API 中的一个函数，它用来检查一个给定的 <code>napi_value</code> 是否是一个 ArrayBuffer。ArrayBuffer 是 JavaScript 中的一个全局对象，用于表示通用的、固定长度的原始二进制数据缓冲区。你不能直接操作 ArrayBuffer 的内容；相反，你使用类型化数组或 DataView 对象来处理原始缓冲区的数据。</p><p>这里是 <code>napi_is_arraybuffer</code> 函数的简要说明：</p><ul><li>参数：该函数接受两个参数。第一个参数是环境句柄 <code>env</code>，它代表了当前的 N-API 调用环境。第二个参数 <code>value</code> 是要检查的 <code>napi_value</code>。</li><li>返回值：返回一个布尔值，通过第三个参数 <code>result</code> 返回。如果 <code>value</code> 是一个 ArrayBuffer，则 <code>*result</code> 设置为 <code>true</code>；否则设置为 <code>false</code>。</li></ul><p>实际应用示例：</p><p>假设你正在编写一个 Node.js 原生插件，需要检查从 JavaScript 传递过来的参数是否是一个 ArrayBuffer。</p><p>C/C++ 代码示例:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他必要的初始化代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CheckIfArrayBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  napi_value returnValue;</span></span>
<span class="line"><span>  bool is_arraybuffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 解析参数</span></span>
<span class="line"><span>  napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查 args[0] 是否是 ArrayBuffer</span></span>
<span class="line"><span>  napi_status status = napi_is_arraybuffer(env, args[0], &amp;is_arraybuffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (status == napi_ok &amp;&amp; is_arraybuffer) {</span></span>
<span class="line"><span>    // 是 ArrayBuffer</span></span>
<span class="line"><span>    napi_get_boolean(env, true, &amp;returnValue);</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    // 不是 ArrayBuffer</span></span>
<span class="line"><span>    napi_get_boolean(env, false, &amp;returnValue);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return returnValue;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 注册函数等其他代码 ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 <code>CheckIfArrayBuffer</code> 函数会被注册到 Node.js 环境中，并由 JavaScript 调用。它会检查传入的参数是否是 ArrayBuffer 并返回相应的布尔值。</p><p>JavaScript 调用示例:</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> buffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> notBuffer</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CheckIfArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出应该是 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CheckIfArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">notBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出应该是 false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，可能需要安装和配置额外的工具和库才能编译和构建原生插件，比如 node-gyp。上面的例子只是展示了如何使用 <code>napi_is_arraybuffer</code> 函数，没有包括全部必要的构建步骤。</p><h3 id="napi-is-buffer" tabindex="-1"><a class="header-anchor" href="#napi-is-buffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_buffer" target="_blank" rel="noopener noreferrer">napi_is_buffer</a></span></a></h3><p><code>napi_is_buffer</code> 是 Node.js 中的一个 N-API 函数，用来判断传入的 <code>napi_value</code> 是否是一个 Node.js Buffer 对象。Node.js Buffer 类是用来处理二进制数据流的类，在 Node.js 中经常被用来读写数据，比如文件、网络通信等。</p><p>在了解 <code>napi_is_buffer</code> 之前，首先要知道 N-API（Node.js API）是 Node.js 提供的一套用 C 或 C++ 编写扩展的 API，这些 API 是独立于 V8 引擎，可以使得编写的本地插件可以跨不同版本的 Node.js 运行。</p><p>现在，我们来具体看一下 <code>napi_is_buffer</code> 函数：</p><p>函数原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_is_buffer(napi_env env, napi_value value, bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code> 是表示当前执行环境的句柄。</li><li><code>value</code> 是你想要检测是否为 Buffer 的 JavaScript 值。</li><li><code>result</code> 是一个指向布尔值的指针，函数会将检测结果存储在这个布尔值中。</li></ul><p>当你调用 <code>napi_is_buffer</code> 后，如果 <code>value</code> 是一个 Buffer 对象，那么在 <code>result</code> 指向的布尔值会被设置为 <code>true</code>，否则会被设置为 <code>false</code>。</p><p>这里是一个简化的例子，展示了如何在一个 N-API 扩展中使用 <code>napi_is_buffer</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//... 在其他代码中</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void SomeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value arg = args[0];</span></span>
<span class="line"><span>    bool isBuffer;</span></span>
<span class="line"><span>    napi_status status = napi_is_buffer(env, arg, &amp;isBuffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理可能发生的错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (isBuffer) {</span></span>
<span class="line"><span>        // 如果是 Buffer, 则执行相关操作</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果不是 Buffer, 则执行其他逻辑或返回错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//... 其他代码和模块导出逻辑</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述例子中，<code>SomeFunction</code> 作为一个 N-API 函数可能会被 JavaScript 调用，它接收参数并判断第一个参数是否是 Buffer。如果是 Buffer 类型，你可以进行如读取数据、处理二进制信息等操作；如果不是，则可以选择抛出错误或者进行其它逻辑处理。</p><p>在实际应用中，可能要处理从文件读取数据、接收网络请求的数据等情况，这时候用 <code>napi_is_buffer</code> 来确保接收到的数据是正确的 Buffer 对象非常有用。这样的检查能够让你的本地扩展更加健壮，避免因类型错误而引发的问题。</p><h3 id="napi-is-date" tabindex="-1"><a class="header-anchor" href="#napi-is-date"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_date" target="_blank" rel="noopener noreferrer">napi_is_date</a></span></a></h3><p><code>napi_is_date</code> 是 Node.js 中的一个函数，这个函数属于 N-API（Node API），一个用来构建原生插件的接口。N-API 提供了一套与 JavaScript 运行时相关的 API，这些 API 允许你创建可以直接与 Node.js 交互的本地插件。</p><p>在 Node.js 中，JavaScript 可以使用 Date 对象来处理时间和日期。但是当我们在 C 或 C++ 的原生插件代码中工作时，需要一种方法来判断一个从 JavaScript 传递过来的值是否为一个 Date 对象。这就是 <code>napi_is_date</code> 函数的用途。</p><p>简单地说，<code>napi_is_date</code> 函数能够帮助你检查一个传入的 <code>napi_value</code>（这是一个代表 JavaScript 值的抽象类型）是否是一个 JavaScript Date 对象。</p><p>下面是如何使用 <code>napi_is_date</code> 函数的例子：</p><p>假设你正在编写一个原生模块，需要判断 JavaScript 传递的参数是否是一个 Date 对象：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将会被绑定到 JavaScript 中，并可从那里调用</span></span>
<span class="line"><span>napi_value IsDateExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    bool is_date;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取传递给该函数的 JavaScript 参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 判断第一个参数是否为 Date 类型</span></span>
<span class="line"><span>    status = napi_is_date(env, args[0], &amp;is_date);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将结果转换回 JavaScript 的布尔值并返回</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_boolean(env, is_date, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result; // 返回结果给 JavaScript 调用方</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化模块，注册 IsDateExample 函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的函数对象</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, IsDateExample, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将这个函数设置为导出的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;isDateExample&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 JavaScript 中，你可以像下面这样调用此函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> date</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> notADate</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isDateExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 应该输出：true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">isDateExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">notADate</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 应该输出：false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述的 C 代码示例中，函数 <code>IsDateExample</code> 会接收一个参数，然后利用 <code>napi_is_date</code> 来检查这个参数是否为一个 JavaScript 的 Date 对象。如果是，它会返回 <code>true</code>，否则返回 <code>false</code>。而在 JavaScript 代码中，我们通过加载这个原生模块来调用 <code>isDateExample</code> 方法，分别传入真正的 Date 对象以及一个普通对象，然后打印出结果。</p><h3 id="napi-is-error-2" tabindex="-1"><a class="header-anchor" href="#napi-is-error-2"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_error_1" target="_blank" rel="noopener noreferrer">napi_is_error</a></span></a></h3><p><code>napi_is_error</code> 是 Node.js 中的一个函数，它属于 N-API（Node API），这是一组用于构建原生插件的 C API。原生插件是用 C、C++等语言编写的模块，它们可以直接与 Node.js 的 V8 引擎交互，提供比 JavaScript 更高效的性能，或实现一些在纯 JavaScript 中不可能或困难的功能。</p><p>具体来说，<code>napi_is_error</code> 函数用于检查一个 <code>napi_value</code> 是否表示一个 JavaScript 错误对象。在 Node.js 中，JavaScript 错误对象通常用于捕获和处理运行时错误。</p><h3 id="参数解释" tabindex="-1"><a class="header-anchor" href="#参数解释"><span>参数解释</span></a></h3><ul><li><code>env</code>: 表示当前的 napi 环境，它是一个上下文对象，包含了当前正在运行的 Node.js 实例的信息。</li><li><code>value</code>: 是要检查的 <code>napi_value</code>，即你想知道它是否为一个错误对象的值。</li><li><code>result</code>: 这是一个指向布尔值的指针，函数将在这里设置结果。如果 <code>value</code> 是一个错误对象，则这个布尔值会被设置为 <code>true</code>；否则，它会被设置为 <code>false</code>。</li></ul><h3 id="使用场景举例-2" tabindex="-1"><a class="header-anchor" href="#使用场景举例-2"><span>使用场景举例</span></a></h3><p>假设你正在编写一个原生插件的功能，该功能调用了另一个可能会抛出错误的函数。在返回给 JavaScript 之前，你想检查结果是否是一个错误对象，并据此采取不同的行动。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设有一个函数可能会产生一个错误对象</span></span>
<span class="line"><span>napi_value SomeFunctionThatMayThrow(napi_env env) {</span></span>
<span class="line"><span>    // ... 一些操作可能会失败并返回错误对象</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 调用可能会抛出错误的函数</span></span>
<span class="line"><span>    napi_value result = SomeFunctionThatMayThrow(env);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查结果是否是一个错误对象</span></span>
<span class="line"><span>    bool is_error;</span></span>
<span class="line"><span>    napi_status status = napi_is_error(env, result, &amp;is_error);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status == napi_ok &amp;&amp; is_error) {</span></span>
<span class="line"><span>        // 如果是错误对象，处理错误情况</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果不是错误对象，继续正常逻辑</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们先定义了一个函数 <code>SomeFunctionThatMayThrow</code>，它在某些情况下可能会返回一个错误对象。然后，我们有了另一个函数 <code>MyNativeFunction</code>，它调用了 <code>SomeFunctionThatMayThrow</code> 并使用 <code>napi_is_error</code> 来检查返回的值是否是一个错误对象。根据检查结果，我们可以决定如何处理这种情况：如果是一个错误对象，我们可以采取适当的错误处理措施，否则，我们继续正常的逻辑处理。</p><p>需要注意的是，<code>napi_is_error</code> 本身也会返回一个状态码（<code>napi_status</code>），如果调用成功且未发生错误，则返回 <code>napi_ok</code>。所以在检查是否为错误对象之前，我们还应该检查 <code>napi_is_error</code> 调用自身是否成功。</p><h3 id="napi-is-typedarray" tabindex="-1"><a class="header-anchor" href="#napi-is-typedarray"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_typedarray" target="_blank" rel="noopener noreferrer">napi_is_typedarray</a></span></a></h3><p><code>napi_is_typedarray</code> 是 Node.js 中的一个函数，它属于 N-API（Node API），这是 Node.js 提供的一个用于构建原生插件的 API。N-API 是一个稳定且与 Node.js 版本无关的 C 级别的 API，使得开发者能够不用担心 Node.js 升级后导致的插件兼容性问题。</p><p>在解释 <code>napi_is_typedarray</code> 之前，我们先来了解一下什么是 TypedArray。TypedArray 是 JavaScript 中的一种特殊类型的数组，它提供了一种读写二进制数据缓冲区的机制。和普通的 JavaScript 数组不同，TypedArray 工作在 ArrayBuffer 上，并且其元素类型是固定的，比如 Int8Array, Uint8Array, Float32Array 等。</p><p>现在，让我们看看 <code>napi_is_typedarray</code>：</p><h3 id="napi-is-typedarray-1" tabindex="-1"><a class="header-anchor" href="#napi-is-typedarray-1"><span><code>napi_is_typedarray</code></span></a></h3><p>这个函数用来检查给定的 N-API 值是否为一个 TypedArray。如果是，这个函数会返回 <code>true</code>，否则返回 <code>false</code>。</p><h4 id="参数-2" tabindex="-1"><a class="header-anchor" href="#参数-2"><span>参数</span></a></h4><ol><li><code>env</code>: 这是当前执行环境的句柄，它提供了 Node.js 环境的上下文。</li><li><code>value</code>: 这是你想要检查的 N-API 值。</li><li><code>result</code>: 这是一个布尔值的指针，函数通过它返回检查结果。</li></ol><h4 id="返回值-4" tabindex="-1"><a class="header-anchor" href="#返回值-4"><span>返回值</span></a></h4><p>如果调用成功，该函数会返回 <code>napi_ok</code>，表示没有错误发生。因此，你需要检查<code>result</code>指向的布尔值来确定给定的值是否为 TypedArray。</p><h4 id="实际运用的例子-7" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-7"><span>实际运用的例子</span></a></h4><p>设想你正在编写一个 Node.js 的原生插件，这个插件需要处理图像或音频数据。你可能会从 JavaScript 代码接收一个数组，而你希望确认它是一个特定类型的 TypedArray，这样就可以以二进制形式直接读取数据，而不需要额外的类型转换。你可以使用 <code>napi_is_typedarray</code> 来检查这一点。</p><p>这里是一个虚构的例子代码片段，展示了如何在一个原生插件中使用 <code>napi_is_typedarray</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他必需的头文件和代码</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否只传递了一个参数并且这个参数是 TypedArray</span></span>
<span class="line"><span>    bool isTypedArray = false;</span></span>
<span class="line"><span>    napi_status status = napi_is_typedarray(env, args[0], &amp;isTypedArray);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok || !isTypedArray) {</span></span>
<span class="line"><span>        // 处理错误或抛出异常</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果是 TypedArray，执行后续的操作...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其他必需的代码来注册这个函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个名为 <code>MyNativeFunction</code> 的原生函数，它检查传递给它的第一个参数是否为 TypedArray。首先，我们使用 <code>napi_get_cb_info</code> 获取参数，然后调用 <code>napi_is_typedarray</code> 来进行检查。如果这个参数确实是 TypedArray，那么我们将继续执行所需的操作；如果不是，我们将处理错误或抛出异常。</p><p>总结起来，<code>napi_is_typedarray</code> 是 N-API 下用来检查一个值是否为 TypedArray 的工具函数，对于处理二进制数据的原生模块开发非常有用。</p><h3 id="napi-is-dataview" tabindex="-1"><a class="header-anchor" href="#napi-is-dataview"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_dataview" target="_blank" rel="noopener noreferrer">napi_is_dataview</a></span></a></h3><p><code>napi_is_dataview</code>是 Node.js 中一个 C API 的函数，这个 API 属于 N-API，是 Node.js 用来构建原生插件的一个接口。N-API 提供了一套与 JavaScript 引擎无关的 C 语言 API，让开发者能够创建可以在不同版本的 Node.js 中运行而不需要重新编译的原生插件。</p><p>在解释<code>napi_is_dataview</code>之前，我首先简单介绍一下 DataView。在 JavaScript 中，DataView 是一种用于操作二进制数据缓冲区（ArrayBuffer）内容的低级接口。它允许你在 ArrayBuffer 中读取和写入多种数值类型，无论它们的字节顺序是大端（big endian）还是小端（little endian）。</p><p>好了，接下来让我们看看<code>napi_is_dataview</code>：</p><h3 id="napi-is-dataview-1" tabindex="-1"><a class="header-anchor" href="#napi-is-dataview-1"><span><code>napi_is_dataview</code></span></a></h3><p>这个函数用来检查某个 N-API 值是否是一个 DataView 对象。其作用类似于 JavaScript 中的<code>instanceof</code>操作符，但是它是用在原生插件的 C 代码中。</p><h4 id="参数-3" tabindex="-1"><a class="header-anchor" href="#参数-3"><span>参数：</span></a></h4><ul><li><code>env</code>: 这是表示当前执行环境的<code>napi_env</code>。</li><li><code>value</code>: 要检查的 N-API 值。</li><li><code>result</code>: 一个指向布尔值的指针，用于存储检查结果：如果<code>value</code>是 DataView，则设为<code>true</code>；否则，设为<code>false</code>。</li></ul><h4 id="返回值-5" tabindex="-1"><a class="header-anchor" href="#返回值-5"><span>返回值：</span></a></h4><p>这个函数返回一个<code>napi_status</code>值，表示操作成功或失败的状态。如果函数调用成功，你可以检查<code>result</code>指向的值来确定传入的<code>value</code>是否为 DataView。</p><h4 id="例子-2" tabindex="-1"><a class="header-anchor" href="#例子-2"><span>例子</span></a></h4><p>假设你正在编写一个 Node.js 原生插件，并且你想确定从 JavaScript 传递给你的 N-API 函数的一个参数是否是一个 DataView。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是一个原生函数，将被JavaScript调用</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查第一个参数是否是DataView</span></span>
<span class="line"><span>  bool is_data_view;</span></span>
<span class="line"><span>  napi_is_dataview(env, args[0], &amp;is_data_view);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (is_data_view) {</span></span>
<span class="line"><span>    // 参数是DataView，处理DataView逻辑...</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    // 参数不是DataView，可能抛出错误或者进行其他处理...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...函数的其他逻辑...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  // 假设创建一个返回值</span></span>
<span class="line"><span>  napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>MyFunction</code>是一个原生函数，它期望接收一个 DataView 作为参数。我们使用<code>napi_get_cb_info</code>取得传递给函数的参数，然后使用<code>napi_is_dataview</code>来检查这个参数是否确实是一个 DataView。根据检查结果，我们可以决定如何处理这个参数。</p><p>记得在实际代码中，你应该总是检查<code>napi_is_dataview</code>的返回值以确定操作是否成功，并相应地处理错误情况。</p><h3 id="napi-strict-equals" tabindex="-1"><a class="header-anchor" href="#napi-strict-equals"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_strict_equals" target="_blank" rel="noopener noreferrer">napi_strict_equals</a></span></a></h3><p>Node.js 中的 <code>napi_strict_equals</code> 是一个函数，它属于 N-API（Node.js API）的一部分。N-API 是 Node.js 提供的用于构建原生插件的一套稳定的 C API。原生插件是指用 C 或 C++ 写的模块，它们可以被 JavaScript 代码直接调用。这些功能对于提升性能和/或使 Node.js 能够访问操作系统级别的功能非常有用。</p><p>现在，来具体看看 <code>napi_strict_equals</code> 这个函数。如名称所示，该函数用于比较两个 JavaScript 值是否严格相等，这意味着它不会进行类型转换。在 JavaScript 中，使用 <code>===</code> 操作符可以执行严格相等性检查。而 <code>napi_strict_equals</code> 则是这种操作的 C 层面的等效实现。</p><p>为什么我们需要这样的函数？当你编写原生模块时，可能需要判断 JavaScript 传入的参数是否与某个特定值完全相同。由于你在 C 或 C++ 的环境中工作，所以不能直接使用 JavaScript 的 <code>===</code>。这时候，<code>napi_strict_equals</code> 就成了判断这种严格相等性的工具。</p><p>下面是一个简化的例子来展示 <code>napi_strict_equals</code> 的基本用法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设有一个函数叫做 &quot;StrictEquals&quot; 绑定到了 JS</span></span>
<span class="line"><span>napi_value StrictEquals(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 获取函数参数</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数数量是否正确</span></span>
<span class="line"><span>    if (argc `&lt;` 2) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Function expects two arguments.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用 napi_strict_equals 比较两个参数是否严格相等</span></span>
<span class="line"><span>    bool result;</span></span>
<span class="line"><span>    napi_strict_equals(env, args[0], args[1], &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 把结果转换为 JavaScript 的布尔值返回给 JS</span></span>
<span class="line"><span>    napi_value jsResult;</span></span>
<span class="line"><span>    napi_get_boolean(env, result, &amp;jsResult);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return jsResult;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Initialize(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // ... 初始化代码，并把上面的函数绑定给 JS 调用 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个名为 <code>StrictEquals</code> 的函数，它接受两个参数，并使用 <code>napi_strict_equals</code> 来判断它们是否严格相同。函数的结果是一个布尔值，表示两个参数是否相等。</p><p>在 JavaScript 端，你可以像这样使用这个函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-module.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">StrictEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出 true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">StrictEquals</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出 false，因为类型不同</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的 JavaScript 代码中，我们通过 <code>require</code> 引入了 C/C++ 编写并编译好的原生模块，然后使用 <code>.StrictEquals</code> 函数来进行严格比较操作。</p><p>总结一下，<code>napi_strict_equals</code> 在 Node.js 原生模块开发中使用，它提供了一个在原生代码中执行严格相等性比较的能力。通过这种方式，你可以在扩展 Node.js 功能时对 JavaScript 值进行更精确的操作。</p><h3 id="napi-detach-arraybuffer" tabindex="-1"><a class="header-anchor" href="#napi-detach-arraybuffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_detach_arraybuffer" target="_blank" rel="noopener noreferrer">napi_detach_arraybuffer</a></span></a></h3><p><code>napi_detach_arraybuffer</code> 是 Node.js 中的一个 N-API 函数，它用于管理 JavaScript ArrayBuffer 对象与其底层的二进制数据之间的关联。在解释这个函数之前，我会先简单介绍一些相关概念。</p><h3 id="arraybuffer-简介" tabindex="-1"><a class="header-anchor" href="#arraybuffer-简介"><span>ArrayBuffer 简介</span></a></h3><p><code>ArrayBuffer</code> 是 JavaScript 中的一种数据类型，它表示一块固定大小的原始二进制数据缓冲区。你可以通过 Typed Arrays 或 DataView 来读写 ArrayBuffer 中的数据。这对于处理如文件数据、网络通信等需要高效操作二进制数据的场景特别有用。</p><h3 id="n-api-简介" tabindex="-1"><a class="header-anchor" href="#n-api-简介"><span>N-API 简介</span></a></h3><p>N-API 是 Node.js 提供的一组 C API，允许本地插件（用 C 或 C++编写的模块）与 JavaScript 代码无缝交互，同时保持与 Node.js 版本的向后兼容性。本地插件可以利用 N-API 创建和操作 JavaScript 值，并通过它们扩展 Node.js 的功能。</p><h3 id="napi-detach-arraybuffer-1" tabindex="-1"><a class="header-anchor" href="#napi-detach-arraybuffer-1"><span>napi_detach_arraybuffer</span></a></h3><p>当我们在本地插件中使用 <code>ArrayBuffer</code> 时，可能会出现一种情况：我们希望把 ArrayBuffer 中的数据「分离」出来。也就是说，让 ArrayBuffer 不再引用那部分内存。这样，JavaScript 的垃圾回收机制就不会管理那部分内存了，而是留给我们自己管理。</p><p>在这种情况下，就可以使用 <code>napi_detach_arraybuffer</code> 函数。这个函数将 ArrayBuffer 对象标记为 &quot;detached&quot; 状态，即该 ArrayBuffer 不再指向任何的数据。这样做的一个常见理由是为了避免数据的重复拷贝，提升性能：我们可能先通过 JavaScript 创建了一个 ArrayBuffer，然后传递到本地插件进行填充；填充完毕后，为了让其他原生库直接操作这块内存，我们就会将其分离。</p><h3 id="实际例子-7" tabindex="-1"><a class="header-anchor" href="#实际例子-7"><span>实际例子</span></a></h3><p>假设你在开发一个图像处理的 Node.js 插件。用户将通过 JavaScript 创建一个 ArrayBuffer，期望你的插件将图像数据填充进去。一旦你完成了填充，你可能想要调用一个专门的图像处理库，它并不知道 JavaScript 的存在，只会处理纯粹的内存数据。</p><p>以下是一个简化的代码流程：</p><ol><li>用户在 JS 侧创建 ArrayBuffer。</li><li>用户调用插件的方法，将 ArrayBuffer 传入。</li><li>插件接收 ArrayBuffer，并使用 <code>napi_create_external_arraybuffer</code> 或其他方法来关联本地数据。</li><li>插件执行操作，比如填充图像数据。</li><li>插件调用 <code>napi_detach_arraybuffer</code> 来分离 ArrayBuffer，这样图像处理库就可以安全地处理这块内存了。</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设此函数由图像处理库提供，用于处理内存中的图像数据</span></span>
<span class="line"><span>void process_image_data(void* data, size_t length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value DetachArrayBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 分离 ArrayBuffer</span></span>
<span class="line"><span>    napi_detach_arraybuffer(env, args[0]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 ArrayBuffer 的数据指针</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span>    size_t length;</span></span>
<span class="line"><span>    napi_get_arraybuffer_info(env, args[0], &amp;data, &amp;length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用图像处理函数</span></span>
<span class="line"><span>    process_image_data(data, length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 其余插件初始化代码 ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这里的例子非常简化，实际使用中还需要进行错误检查和资源管理等工作。但它展示了 <code>napi_detach_arraybuffer</code> 在实践中是如何被用来优化性能和与本地库交互的。</p><h3 id="napi-is-detached-arraybuffer" tabindex="-1"><a class="header-anchor" href="#napi-is-detached-arraybuffer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_detached_arraybuffer" target="_blank" rel="noopener noreferrer">napi_is_detached_arraybuffer</a></span></a></h3><p><code>napi_is_detached_arraybuffer</code> 是 Node.js 中 N-API (Native API) 的一部分，它是一个函数，让你可以检查一个 <code>ArrayBuffer</code> 是否已经被 &quot;detach&quot;（分离）。在 JavaScript 中，<code>ArrayBuffer</code> 是一种用来表示一块原始二进制数据的方法；你可以想象成它就像是一个可以存储字节的容器。</p><p>在某些情况下，特别是在与 WebAssembly 或者其他底层操作打交道时，可能会需要 &quot;detach&quot; 一个 ArrayBuffer。&quot;detach&quot; 操作基本上是指使这个 ArrayBuffer 的内容变得不可访问，这样做的一个原因可能是为了释放内存或者防止后续的 JavaScript 代码错误地使用了这段内存。</p><p>现在，让我们通过几个简单的例子来理解 <code>napi_is_detached_arraybuffer</code> 函数的作用。</p><h3 id="实际运用的例子-8" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-8"><span>实际运用的例子</span></a></h3><p><strong>注意：</strong> 下面的代码是在 Node.js 的 C/C++ 插件中使用的，而非纯 JavaScript 环境。</p><ol><li><strong>检查 ArrayBuffer 是否已经 Detach</strong></li></ol><p>假设你正在编写一个 Node.js 的扩展模块，你有一个从 JavaScript 传递过来的 <code>ArrayBuffer</code> 对象，你想检查它是否已经被 detach。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将被暴露给 JavaScript，用于检查 ArrayBuffer 是否 detach</span></span>
<span class="line"><span>napi_value IsDetached(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查参数数量是否正确</span></span>
<span class="line"><span>    if (argc `&lt;` 1) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Function expects an ArrayBuffer.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value arrayBuffer = args[0];</span></span>
<span class="line"><span>    bool is_detached = false;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用 napi_is_detached_arraybuffer 来检查 ArrayBuffer 是否 detach</span></span>
<span class="line"><span>    napi_status status = napi_is_detached_arraybuffer(env, arrayBuffer, &amp;is_detached);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Failed to check if ArrayBuffer is detached.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_boolean(env, is_detached, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们定义了一个 <code>IsDetached</code> 函数，这个函数可以被 JavaScript 调用，并且它接受一个 <code>ArrayBuffer</code> 参数，然后使用 <code>napi_is_detached_arraybuffer</code> 检查该 <code>ArrayBuffer</code> 是否已经被 detach。函数返回一个布尔值，告诉调用者 <code>ArrayBuffer</code> 是否 detach。</p><ol start="2"><li><strong>在实际操作前确认 ArrayBuffer 的状态</strong></li></ol><p>在处理 <code>ArrayBuffer</code> 进行内存操作之前，先确认它没有被 detach 是一个好习惯，可以避免潜在的错误：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设你有一个用于处理 ArrayBuffer 数据的函数</span></span>
<span class="line"><span>void ProcessArrayBufferData(napi_env env, napi_value arrayBuffer) {</span></span>
<span class="line"><span>    bool is_detached = false;</span></span>
<span class="line"><span>    napi_is_detached_arraybuffer(env, arrayBuffer, &amp;is_detached);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (is_detached) {</span></span>
<span class="line"><span>        // 如果 ArrayBuffer 已经被 detach，则不进行操作</span></span>
<span class="line"><span>        // 可以抛出错误或者直接退出</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;The ArrayBuffer is detached and cannot be used.&quot;);</span></span>
<span class="line"><span>        return;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 正常处理 ArrayBuffer 数据...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们在对 <code>ArrayBuffer</code> 进行任何处理之前，先使用 <code>napi_is_detached_arraybuffer</code> 函数检查它的状态。如果发现已经 detach，就不再进行后续操作，以此来保证程序的安全性和稳定性。</p><p>希望这些例子能够帮助你理解 <code>napi_is_detached_arraybuffer</code> 在 Node.js N-API 中的使用和重要性。在编写涉及原始二进制数据操作的扩展模块时，正确检查 <code>ArrayBuffer</code> 的状态是非常关键的。</p><h2 id="working-with-javascript-properties" tabindex="-1"><a class="header-anchor" href="#working-with-javascript-properties"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#working-with-javascript-properties" target="_blank" rel="noopener noreferrer">Working with JavaScript properties</a></span></a></h2><p>当我们在 Node.js 中使用 N-API（Node.js 的原生 API 接口）与 JavaScript 属性打交道时，我们主要关注几个方面：创建属性、获取属性值、设置属性值以及操作对象的属性。我会用简单的例子来解释这些概念。</p><h3 id="创建属性" tabindex="-1"><a class="header-anchor" href="#创建属性"><span>创建属性</span></a></h3><p>在 JavaScript 中，你可以直接为对象添加新属性。例如：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myProperty</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在使用 N-API 的 C/C++ 插件中，你需要通过特定的函数来实现类似的功能。以下是一个如何在 N-API 中创建属性的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value my_property_name;</span></span>
<span class="line"><span>napi_value my_property_value;</span></span>
<span class="line"><span>napi_value object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 和 object 已经被正确初始化。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个 JavaScript 字符串作为属性名。</span></span>
<span class="line"><span>status = napi_create_string_utf8(env, &quot;myProperty&quot;, NAPI_AUTO_LENGTH, &amp;my_property_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个 JavaScript 数字作为属性值。</span></span>
<span class="line"><span>status = napi_create_double(env, 123, &amp;my_property_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将创建的属性和值添加到对象上。</span></span>
<span class="line"><span>status = napi_set_property(env, object, my_property_name, my_property_value);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="获取属性值" tabindex="-1"><a class="header-anchor" href="#获取属性值"><span>获取属性值</span></a></h3><p>在 JavaScript 中，要获取对象属性的值非常直接，就像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: 123</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 N-API 中，获取属性也需要调用特定的函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value my_property_value;</span></span>
<span class="line"><span>napi_value object;</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 和 object 已经被正确初始化，并且object上有myProperty属性。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取 myProperty 属性的值。</span></span>
<span class="line"><span>status = napi_get_named_property(env, object, &quot;myProperty&quot;, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设属性值是一个数字，转换结果并输出。</span></span>
<span class="line"><span>double value;</span></span>
<span class="line"><span>status = napi_get_value_double(env, result, &amp;value);</span></span>
<span class="line"><span>printf(&quot;The property value is: %f\n&quot;, value); // 输出将类似于: The property value is: 123.000000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="设置属性值" tabindex="-1"><a class="header-anchor" href="#设置属性值"><span>设置属性值</span></a></h3><p>在 JavaScript 中修改属性值同样很简单：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myProperty</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 456</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 修改属性值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用 N-API 时，我们可以如下设置属性值：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value my_property_value;</span></span>
<span class="line"><span>napi_value object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 和 object 已经被正确初始化，并且object上有myProperty属性。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个新的 JavaScript 数字作为新的属性值。</span></span>
<span class="line"><span>status = napi_create_double(env, 456, &amp;my_property_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 更新属性值。</span></span>
<span class="line"><span>status = napi_set_named_property(env, object, &quot;myProperty&quot;, my_property_value);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="操作对象的属性" tabindex="-1"><a class="header-anchor" href="#操作对象的属性"><span>操作对象的属性</span></a></h3><p>在 JavaScript 中，你可以使用 <code>delete</code> 来删除属性，或者使用 <code>Object.keys()</code> 来列出对象的所有属性等。对于 N-API，我们同样有函数来处理这些操作。</p><p>删除属性的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value object;</span></span>
<span class="line"><span>bool result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 和 object 已经被正确初始化，并且object上有myProperty属性。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 删除该属性。</span></span>
<span class="line"><span>status = napi_delete_property(env, object, &quot;myProperty&quot;, &amp;result);</span></span>
<span class="line"><span>// result 现在为 true 表示删除成功。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 Node.js 中 N-API 处理 JavaScript 属性的基础知识和一些简单例子。这些例子展示了如何在编写 C/C++ 插件时与 JavaScript 对象的属性进行交互。记得在实际的应用中，每次调用后都需要检查 <code>napi_status</code> 的返回值，确保操作成功。</p><h3 id="structures" tabindex="-1"><a class="header-anchor" href="#structures"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#structures" target="_blank" rel="noopener noreferrer">Structures</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行环境，使得开发者可以用 JavaScript 来编写后端代码。而 N-API（Node.js API）则是 Node.js 提供的一个用来构建本地插件的 API。</p><p>在理解 Node.js 的 N-API 文档中的 &quot;Structures&quot; 一节时，我们需要知道 &quot;Structures&quot; 在这里指的是 C 语言中的结构体（structs）。结构体是一种用户自定义的数据类型，允许你将多个不同的数据项组合成单个复合数据类型。在 N-API 中，这些结构体被用作和 JavaScript 运行时交互的接口。</p><p>下面是对 &quot;Structures&quot; 部分内容的简要解释和实际应用例子：</p><ol><li><code>napi_property_descriptor</code>：<br> 这是一个结构，在创建或定义对象的属性时使用。例如，如果你想向一个 JavaScript 对象添加一个新的属性或方法，你就会使用这个结构体。</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 定义一个 napi_property_descriptor</span></span>
<span class="line"><span>napi_property_descriptor desc = {</span></span>
<span class="line"><span>    &quot;myProperty&quot;,  // 属性名</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    MyPropertyGetter,  // getter 函数</span></span>
<span class="line"><span>    MyPropertySetter,  // setter 函数</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    napi_default,</span></span>
<span class="line"><span>    NULL</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>MyPropertyGetter</code> 和 <code>MyPropertySetter</code> 是 C 函数，当从 JavaScript 访问或修改 <code>myProperty</code>属性时会调用它们。</p><ol start="2"><li><p><code>napi_callback_info</code>：<br> 当一个原生函数（即由 C/C++ 编写的函数）被 JavaScript 代码调用时，<code>napi_callback_info</code> 结构会包含调用的上下文信息，比如传递给函数的参数等。</p></li><li><p><code>napi_ref</code>：<br> 这个结构代表了一个对 JavaScript 对象的强引用。如果你有一个 JavaScript 对象，并且你不希望它在某个时候被垃圾回收器回收，可以使用 <code>napi_ref</code> 来确保对象保持活跃。</p></li><li><p><code>napi_value</code>：<br> 表示一个 ECMAScript（JavaScript 的规范）值。无论何时你需要从 C/C++ 代码与 JavaScript 更基本的数据类型（如字符串、数字、对象等）进行交云，都会用到 <code>napi_value</code>。</p></li></ol><p>例如，假设我们正在编写一个 Node.js 插件，该插件提供了一个名为 <code>addNumbers</code> 的函数，用于计算两个数的和：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原生 addNumbers 函数</span></span>
<span class="line"><span>napi_value AddNumbers(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span>    double value1, value2;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取 JavaScript 调用提供的参数</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保没有出错并且接受了两个参数</span></span>
<span class="line"><span>    if (status == napi_ok &amp;&amp; argc == 2) {</span></span>
<span class="line"><span>        // 将 napi_values （JavaScript 值）转换为 C 类型的 double</span></span>
<span class="line"><span>        status = napi_get_value_double(env, args[0], &amp;value1);</span></span>
<span class="line"><span>        status = napi_get_value_double(env, args[1], &amp;value2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 计算两数之和</span></span>
<span class="line"><span>        double sum = value1 + value2;</span></span>
<span class="line"><span>        napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 将 C 类型的和转换回 napi_value</span></span>
<span class="line"><span>        status = napi_create_double(env, sum, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 返回结果给 JavaScript</span></span>
<span class="line"><span>        return result;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果出现错误，返回 undefined</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个表示 addNumbers 函数的 napi_value</span></span>
<span class="line"><span>    status = napi_create_function(env, NULL, 0, AddNumbers, NULL, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 把 addNumbers 函数作为模块导出的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;addNumbers&quot;, fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先定义了一个 <code>AddNumbers</code> 函数，它使用 <code>napi_get_cb_info</code> 来获取 JavaScript 传递的参数，并使用 <code>napi_create_double</code> 和 <code>napi_get_value_double</code> 来在 JavaScript 的数值和 C 的数值之间进行转换。最后，我们通过 <code>napi_create_function</code> 创建函数并通过 <code>napi_set_named_property</code> 把它绑定到模块的导出对象上。</p><p>这样，当 JavaScript 代码通过 <code>require</code> 导入这个模块后，就能够调用 <code>addNumbers</code> 函数，并且在底层执行我们的 C 代码进行加法运算了。</p><h4 id="napi-property-attributes" tabindex="-1"><a class="header-anchor" href="#napi-property-attributes"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_property_attributes" target="_blank" rel="noopener noreferrer">napi_property_attributes</a></span></a></h4><p>Node.js 中的 N-API 是一个用于构建本机插件（native addons）的底层接口，这些本机插件是使用 C/C++编写的，用来直接与 Node.js 的 V8 引擎进行交互。<code>napi_property_attributes</code>是 N-API 中定义属性特性的枚举类型，用于设置 JavaScript 对象属性的一些特征。</p><p>在 JavaScript 中，对象的属性可以具有几个特征，比如它们是否可写（writable）、是否可枚举（enumerable）、是否可配置（configurable）。理解这些特征对于创建行为像普通 JavaScript 对象属性的本机插件非常重要。</p><p><code>napi_property_attributes</code>枚举中包含以下值：</p><ul><li><code>napi_default</code>: 这是默认选项，等同于 JavaScript 中普通属性的默认行为，即属性是可写、可枚举、可配置的。</li><li><code>napi_readonly</code>: 设置该属性标志后，属性将不可写，也就是说你不能更改属性的值。</li><li><code>napi_dont_enum</code>: 设置该属性标志后，属性在对象的枚举属性列表中不会出现，也就是说它不会出现在<code>for...in</code>循环或<code>Object.keys()</code>的输出中。</li><li><code>napi_fixed</code>: 相当于同时设置了<code>napi_readonly</code>和<code>napi_dont_delete</code>，使属性既不可写也不可删除。</li><li><code>napi_static</code>: 表示属性是静态的。</li></ul><p>让我们看看如何在实际中使用这些属性：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个简单的函数，返回一个字符串</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value greeting;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;Hello World&quot;, NAPI_AUTO_LENGTH, &amp;greeting);</span></span>
<span class="line"><span>    return greeting;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，在模块加载时调用</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 定义一个新的函数属性</span></span>
<span class="line"><span>    napi_property_descriptor desc = {</span></span>
<span class="line"><span>        &quot;myFunction&quot;,             // 属性名称</span></span>
<span class="line"><span>        NULL,                     // 属性的唯一标识符（Symbol），这里没有使用</span></span>
<span class="line"><span>        MyFunction,               // 指向上面定义的函数的指针</span></span>
<span class="line"><span>        NULL,                     // getter 函数，这里不需要</span></span>
<span class="line"><span>        NULL,                     // setter 函数，这里不需要</span></span>
<span class="line"><span>        NULL,                     // value, 因为已经指定了方法，所以不需要设置值</span></span>
<span class="line"><span>        napi_default,             // 设置属性特性为默认</span></span>
<span class="line"><span>        NULL                      // 任何与属性相关的数据</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在exports对象上定义属性</span></span>
<span class="line"><span>    napi_define_properties(env, exports, 1, &amp;desc);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个简单的本机插件，它暴露了一个函数<code>myFunction</code>。当你在 JavaScript 中调用这个函数时，它将返回字符串&quot;Hello World&quot;。</p><p>我们使用<code>napi_define_properties</code>函数来把<code>myFunction</code>添加到模块的导出对象上，并且我们设置了属性特性为<code>napi_default</code>，这意味着在 JavaScript 代码中，这个函数是可写的、可枚举的、可配置的。</p><p>如果我们想让这个函数成为只读的，我们就可以在<code>napi_property_descriptor</code>结构体中将<code>napi_default</code>改为<code>napi_readonly</code>：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_property_descriptor desc = {</span></span>
<span class="line"><span>    &quot;myFunction&quot;,</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    MyFunction,</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    NULL,</span></span>
<span class="line"><span>    napi_readonly,  // 设置属性特性为只读</span></span>
<span class="line"><span>    NULL</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样设置之后，在 JavaScript 代码中尝试修改<code>myFunction</code>属性将会失败。</p><h4 id="napi-property-descriptor" tabindex="-1"><a class="header-anchor" href="#napi-property-descriptor"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_property_descriptor" target="_blank" rel="noopener noreferrer">napi_property_descriptor</a></span></a></h4><p><code>napi_property_descriptor</code> 是 Node.js 中 N-API 的一部分，N-API 是一个用于构建原生插件的 API 层。原生插件是用 C 或者 C++ 写的模块，它们可以直接调用系统级别的 API，通常用于提高性能或者访问一些 JavaScript 没有直接支持的低层功能。</p><p>在介绍 <code>napi_property_descriptor</code> 之前，需要明白原生插件中经常需要和 JavaScript 对象交互。JavaScript 对象由属性组成，这些属性可以是值（如字符串、数字等），也可以是函数。<code>napi_property_descriptor</code> 就是用来定义一个属性及其特性的结构体（C 结构体），当你想要在原生代码中创建新的 JavaScript 对象或者给对象添加属性时会用到它。</p><p><code>napi_property_descriptor</code> 包含以下字段：</p><ul><li><code>utf8name</code>: 这是一个指向字符数组的指针，代表属性的名字。</li><li><code>name</code>: 一个 <code>napi_value</code> 类型，表示属性的名称，用于安全地处理可能包含非 ASCII 字符的属性名。</li><li><code>method</code>: 如果这个属性是一个函数的话，<code>method</code> 是一个指向该函数原生实现的指针。</li><li><code>getter</code>: 如果这个属性是通过 getter 函数获得的，<code>getter</code> 就是指向该 getter 函数的指针。</li><li><code>setter</code>: 如果这个属性可以被设置，并且有 setter 函数，<code>setter</code> 就是指向该 setter 函数的指针。</li><li><code>value</code>: 如果这个属性是一个简单的值，那么 <code>value</code> 就会包含这个值的 <code>napi_value</code> 表示。</li><li><code>attributes</code>: 这是一个位掩码，用来定义属性的特性，比如是否可写 (<code>napi_writable</code>)，是否可枚举 (<code>napi_enumerable</code>)，是否可配置 (<code>napi_configurable</code>) 等。</li><li><code>data</code>: 这是一个指向任意数据的指针，通常用于与属性相关联的数据。</li></ul><p>现在，我们通过一个简单的例子来看看如何使用 <code>napi_property_descriptor</code>：</p><p>假设我们正在编写一个原生插件，我们希望暴露一个 JavaScript 对象给 Node.js，这个对象有一个叫做 <code>version</code> 的只读属性和一个叫做 <code>sayHello</code> 的方法。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将会成为 sayHello 方法的原生实现</span></span>
<span class="line"><span>napi_value SayHelloMethod(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建一个 JS 字符串 &quot;Hello, world!&quot;</span></span>
<span class="line"><span>    napi_value greeting;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;Hello, world!&quot;, NAPI_AUTO_LENGTH, &amp;greeting);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return greeting; // 返回这个字符串</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Getter 函数用于获取 version 属性</span></span>
<span class="line"><span>napi_value GetVersionValue(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value version_value;</span></span>
<span class="line"><span>    napi_create_double(env, 1.0, &amp;version_value); // 假设版本号是 1.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return version_value; // 返回版本号</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，这个函数会在模块加载时被调用</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 定义 sayHello 属性</span></span>
<span class="line"><span>    napi_property_descriptor say_hello_desc = {</span></span>
<span class="line"><span>        .utf8name = &quot;sayHello&quot;,</span></span>
<span class="line"><span>        .method = SayHelloMethod,</span></span>
<span class="line"><span>        .attributes = napi_default</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 定义 version 属性</span></span>
<span class="line"><span>    napi_property_descriptor version_desc = {</span></span>
<span class="line"><span>        .utf8name = &quot;version&quot;,</span></span>
<span class="line"><span>        .getter = GetVersionValue,</span></span>
<span class="line"><span>        .attributes = napi_default | napi_read_only</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 给 exports 对象添加 sayHello 和 version 属性</span></span>
<span class="line"><span>    napi_define_properties(env, exports, 1, &amp;say_hello_desc);</span></span>
<span class="line"><span>    napi_define_properties(env, exports, 1, &amp;version_desc);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们创建了两个 <code>napi_property_descriptor</code>：<code>say_hello_desc</code> 和 <code>version_desc</code>，然后分别通过 <code>napi_define_properties</code> 把它们添加到导出的对象上。当 JavaScript 代码 <code>require</code> 这个原生模块时，就可以直接调用 <code>sayHello()</code> 方法和访问 <code>version</code> 属性了。</p><p>这就是 <code>napi_property_descriptor</code> 在 Node.js N-API 中的基本用法。通过这种方式，你可以构建丰富的原生插件，并把它们无缝集成到 Node.js 应用程序中。</p><h3 id="functions" tabindex="-1"><a class="header-anchor" href="#functions"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#functions" target="_blank" rel="noopener noreferrer">Functions</a></span></a></h3><p>Node.js 中的 N-API（Node.js API）是一个用 C 语言编写的接口，它允许你创建可以直接与 Node.js 的运行时交互的本地插件。这意味着你可以用像 C 或 C++这样的低级语言编写性能敏感的代码，并且可以在 Node.js 中作为模块调用。</p><p>在 Node.js v21.7.1 版本的文档中，“Functions”部分指的是 N-API 提供的一系列函数，这些函数允许开发者在本地插件中执行各种操作，比如创建对象、调用 JavaScript 函数、处理异常等。</p><p>我会用几个例子来解释这一点：</p><h3 id="_1-创建原生对象" tabindex="-1"><a class="header-anchor" href="#_1-创建原生对象"><span>1. 创建原生对象</span></a></h3><p>假设你想要在本地插件中创建一个新的 JavaScript 对象，并将其返回给 Node.js 的环境。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value myObject;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个空对象。</span></span>
<span class="line"><span>  status = napi_create_object(env, &amp;myObject);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return myObject;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数，使其可以从Node.js调用。</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个新函数。</span></span>
<span class="line"><span>  status = napi_create_function(env, NULL, 0, CreateObject, NULL, &amp;fn);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 设置导出的函数为 &quot;CreateObject&quot;</span></span>
<span class="line"><span>  status = napi_set_named_property(env, exports, &quot;CreateObject&quot;, fn);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-调用-javascript-函数" tabindex="-1"><a class="header-anchor" href="#_2-调用-javascript-函数"><span>2. 调用 JavaScript 函数</span></a></h3><p>如果你的本地插件接收到了一个 JavaScript 函数作为参数，并希望在本地代码中调用它。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CallJsFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  size_t argc = 1;</span></span>
<span class="line"><span>  napi_value args[1];</span></span>
<span class="line"><span>  napi_value global, jsFunction, result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取JavaScript传递的参数。</span></span>
<span class="line"><span>  status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 确保我们得到一个函数。</span></span>
<span class="line"><span>  napi_valuetype valuetype;</span></span>
<span class="line"><span>  status = napi_typeof(env, args[0], &amp;valuetype);</span></span>
<span class="line"><span>  if (status != napi_ok || valuetype != napi_function) {</span></span>
<span class="line"><span>    // 抛出错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  jsFunction = args[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取全局对象。</span></span>
<span class="line"><span>  status = napi_get_global(env, &amp;global);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用JavaScript函数，没有参数和返回值。</span></span>
<span class="line"><span>  status = napi_call_function(env, global, jsFunction, 0, NULL, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些示例展示了如何使用 N-API 提供的函数来创建对象和调用函数。当然，N-API 提供的功能远不止这些，但是上面提供了一个基本的了解。</p><p>这些概念可能对于编程新手来说有点复杂，因为它们涉及了跨越 JavaScript 和 C/C++两种不同编程语言界限的编程理念。如果你刚开始学习编程，并且专注于 JavaScript，你可能不需要立即深入了解 N-API。这更多是为需要高性能计算和对 Node.js 运行时有特别需求的高级用户提供的功能。</p><h4 id="napi-get-property-names" tabindex="-1"><a class="header-anchor" href="#napi-get-property-names"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_property_names" target="_blank" rel="noopener noreferrer">napi_get_property_names</a></span></a></h4><p><code>napi_get_property_names</code> 是 Node.js 中的一个 N-API 函数，这是一个用于创建本地插件的 API。简单来说，N-API 允许你用 C 或者 C++编写代码，这些代码可以直接与 Node.js 的 JavaScript 引擎 V8 交互。</p><p>现在来解释一下<code>napi_get_property_names</code>的作用。当你在 JavaScript 对象上使用这个函数时，它会返回那个 JavaScript 对象的所有可枚举属性名称的列表。所谓“可枚举”的属性，指的是那些可以通过常规循环如<code>for...in</code>来访问的属性。</p><p>在 C 或 C++中使用<code>napi_get_property_names</code>的伪代码大致如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value object; // 假设这是你想要获取其属性的JS对象</span></span>
<span class="line"><span>napi_value property_names_array;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用napi_get_property_names来获取属性数组</span></span>
<span class="line"><span>status = napi_get_property_names(env, object, &amp;property_names_array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 检查是否调用成功</span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  // 使用property_names_array</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>  // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际应用例子：</p><p>假设你正在编写一个 Node.js 本地插件，你需要分析一个从 JavaScript 传来的配置对象，这个对象可能是这样的：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">  host</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;localhost&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">  port</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">8080</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">  username</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;admin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#E06C75;">  password</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;passwd&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你想在你的 C/C++插件中找出所有的配置项。你可以使用<code>napi_get_property_names</code>这样做：</p><ol><li>当 JavaScript 调用你的本地插件时，它会传递上述配置对象。</li><li>在你的插件代码中，你使用<code>napi_get_property_names</code>获取这个对象的所有属性名称。</li><li>然后，你可以遍历返回的属性名称数组，并对每个属性进行操作，例如读取值、进行校验等。</li></ol><p>这种方式可以帮助你的 C/C++代码更方便地了解和操作 JavaScript 传入的对象，使得本地插件能够更紧密地与 JavaScript 代码集成。</p><h4 id="napi-get-all-property-names" tabindex="-1"><a class="header-anchor" href="#napi-get-all-property-names"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_all_property_names" target="_blank" rel="noopener noreferrer">napi_get_all_property_names</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它允许你在服务器端运行 JavaScript 代码。N-API 是 Node.js 的一个 C API 层，它提供了构建原生插件的接口，让开发者可以不用直接使用底层的 V8 API。</p><p><code>napi_get_all_property_names</code> 是 N-API 中的一个函数，用于获取 JavaScript 对象上的所有属性名称（包括自身的和继承的属性）。这个函数是为了使得原生模块的开发者能够从 C/C++ 代码中检索出 JavaScript 对象的属性名列表。</p><h3 id="函数签名-4" tabindex="-1"><a class="header-anchor" href="#函数签名-4"><span>函数签名</span></a></h3><p>函数的签名如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_all_property_names(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    napi_value object,</span></span>
<span class="line"><span>    napi_key_collection_mode key_mode,</span></span>
<span class="line"><span>    napi_key_filter key_filter,</span></span>
<span class="line"><span>    napi_key_conversion key_conversion,</span></span>
<span class="line"><span>    napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 当前调用的环境。</li><li><code>object</code>: 要检索属性的 JavaScript 对象。</li><li><code>key_mode</code>: 指定要返回哪些类型的键，例如只返回自有属性或还包括原型链上的属性。</li><li><code>key_filter</code>: 用于过滤键的条件，例如是否排除不可枚举的属性。</li><li><code>key_conversion</code>: 键的转换方式，比如返回字符串形式还是符号。</li><li><code>result</code>: 返回找到的属性名称数组。</li></ul><h3 id="参数解释-1" tabindex="-1"><a class="header-anchor" href="#参数解释-1"><span>参数解释</span></a></h3><p><code>key_mode</code>, <code>key_filter</code>, 和 <code>key_conversion</code> 是特殊的枚举值，分别用来指明：</p><ul><li><strong>key_mode</strong>: 应该检索对象自己的属性 (<code>napi_key_own</code>), 还是连同原型链上的属性一起 (<code>napi_key_include_prototypes</code>).</li><li><strong>key_filter</strong>: 定义了哪些属性将被包括在内 —— 可枚举的（<code>napi_key_enumerable</code>）、可配置的（<code>napi_key_configurable</code>）、可写的（<code>napi_key_writable</code>）等。</li><li><strong>key_conversion</strong>: 通常设置为 <code>napi_key_keep_numbers</code> 表示保持数字属性作为数字类型，而不是转换成字符串。</li></ul><h3 id="实际应用示例" tabindex="-1"><a class="header-anchor" href="#实际应用示例"><span>实际应用示例</span></a></h3><p>假设你正在编写一个原生的 Node.js 模块，并希望检索一个给定 JavaScript 对象的所有可枚举属性名称。下面是如何使用 <code>napi_get_all_property_names</code> 来完成这项任务的伪代码例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你已经有了一个 napi_env env 和一个要检索属性的 napi_value jsObject.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value propertyNames;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 获取所有自有的、可枚举的属性名称。</span></span>
<span class="line"><span>napi_status status = napi_get_all_property_names(</span></span>
<span class="line"><span>    env,</span></span>
<span class="line"><span>    jsObject,</span></span>
<span class="line"><span>    napi_key_own,             // 只考虑对象自身的属性</span></span>
<span class="line"><span>    napi_key_enumerable_only, // 只选取可枚举的属性</span></span>
<span class="line"><span>    napi_key_keep_strings,    // 键作为字符串返回</span></span>
<span class="line"><span>    &amp;propertyNames            // 这是输出参数，将返回属性名数组</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>    // 如果调用成功，你现在可以处理 propertyNames 数组了。</span></span>
<span class="line"><span>    // 例如，你可以遍历这些属性名并做进一步处理。</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此段代码展示了如何通过 <code>napi_get_all_property_names</code> 获取一个 JS 对象自身所有可枚举属性的名称。需要注意的是，实际代码中应当添加更多的错误检查和处理逻辑。</p><p>请记住，这个函数主要在编写涉及与 JavaScript 对象交互的原生扩展时使用，并不常见于日常的 Node.js 应用程序开发中。大多数情况下，你会直接使用 JavaScript 本身提供的反射 API，例如 <code>Object.keys()</code> 或 <code>Object.getOwnPropertyNames()</code> 等。</p><h4 id="napi-set-property" tabindex="-1"><a class="header-anchor" href="#napi-set-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_set_property" target="_blank" rel="noopener noreferrer">napi_set_property</a></span></a></h4><p>当然，很高兴帮助您理解 Node.js 中的<code>napi_set_property</code>这个函数。</p><p>首先，我们需要了解 N-API 是什么。N-API 是 Node.js 提供的一个 C 语言接口，它允许你用 C 或 C++编写插件（称为本机模块），这些插件可以直接与 Node.js 运行时环境交互。使用 N-API 编写的本机模块不受 Node.js 版本更迭的影响，意味着它们有很好的兼容性和稳定性。</p><p><code>napi_set_property</code>是 N-API 中的一个函数，它用于将一个 JavaScript 值设置为对象的属性。这个函数在 C/C++代码中操作 JavaScript 对象时非常有用，尤其是当你创建或修改 JavaScript 对象，并想把它传回给 JavaScript 代码时。</p><p>使用<code>napi_set_property</code>之前，你需要掌握以下概念：</p><ul><li><code>napi_env</code>: 代表 N-API 环境的上下文，几乎所有 N-API 函数都会用到它。</li><li><code>napi_value</code>: 表示 JavaScript 值的抽象表示，可以是数字、字符串、对象等。</li></ul><p>现在，让我们看一下<code>napi_set_property</code>的函数签名：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_set_property(napi_env env,</span></span>
<span class="line"><span>                              napi_value object,</span></span>
<span class="line"><span>                              napi_value key,</span></span>
<span class="line"><span>                              napi_value value);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: N-API 的执行环境。</li><li><code>object</code>: 你要设置属性的 JavaScript 对象。</li><li><code>key</code>: JavaScript 对象的属性名称，通常是一个字符串（也可以是 Symbol）。</li><li><code>value</code>: 你想要设置的值。</li></ul><p>举例来说，假设你用 C++写了一个函数，你想要创建一个 JavaScript 对象，然后添加一个属性<code>name</code>，其值为<code>&quot;Node.js&quot;</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设你已经有了一个napi_env env变量</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CreateObjectWithProperty() {</span></span>
<span class="line"><span>    // 创建一个新的空对象</span></span>
<span class="line"><span>    napi_value js_object;</span></span>
<span class="line"><span>    napi_create_object(env, &amp;js_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建字符串&#39;Node.js&#39;</span></span>
<span class="line"><span>    napi_value js_string;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;Node.js&quot;, NAPI_AUTO_LENGTH, &amp;js_string);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个表示属性键的字符串&#39;name&#39;</span></span>
<span class="line"><span>    napi_value js_key;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;name&quot;, NAPI_AUTO_LENGTH, &amp;js_key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用napi_set_property将&#39;name&#39;属性设置到对象上</span></span>
<span class="line"><span>    napi_set_property(env, js_object, js_key, js_string);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // js_object 现在是一个拥有 { name: &#39;Node.js&#39; } 的JavaScript对象</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们首先创建了一个空的 JavaScript 对象<code>js_object</code>，然后创建了一个表示字符串<code>&quot;Node.js&quot;</code>的<code>napi_value</code>。接着，我们创建了一个表示属性键<code>&quot;name&quot;</code>的<code>napi_value</code>。最后，我们调用<code>napi_set_property</code>将这个属性添加到了对象上。</p><p>现在，如果这个 C++函数被绑定并从 JavaScript 代码中调用，JavaScript 代码就能接收到一个包含<code>{ name: &#39;Node.js&#39; }</code>的对象。</p><p>注意，所有 N-API 函数都返回一个<code>napi_status</code>枚举值，这个值表示操作是否成功。在实际使用中，你应该检查每次 N-API 调用的返回值，确保没有错误发生。</p><h4 id="napi-get-property" tabindex="-1"><a class="header-anchor" href="#napi-get-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_property" target="_blank" rel="noopener noreferrer">napi_get_property</a></span></a></h4><p>Node.js 是一个基于 Chrome 的 V8 JavaScript 引擎运行的 JavaScript 环境。它让你可以用 JavaScript 编写服务器端代码，以及在非浏览器环境下运行 JavaScript。N-API 是 Node.js 提供的一个 API 层，这个 API 层的目标是为了减少原生模块编写者与 Node.js 引擎之间的耦合，并且跨不同版本的 Node.js 提供兼容性。</p><p><code>napi_get_property</code> 是 N-API 中的一个函数，它允许原生模块代码（通常是用 C 或 C++ 写的）访问 JavaScript 对象的属性。当你想从原生代码中读取 JavaScript 对象上的某一个属性时，你可以使用这个函数。</p><p>下面我将通过一个简单的例子来说明 <code>napi_get_property</code> 的用法：</p><p>假设你有一个 JavaScript 对象如下所示：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  age</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你正在编写一个原生插件，并且你想访问这个 <code>user</code> 对象的 <code>name</code> 属性，你会需要通过 N-API 调用 <code>napi_get_property</code> 函数。</p><p>C/C++ 原生代码的大致示例如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 假设你已有 napi_env env 和 napi_value object 参数，其中 object 指向了我们的 user 对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_value name_key, name_value;</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 首先创建一个表示属性名（&quot;name&quot; 字符串）的 napi_value</span></span>
<span class="line"><span>status = napi_create_string_utf8(env, &quot;name&quot;, NAPI_AUTO_LENGTH, &amp;name_key);</span></span>
<span class="line"><span>// 检查是否成功创建字符串</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 然后使用 napi_get_property 获取属性值</span></span>
<span class="line"><span>status = napi_get_property(env, object, name_key, &amp;name_value);</span></span>
<span class="line"><span>// 检查操作是否成功</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 如果操作成功，现在 name_value 将包含 user 对象的 name 属性值</span></span>
<span class="line"><span>// 你可以继续使用其他 N-API 函数来处理这个值，比如转换成 C 字符串等</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码展示了如何在 N-API 中创建一个指向属性名的 <code>napi_value</code>（这里是 &quot;name&quot;），然后如何使用 <code>napi_get_property</code> 来获取对象上该属性的值。</p><p>请注意，实际上在编写原生扩展时，你会需要处理各种错误情况，诸如检查 <code>napi_status</code> 返回值确保每步操作都成功执行，并且可能需要与 JavaScript 代码更紧密地交互，比如接收参数或返回结果给 JavaScript 端。不过上述例子涵盖了 <code>napi_get_property</code> 的核心用法。</p><h4 id="napi-has-property" tabindex="-1"><a class="header-anchor" href="#napi-has-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_has_property" target="_blank" rel="noopener noreferrer">napi_has_property</a></span></a></h4><p><code>napi_has_property</code> 是 Node.js 中的一个 N-API（Node.js API）函数，用来检查 JavaScript 对象是否拥有某个属性。N-API 是一套 C 语言的 API，它允许你使用 C 或 C++ 来编写可从 JavaScript 代码中调用的原生扩展模块。</p><p>为了更好地理解这个函数，我们首先要了解几个基本概念：</p><ol><li><p><strong>JavaScript 对象</strong>：在 JavaScript 中，对象是键值对的集合。例如，<code>{ name: &quot;Alice&quot;, age: 25 }</code> 是一个包含两个属性 <code>name</code> 和 <code>age</code> 的对象。</p></li><li><p><strong>属性</strong>：对象中的每个键（如 <code>name</code> 或 <code>age</code>）被称为属性。</p></li><li><p><strong>原生扩展</strong>：这是直接用 C/C++ 编写的代码，它进行与 JavaScript 核心引擎的交互，通常用来执行不能直接用 JavaScript 完成或者性能较差的任务。</p></li></ol><p>现在，让我们看看 <code>napi_has_property</code> 函数的定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_has_property(napi_env env,</span></span>
<span class="line"><span>                              napi_value object,</span></span>
<span class="line"><span>                              napi_value key,</span></span>
<span class="line"><span>                              bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是一个代表 N-API 环境的句柄。它是大多数 N-API 函数的第一个参数，用于管理和维护与 Node.js 引擎的交互。</li><li><code>object</code>: 这是要检查属性的 JavaScript 对象。</li><li><code>key</code>: 这是要检查的属性名称。它也是一个 JavaScript 值，通常是一个字符串或符号（Symbol）。</li><li><code>result</code>: 这是一个指向布尔值的指针，函数会将结果存入这个地址。如果属性存在，那么这个值会设置为 <code>true</code>；否则，为 <code>false</code>。</li></ul><p><code>napi_has_property</code> 的返回值是 <code>napi_status</code> 类型，其中包含了操作的状态信息，例如是否成功执行或遇到了错误。</p><h3 id="实际运用例子-3" tabindex="-1"><a class="header-anchor" href="#实际运用例子-3"><span>实际运用例子</span></a></h3><p>假设我们正在编写一个原生扩展，需要检查传入的 JavaScript 对象是否具有 <code>username</code> 属性。以下是一段可能的 C/C++ 代码示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...其他必要的代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CheckProperty(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value thisArg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取函数参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;thisArg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否提供了足够的参数</span></span>
<span class="line"><span>    if (argc `&lt;` 1) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Wrong number of arguments&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个表示属性名 &quot;username&quot; 的 JavaScript 字符串</span></span>
<span class="line"><span>    napi_value key;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;username&quot;, NAPI_AUTO_LENGTH, &amp;key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查对象是否含有这个属性</span></span>
<span class="line"><span>    bool hasProperty;</span></span>
<span class="line"><span>    napi_has_property(env, args[0], key, &amp;hasProperty);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 根据结果返回 JavaScript 值 true 或 false</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_boolean(env, hasProperty, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...其他必要的代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个名为 <code>CheckProperty</code> 的函数，它检查传递给它的第一个参数（一个 JavaScript 对象）是否有 <code>username</code> 属性，并返回一个表示结果的布尔值。</p><p>请注意，为了实际在 Node.js 中使用这个原生扩展，你还需要编写额外的代码来注册扩展模块、方法和初始化它们。以上只是关于 <code>napi_has_property</code> 如何使用的简单演示。</p><h4 id="napi-delete-property" tabindex="-1"><a class="header-anchor" href="#napi-delete-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_delete_property" target="_blank" rel="noopener noreferrer">napi_delete_property</a></span></a></h4><p>当然，让我们来聊一聊 Node.js 中的 <code>napi_delete_property</code> 函数。首先，我们需要了解 N-API 是什么：N-API 是一个 C 语言的 API，它是 Node.js 提供的一个稳定的抽象层，允许你编写可跨不同版本 Node.js 运行的本地插件。</p><p>现在，让我们深入到 <code>napi_delete_property</code> 这个函数：</p><h3 id="napi-delete-property-1" tabindex="-1"><a class="header-anchor" href="#napi-delete-property-1"><span>napi_delete_property</span></a></h3><p>这个函数用于从一个 JavaScript 对象中删除一个属性。它是 N-API 的一部分，并且接受几个参数来完成操作。</p><h4 id="参数-4" tabindex="-1"><a class="header-anchor" href="#参数-4"><span>参数：</span></a></h4><ul><li><code>env</code>: 这是表示 N-API 环境的一个句柄，它提供了大量的 N-API 调用所需的上下文信息。</li><li><code>object</code>: 这是你想要删除属性的那个 JavaScript 对象。</li><li><code>key</code>: 这代表了要被删除的属性的名称或者 Symbol。</li></ul><h4 id="返回值-6" tabindex="-1"><a class="header-anchor" href="#返回值-6"><span>返回值：</span></a></h4><ul><li>如果操作成功，它将返回 <code>napi_ok</code>，这表明属性已经被成功删除。</li><li>如果有错误发生，它将返回一个代表相应错误类型的枚举值。</li></ul><h3 id="实际运用例子-4" tabindex="-1"><a class="header-anchor" href="#实际运用例子-4"><span>实际运用例子：</span></a></h3><p>假设你正在编写一个 Node.js 的本地插件，而你希望删除一个对象中的某个属性。假设我们有一个 JavaScript 对象如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，你想在你的本地插件中删除属性 <code>b</code>。</p><p>使用 <code>napi_delete_property</code> 的 C 代码可能看起来像这样：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value DeletePropertyExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value object_to_delete_property_from;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取传递给函数的 JavaScript 对象</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    object_to_delete_property_from = args[0]; // 第一个参数是我们的对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个表示属性 &#39;b&#39; 的字符串</span></span>
<span class="line"><span>    napi_value key;</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;b&quot;, NAPI_AUTO_LENGTH, &amp;key);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 删除属性 &#39;b&#39;</span></span>
<span class="line"><span>    bool result;</span></span>
<span class="line"><span>    status = napi_delete_property(env, object_to_delete_property_from, key, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (result) {</span></span>
<span class="line"><span>        // 属性 &#39;b&#39; 已被删除</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 属性 &#39;b&#39; 没有被删除（可能该属性不存在或不可配置）</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回undefined，因为这个函数不需要返回任何值</span></span>
<span class="line"><span>    napi_value undef;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;undef);</span></span>
<span class="line"><span>    return undef;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册这个函数以便在JavaScript中可以调用</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value deleteFn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, DeletePropertyExample, NULL, &amp;deleteFn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;deletePropertyExample&quot;, deleteFn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 里，你可以这样调用这个本地函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;path-to-your-native-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">deletePropertyExample</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// { a: 1, c: 3 }, 属性 &#39;b&#39; 已经被删除</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 <code>napi_delete_property</code> 的基础介绍和一个简单的使用示例。希望能帮助你理解这个函数如何在实际中应用！</p><h4 id="napi-has-own-property" tabindex="-1"><a class="header-anchor" href="#napi-has-own-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_has_own_property" target="_blank" rel="noopener noreferrer">napi_has_own_property</a></span></a></h4><p><code>napi_has_own_property</code> 是 Node.js 中的一个函数，这个函数是 Node.js 的 N-API（Node.js API）的一部分。N-API 是一个 C 层面的 API，让你可以创建原生的插件，这些插件可以直接和 Node.js 交互，通常用来提升性能或者让 Node.js 能够使用那些只有 C/C++库才有的功能。</p><p>在解释 <code>napi_has_own_property</code> 前，让我们先理解一下 JavaScript 中的对象属性。在 JavaScript 中，每个对象都有一些属性，它们可以是直接定义在该对象上的（也就是&quot;自有属性&quot;），也可以是从它的原型链中继承而来的。检查一个属性是否为对象的自有属性很重要，因为这关系到了属性的枚举、遍历和权限控制等问题。</p><p>现在回到 <code>napi_has_own_property</code> 函数。这个函数的作用是告诉我们一个给定的属性是否是 JavaScript 对象的自有属性。它是 N-API 的一部分，因此在 C 或 C++中编写的代码中被使用，不是在常规的 JavaScript 代码中。</p><p>函数原型：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_has_own_property(napi_env env,</span></span>
<span class="line"><span>                                  napi_value object,</span></span>
<span class="line"><span>                                  napi_value key,</span></span>
<span class="line"><span>                                  bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>参数解释：</strong></p><ul><li><code>env</code>: 这是表示 N-API 调用的上下文的环境句柄。</li><li><code>object</code>: 这是我们要检查属性的 JavaScript 对象。</li><li><code>key</code>: 表示我们想要检查的属性的名称或者 Symbol。</li><li><code>result</code>: 指向布尔值的指针，函数执行后会将结果存储在这个布尔值中。如果属性确实存在并且是自有属性，则结果为 true；否则为 false。</li></ul><p><strong>函数返回值：</strong></p><ul><li>返回一个类型为 <code>napi_status</code> 的值，这个值表示函数调用是否成功。如果成功，返回 <code>napi_ok</code>，否则返回错误码。</li></ul><p><strong>使用场景例子：</strong></p><p>假设你创建了一个 Node.js 原生模块，需要对传入的 JavaScript 对象进行操作，并且你需要判断这个对象是否具有特定的属性，而且这个属性必须是该对象自己独有的，不是从原型继承来的。</p><p>C 代码示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递的参数</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 校验参数并执行相关操作</span></span>
<span class="line"><span>    if (status == napi_ok &amp;&amp; argc == 1) {</span></span>
<span class="line"><span>        napi_value objectToCheck = args[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 我们要检查的属性</span></span>
<span class="line"><span>        napi_value key;</span></span>
<span class="line"><span>        status = napi_create_string_utf8(env, &quot;myProperty&quot;, NAPI_AUTO_LENGTH, &amp;key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 检查属性</span></span>
<span class="line"><span>        bool hasOwnProperty;</span></span>
<span class="line"><span>        status = napi_has_own_property(env, objectToCheck, key, &amp;hasOwnProperty);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 根据结果进行处理</span></span>
<span class="line"><span>        if (status == napi_ok &amp;&amp; hasOwnProperty) {</span></span>
<span class="line"><span>            // 如果有这个自有属性，执行一些操作...</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            // 如果没有这个属性或者出错了，执行其他操作...</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一些值给JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先获取了通过 JavaScript 传递过来的参数，然后创建了一个字符串键来表示我们要检查的属性 <code>&quot;myProperty&quot;</code>。使用 <code>napi_has_own_property()</code> 函数检查这个属性是否为对象的自有属性，最后根据结果执行相应的操作。</p><p>总结起来，<code>napi_has_own_property</code> 在 Node.js 的 N-API 中用于原生模块开发，它帮助我们检查一个属性是否是 JavaScript 对象的自有属性。这对于进行有效的属性管理和正确的内存操作非常重要，尤其是在涉及原生资源时。</p><h4 id="napi-set-named-property" tabindex="-1"><a class="header-anchor" href="#napi-set-named-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_set_named_property" target="_blank" rel="noopener noreferrer">napi_set_named_property</a></span></a></h4><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行时环境。它让我们能够使用 JavaScript 来编写服务器端的代码。N-API 则是 Node.js 提供的一个用于构建原生插件的 API。</p><p>在 Node.js 中，你可以用 JavaScript 写大部分的功能，但有时候你可能需要直接使用 C 或者 C++来写一些性能关键型的代码或者与操作系统交互。这些用 C 或 C++写的模块称为“原生插件”。</p><p><code>napi_set_named_property</code>函数就是这样一个 N-API 的函数，它允许原生插件（C/C++代码）给一个 JavaScript 对象设置属性。</p><p>这个函数原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_set_named_property(napi_env env,</span></span>
<span class="line"><span>                                    napi_value object,</span></span>
<span class="line"><span>                                    const char* utf8name,</span></span>
<span class="line"><span>                                    napi_value value);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>：代表当前的 N-API 环境上下文。</li><li><code>object</code>：是要添加属性的 JavaScript 对象。</li><li><code>utf8name</code>：是一个以 null 结尾的字符串，表示你想要设置的属性的名称。</li><li><code>value</code>：是一个<code>napi_value</code>，表示属性的值，它可以代表任何 JavaScript 数据类型，例如一个数字、字符串、对象等。</li></ul><p>返回值：<code>napi_status</code>，它表示操作成功还是失败等状态信息。</p><p>现在举个例子，假设你正在写一个原生插件，你想要创建一个 JavaScript 对象，并且给它添加一个属性叫<code>version</code>，其值为字符串<code>&quot;1.0.0&quot;</code>。下面是你可能会怎么做的 C 代码示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数被暴露给JavaScript，因此可从Node.js中调用</span></span>
<span class="line"><span>napi_value CreateObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value myObject;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的空对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;myObject);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个JavaScript字符串，作为属性的值</span></span>
<span class="line"><span>    napi_value versionString;</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;1.0.0&quot;, NAPI_AUTO_LENGTH, &amp;versionString);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置对象的&quot;version&quot;属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, myObject, &quot;version&quot;, versionString);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回创建的对象</span></span>
<span class="line"><span>    return myObject;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化函数，此处将CreateObject关联到名为&quot;createObject&quot;的导出项</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value exportFunc;</span></span>
<span class="line"><span>    napi_status status = napi_create_function(env, NULL, 0, CreateObject, NULL, &amp;exportFunc);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return exportFunc;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当从 Node.js 代码中调用这个模块的<code>createObject</code>方法时，它就会返回我们刚刚创建并设置属性的对象。</p><p>在 JavaScript 中，你可能会这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 将输出: 1.0.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，你就能在 C/C++中构建复杂的数据结构，然后把它们传递给 Node.js 的 JavaScript 环境，非常方便地进行进一步处理。</p><h4 id="napi-get-named-property" tabindex="-1"><a class="header-anchor" href="#napi-get-named-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_named_property" target="_blank" rel="noopener noreferrer">napi_get_named_property</a></span></a></h4><p>当然，我很乐意帮助你理解这个概念。</p><p>Node.js 的 N-API 是一个 API，它允许你编写本地插件。所谓本地插件，就是用 C 或者 C++ 写的代码，这些代码可以直接调用 Node.js 的功能、或者反过来被 Node.js 调用。这样做的好处是可以利用 C/C++ 的性能优势，或者使用已经存在的 C/C++ 库。</p><p><code>napi_get_named_property</code> 这个函数是 N-API 的一部分，用于从 JavaScript 对象中获取属性的值。简单来说，就是如果你有一个 JavaScript 对象，而你又在 C/C++ 代码中工作，你可以使用这个函数来读取 JavaScript 对象的属性。</p><p>比如说，如果我们有一个这样的 JavaScript 对象：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  age</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想在 C/C++ 插件中获取这个对象的 <code>name</code> 属性的值，我们就可以使用 <code>napi_get_named_property</code> 函数。</p><p>下面是一个例子，展示了如何在 C/C++ 中使用这个函数：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 env 是 napi_env 类型的变量，obj 是 napi_value 类型的变量，</span></span>
<span class="line"><span>// 表示上面提到的 person 对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value name_value;</span></span>
<span class="line"><span>napi_status status = napi_get_named_property(env, obj, &quot;name&quot;, &amp;name_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  // 如果成功，name_value 现在包含了 name 属性的值</span></span>
<span class="line"><span>  // 然后你可以把它转换成 C/C++ 字符串或其他你需要的格式</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，<code>env</code> 是一个表示当前环境的变量，所有的 N-API 调用都需要它。<code>obj</code> 是一个 <code>napi_value</code> 类型的变量，表示我们要操作的 JavaScript 对象。<code>&quot;name&quot;</code> 是我们想要读取的属性名，<code>name_value</code> 将会得到属性的值（也是一个 <code>napi_value</code> 类型，因为在 N-API 中，JavaScript 值都由这个类型表示）。</p><p>但是要注意的是，这个函数只获取属性的值，并不执行任何 JavaScript 代码。这意味着如果属性是 getter 函数，它不会被调用。</p><p>这种机制在与 JavaScript 交互时非常有用，特别是当你需要高性能处理或者需要将现有的 C/C++ 代码集成到 Node.js 应用程序中时。</p><h4 id="napi-has-named-property" tabindex="-1"><a class="header-anchor" href="#napi-has-named-property"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_has_named_property" target="_blank" rel="noopener noreferrer">napi_has_named_property</a></span></a></h4><p><code>napi_has_named_property</code> 是一个函数，它来自 Node.js 的 N-API（Node.js API），这是一个用于构建原生插件的接口。N-API 提供了一系列的 C 语言 API，允许本地代码与 JavaScript 代码进行交互。在这种情况下，<code>napi_has_named_property</code> 允许你检查一个 JavaScript 对象是否有一个特定名称的属性。</p><h3 id="使用场景解释" tabindex="-1"><a class="header-anchor" href="#使用场景解释"><span>使用场景解释：</span></a></h3><p>当你在编写一个原生模块（通常是用 C 或者 C++ 写的）时，你可能需要检查一个从 JavaScript 传递过来的对象是否拥有某个属性。例如，如果你正在编写一个处理配置对象的模块，那么你可能想要检查用户是否提供了某些必要的设置。</p><h3 id="函数签名-5" tabindex="-1"><a class="header-anchor" href="#函数签名-5"><span>函数签名：</span></a></h3><p>这个函数的声明如下所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_has_named_property(napi_env env, napi_value object, const char* utf8name, bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>env</code>: 表示一个 N-API 调用环境，它贯穿整个 N-API 的使用周期。</li><li><code>object</code>: 是指向你想要检查属性的 JavaScript 对象的引用。</li><li><code>utf8name</code>: 是一个字符串，表示你要检查的属性名。</li><li><code>result</code>: 是一个布尔值的指针，在函数执行后，*result 会被设置为 <code>true</code> 如果该属性存在，否则为 <code>false</code>。</li></ul><h3 id="返回值-7" tabindex="-1"><a class="header-anchor" href="#返回值-7"><span>返回值：</span></a></h3><p>这个函数会返回一个 <code>napi_status</code> 值，告诉你调用是否成功。<code>napi_status</code> 是一个枚举，包含了多种状态，比如 <code>napi_ok</code> 表示操作成功完成。</p><h3 id="实际例子-8" tabindex="-1"><a class="header-anchor" href="#实际例子-8"><span>实际例子：</span></a></h3><p>假设我们在编写一个原生模块，这个模块需要用户传递一个包含 <code>config</code> 属性的对象：</p><p>JavaScript 侧代码可能是这样的：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;your-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">process</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">  config</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //... 配置信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在你的原生模块中，你可能需要这样判断 <code>process</code> 方法接收到的对象是否含有 <code>config</code> 属性：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 object 是从 JS 传过来的参数</span></span>
<span class="line"><span>napi_value object;</span></span>
<span class="line"><span>bool hasConfig;</span></span>
<span class="line"><span>napi_status status = napi_has_named_property(env, object, &quot;config&quot;, &amp;hasConfig);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (hasConfig) {</span></span>
<span class="line"><span>  // 继续处理存在 config 属性的逻辑...</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>  // 抛出异常或处理不存在 config 属性的情形...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码展示了如何使用 <code>napi_has_named_property</code> 来确认一个对象是否具有 <code>config</code> 属性，并据此进行不同的处理策略。如果发现没有 <code>config</code> 属性，可以抛出一个错误，告诉 JS 代码缺少必要的配置。</p><h4 id="napi-set-element" tabindex="-1"><a class="header-anchor" href="#napi-set-element"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_set_element" target="_blank" rel="noopener noreferrer">napi_set_element</a></span></a></h4><p><code>napi_set_element</code>是 Node.js 中 N-API 的一部分，N-API 是一个用于构建原生插件的 API 层。简单来说，原生插件允许你用 C 或 C++编写代码，这些代码可以直接在 Node.js 运行时环境中执行，提供性能上的优势，特别是对于需要大量计算的任务。</p><p><code>napi_set_element</code>具体是一个函数，它用于设置 JavaScript 数组中指定索引位置的元素值。当你用 C 或 C++编写与 Node.js 交互的代码时，你可能需要操作 JavaScript 对象和数组。这个函数就是用来完成数组操作的部分工作。</p><h3 id="函数签名-6" tabindex="-1"><a class="header-anchor" href="#函数签名-6"><span>函数签名</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_set_element(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    napi_value array,</span></span>
<span class="line"><span>    uint32_t index,</span></span>
<span class="line"><span>    napi_value value</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：表示当前的 N-API 环境，通常是你在每个 N-API 函数中都会见到的参数。任何使用 N-API 的函数几乎总是需要这个环境变量。</li><li><code>array</code>：这是你想要修改的 JavaScript 数组的引用。</li><li><code>index</code>：你希望设置的数组元素的索引（位置）。</li><li><code>value</code>：这是你想要放置在数组中的那个索引处的值的引用。</li></ul><h3 id="实际例子-9" tabindex="-1"><a class="header-anchor" href="#实际例子-9"><span>实际例子</span></a></h3><p>假设你有一个 JavaScript 数组，并且你想要在 C++扩展中更改第二个元素的值。在 Node.js 代码中，你可能会这样做：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">myArray</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 设置数组的第二个元素为20</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是在 C++的 N-API 中，你会使用<code>napi_set_element</code>来达到同样的目的：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value SetElementExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 提前定义好你将用到的N-API变量</span></span>
<span class="line"><span>    napi_value myArray;</span></span>
<span class="line"><span>    napi_value valToSet;</span></span>
<span class="line"><span>    uint32_t index = 1; // 我们想要设置的索引</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的JavaScript数组</span></span>
<span class="line"><span>    status = napi_create_array(env, &amp;myArray);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 让我们假设要设置的值是20</span></span>
<span class="line"><span>    status = napi_create_int32(env, 20, &amp;valToSet);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置数组的第二个元素（index=1，因为索引是从0开始的）</span></span>
<span class="line"><span>    status = napi_set_element(env, myArray, index, valToSet);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回已被修改的数组</span></span>
<span class="line"><span>    return myArray;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 然后你还需要注册这个函数，以便它可以从Node.js调用，</span></span>
<span class="line"><span>// 这通常在N-API模块的初始化函数中完成。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子演示了如何创建一个数组并设置其特定索引处的值。这只是<code>napi_set_element</code>的一个简单应用实例，在实际开发中，你可能需要处理更复杂的数据结构和错误检查流程。</p><h4 id="napi-get-element" tabindex="-1"><a class="header-anchor" href="#napi-get-element"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_element" target="_blank" rel="noopener noreferrer">napi_get_element</a></span></a></h4><p><code>napi_get_element</code> 是 Node.js 中的一个 N-API 函数，用于从 JavaScript 数组中获取指定索引处的值。N-API 是 Node.js 提供的一套 C API，使得本地插件（通常是 C 或 C++编写的模块）能够与 JavaScript 代码交互，并且不受 Node.js 版本变动的影响。</p><p><strong>基本概念：</strong></p><ul><li><strong>N-API</strong>：一组固定的 API，独立于底层的 JavaScript 运行时（如 V8），旨在保持二进制兼容性，即使 Node.js 的版本升级也不需要对本地插件重新编译。</li><li><strong>JavaScript 数组</strong>：在 JavaScript 中，数组是一种用来存储多个值的单一变量。</li></ul><p><strong><code>napi_get_element</code>函数的作用：</strong><br> 这个函数用于访问 JavaScript 中的数组元素。它的签名大致如下(使用 C 语言):</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_element(napi_env env,</span></span>
<span class="line"><span>                             napi_value array,</span></span>
<span class="line"><span>                             uint32_t index,</span></span>
<span class="line"><span>                             napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：表示 N-API 调用的上下文。</li><li><code>array</code>：一个 <code>napi_value</code>，代表 JavaScript 中的数组。</li><li><code>index</code>：要访问数组的哪个位置的元素，以 0 开始的索引值。</li><li><code>result</code>：用来接收位于提供索引的数组元素的 <code>napi_value</code>。</li></ul><p>函数返回一个 <code>napi_status</code> 值，表示操作成功与否。</p><p><strong>实际应用例子：</strong></p><p>假设有如下 JavaScript 数组：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">40</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>你想通过一个 C/C++的 Node.js 插件获取这个数组的第三个元素（30）。你的 C 代码会像这样使用<code>napi_get_element</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数被假定为已经设置好与JavaScript环境相联系</span></span>
<span class="line"><span>void GetThirdElementExample(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript传递给这个C函数的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // args[0] 应该是我们的JavaScript数组</span></span>
<span class="line"><span>    napi_value array = args[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 我们想要获取第三个元素，索引值为2</span></span>
<span class="line"><span>    uint32_t index = 2;</span></span>
<span class="line"><span>    napi_value thirdElementValue;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用napi_get_element获取数组的第三个元素</span></span>
<span class="line"><span>    napi_status status = napi_get_element(env, array, index, &amp;thirdElementValue);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保操作成功</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 如果操作成功，thirdElementValue 现在就包含了数字30</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 以下代码可以将napi_value转换为C类型的值，比如int</span></span>
<span class="line"><span>        int thirdElement;</span></span>
<span class="line"><span>        napi_get_value_int32(env, thirdElementValue, &amp;thirdElement);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 现在你可以使用这个值做进一步的操作了</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 错误处理：可以通过status来判断发生了什么错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码演示了如何从 Node.js 传递到原生插件的数组中获取特定元素的值，并将其转换为 C 语言中的整数。通过这样的方式，你可以在 C/C++代码中实现复杂的逻辑处理，同时利用 JavaScript 进行高层次的应用程序开发。</p><h4 id="napi-has-element" tabindex="-1"><a class="header-anchor" href="#napi-has-element"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_has_element" target="_blank" rel="noopener noreferrer">napi_has_element</a></span></a></h4><p><code>napi_has_element</code> 是 Node.js 中 N-API (Native API) 的一部分，它提供了一种在原生模块中与 JavaScript 交互的稳定、跨版本的接口。</p><p>这个函数的作用是检查一个 JavaScript 对象是否具有给定的索引属性。在 JavaScript 中，你可以把对象当作数组来使用，访问它的元素通过索引（比如 <code>obj[0]</code>, <code>obj[1]</code>），而 <code>napi_has_element</code> 就是用来判断指定索引的元素是否存在。</p><p>下面将详细解释 <code>napi_has_element</code> 的用法，并给出一个简单的例子：</p><h3 id="函数原型-2" tabindex="-1"><a class="header-anchor" href="#函数原型-2"><span>函数原型：</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_has_element(napi_env env,</span></span>
<span class="line"><span>                             napi_value object,</span></span>
<span class="line"><span>                             uint32_t index,</span></span>
<span class="line"><span>                             bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: <code>napi_env</code> 对象，它代表了 Node.js 的运行环境，你可以通过这个环境来调用其他 N-API 函数。</li><li><code>object</code>: <code>napi_value</code> 类型，表示一个 JavaScript 对象，我们将检查这个对象是否含有特定索引的元素。</li><li><code>index</code>: 一个 <code>uint32_t</code> 整数，表示要检查的索引值。</li><li><code>result</code>: 指向布尔类型的指针，函数会设置这个值以指示对象是否有该索引的元素。</li></ul><h3 id="返回值-8" tabindex="-1"><a class="header-anchor" href="#返回值-8"><span>返回值：</span></a></h3><p><code>napi_has_element</code> 返回 <code>napi_status</code> 类型的值，这表明操作是否成功。如果函数调用成功，返回 <code>napi_ok</code>；如果出现错误，则返回不同的错误码，表明发生了什么问题。</p><h3 id="实际使用例子" tabindex="-1"><a class="header-anchor" href="#实际使用例子"><span>实际使用例子：</span></a></h3><p>假设我们编写了一个原生模块，在这个模块中，我们想要检查某个 JavaScript 数组或者类似数组的对象是否有位于第二个位置的元素（索引为 1）。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 定义其他必要的变量和初始化代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设 args[0] 是传入的 JavaScript 对象</span></span>
<span class="line"><span>    bool hasElement;</span></span>
<span class="line"><span>    napi_status status = napi_has_element(env, args[0], 1, &amp;hasElement);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 如果出现错误，处理错误逻辑</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 根据查询结果执行不同的逻辑</span></span>
<span class="line"><span>    if (hasElement) {</span></span>
<span class="line"><span>        // 对象中有索引为 1 的元素</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 对象中没有索引为 1 的元素</span></span>
<span class="line"><span>        // ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一些值或 undefined</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册原生函数等其他相关代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们定义了一个原生函数 <code>MyNativeFunction</code>，它接收一个参数并且调用 <code>napi_has_element</code> 来检查该参数是否有索引为 1 的元素。根据检查的结果，我们可以决定执行不同的逻辑。最后，这个函数返回了 <code>undefined</code> 或者其它一些值，取决于具体实现。</p><h4 id="napi-delete-element" tabindex="-1"><a class="header-anchor" href="#napi-delete-element"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_delete_element" target="_blank" rel="noopener noreferrer">napi_delete_element</a></span></a></h4><p>在 Node.js 中，<code>napi_delete_element</code>是一个函数，属于 N-API（Node API），这是一套用于构建本地插件的 API。N-API 设计的目的是为了让 C 或 C++编写的插件能够在不同版本的 Node.js 中运行而不需要重新编译，提高模块的稳定性和兼容性。</p><p><code>napi_delete_element</code>函数的作用是从 JavaScript 对象中删除一个属性，与 JavaScript 中的<code>delete object[property]</code>操作相似。但这里的对象是一个数组，因此该函数特指从数组中移除索引处的元素。</p><p>我们现在来详细解释一下这个函数：</p><h3 id="函数签名-7" tabindex="-1"><a class="header-anchor" href="#函数签名-7"><span>函数签名</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_delete_element(napi_env env, napi_value object, uint32_t index, bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>napi_env env</code>: 这是表示 N-API 环境的句柄。它是一个上下文对象，提供了许多 N-API 调用所需的信息。</li><li><code>napi_value object</code>: 这是数组对象的句柄，表示要操作的数组。</li><li><code>uint32_t index</code>: 这是你想要删除的数组元素的索引。</li><li><code>bool* result</code>: 这个参数会返回操作是否成功。如果删除成功，它会被设置为<code>true</code>；否则为<code>false</code>。</li></ul><h3 id="返回值-9" tabindex="-1"><a class="header-anchor" href="#返回值-9"><span>返回值</span></a></h3><p>返回一个<code>napi_status</code>枚举值，代表函数执行的状态。如果返回<code>napi_ok</code>，则表示没有错误发生。</p><h3 id="举例说明" tabindex="-1"><a class="header-anchor" href="#举例说明"><span>举例说明</span></a></h3><p>假设我们有一个 Node.js 的本地插件，在 C/C++代码中，我们希望删除一个 JavaScript 数组中的特定元素。我们的代码可能如下所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这个函数是为了从给定的JavaScript数组中删除特定索引处的元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value DeleteElementFromJSArray(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 2;</span></span>
<span class="line"><span>    napi_value args[2];</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 解析传入的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // args[0] 应该是一个数组</span></span>
<span class="line"><span>    napi_value js_array = args[0];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // args[1] 应该是一个数字，表示数组中要删除的元素索引</span></span>
<span class="line"><span>    uint32_t index;</span></span>
<span class="line"><span>    napi_get_value_uint32(env, args[1], &amp;index);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 执行删除操作</span></span>
<span class="line"><span>    bool result;</span></span>
<span class="line"><span>    napi_status status = napi_delete_element(env, js_array, index, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查操作是否成功</span></span>
<span class="line"><span>    if (status == napi_ok &amp;&amp; result) {</span></span>
<span class="line"><span>        // 删除成功</span></span>
<span class="line"><span>        return nullptr; // 或返回一个表示成功的JavaScript值</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 删除失败，可以根据具体情况处理错误</span></span>
<span class="line"><span>        return nullptr; // 或返回一个表示失败的JavaScript值</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将上面的函数暴露为模块的导出</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, DeleteElementFromJSArray, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;deleteElement&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个<code>DeleteElementFromJSArray</code>函数，它接收两个参数：第一个是 JavaScript 数组，第二个是要删除的元素索引。使用<code>napi_get_cb_info</code>获取 JavaScript 传递的参数，然后调用<code>napi_delete_element</code>执行删除操作。最后，根据操作结果返回相应的 JavaScript 值。</p><p>要注意的是，这只是一个简化的例子，实际上还需要进行更多的错误检查和边界检查等操作。</p><h4 id="napi-define-properties" tabindex="-1"><a class="header-anchor" href="#napi-define-properties"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_define_properties" target="_blank" rel="noopener noreferrer">napi_define_properties</a></span></a></h4><p><code>napi_define_properties</code> 是 Node.js 中 N-API 的一部分，N-API 是一个用于构建原生插件的 API。原生插件是用 C 或 C++编写的，可以直接调用 Node.js 底层 API，通常用于提升性能或实现 Node.js 本身无法直接实现的功能。</p><p>在介绍 <code>napi_define_properties</code> 之前，我们需要理解几个概念：</p><ol><li><p><strong>N-API</strong>: Node.js 的 Native API，使得开发者能够不依赖于 V8 引擎的内部结构来构建扩展模块。这意味着使用 N-API 的扩展模块与 Node.js 的版本无关，可以在不同版本的 Node.js 中运行而无需重新编译。</p></li><li><p><strong>对象属性</strong>: 在 JavaScript 中，对象由属性组成，每个属性都有一个键（key）和相应的值（value）。属性还可以包含如是否可写、是否可枚举等特性。</p></li><li><p><strong>napi_value</strong>: 这是一个代表 JavaScript 值的抽象句柄，在 N-API 函数中用来表示各种类型的值，比如数字、字符串、对象等。</p></li><li><p><strong>napi_property_descriptor</strong>: 这是一个结构体，用来描述对象的属性，包括属性名称、属性特性等。</p></li></ol><p>现在，让我们看看 <code>napi_define_properties</code> 函数。它用于在一个已存在的 JavaScript 对象上定义新的属性。这个函数的原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_define_properties(napi_env env,</span></span>
<span class="line"><span>                                   napi_value object,</span></span>
<span class="line"><span>                                   size_t properties_count,</span></span>
<span class="line"><span>                                   const napi_property_descriptor* properties);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>: 当前执行环境。</li><li><code>object</code>: 要定义属性的 JavaScript 对象。</li><li><code>properties_count</code>: 要定义的属性数量。</li><li><code>properties</code>: 指向<code>napi_property_descriptor</code>数组的指针，每个元素描述一个属性。</li></ul><p>使用这个函数时，你首先创建一个或多个 <code>napi_property_descriptor</code> 结构体来表示你想在 JavaScript 对象上定义的属性，然后通过 <code>napi_define_properties</code> 将它们添加到对象上。</p><p>举个例子，假设你正在编写一个原生模块，需要在一个对象上定义两个属性：一个是可读写的 <code>myNumber</code>，另一个是只读的 <code>myString</code>。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 定义属性描述符数组</span></span>
<span class="line"><span>  napi_property_descriptor properties[] = {</span></span>
<span class="line"><span>    { &quot;myNumber&quot;, NULL, 0, 0, 0, 0, napi_default, 0 },</span></span>
<span class="line"><span>    { &quot;myString&quot;, NULL, 0, 0, 0, 0, napi_default, (void*)&quot;this is a string&quot; }</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个新的空对象</span></span>
<span class="line"><span>  napi_value myObject;</span></span>
<span class="line"><span>  napi_create_object(env, &amp;myObject);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 定义myNumber为一个可读写的属性，默认值是42</span></span>
<span class="line"><span>  napi_value numberValue;</span></span>
<span class="line"><span>  napi_create_double(env, 42, &amp;numberValue);</span></span>
<span class="line"><span>  properties[0].value = numberValue;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 定义myString为一个只读的属性</span></span>
<span class="line"><span>  properties[1].getter = [](napi_env env, napi_callback_info info) -&gt; napi_value {</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, NULL, NULL, NULL, &amp;data);</span></span>
<span class="line"><span>    napi_value stringValue;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, static_cast`&lt;`char*&gt;(data), NAPI_AUTO_LENGTH, &amp;stringValue);</span></span>
<span class="line"><span>    return stringValue;</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将属性添加到对象上</span></span>
<span class="line"><span>  napi_define_properties(env, myObject, sizeof(properties) / sizeof(properties[0]), properties);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 导出这个对象</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;myModule&quot;, myObject);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，我们创建了一个新的 JavaScript 对象，并为它定义了两个属性。<code>myNumber</code> 属性被设置为初始值 42，并且是可读写的。<code>myString</code> 属性通过一个 getter 函数定义，当在 JavaScript 中访问这个属性时，getter 函数会被调用，返回一个字符串&quot;this is a string&quot;。</p><p>最后，我们将这个对象导出为模块的一部分，这样在 JavaScript 代码中就可以通过 require 加载并使用这个对象及其定义的属性了。</p><h4 id="napi-object-freeze" tabindex="-1"><a class="header-anchor" href="#napi-object-freeze"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_object_freeze" target="_blank" rel="noopener noreferrer">napi_object_freeze</a></span></a></h4><p>Node.js 是一个十分流行的 JavaScript 运行环境，它允许你在服务器端运行 JavaScript 代码。N-API 是 Node.js 提供的一套用于构建原生插件的 API。原生插件是使用像 C 或者 C++这样的语言编写的模块，可以直接和 Node.js 的底层 API 进行交互。</p><p><code>napi_object_freeze</code> 是 N-API 中的一个函数，其目的在于让一个 JavaScript 对象变得不可修改，也就是说，一旦一个对象被冻结（freeze），就不能再向它添加新的属性，也不能删除或修改已有的属性，甚至现有的属性也不能被重新配置（比如改变它们的可枚举性、可配置性等）。这个过程类似于 JavaScript 中 <code>Object.freeze()</code> 方法的功能。</p><p>这里是 <code>napi_object_freeze</code> 函数的一般用法：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_object_freeze(napi_env env,</span></span>
<span class="line"><span>                               napi_value object);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>: 这是表示当前环境的句柄，它是所有 N-API 调用的上下文。</li><li><code>object</code>: 这是你想要冻结的 JavaScript 对象。</li></ul><p>返回值是 <code>napi_status</code> 类型，它会告诉你操作是否成功完成。</p><p>现在让我们通过一个简单的例子来理解如何使用 <code>napi_object_freeze</code>:</p><p>假设你正在编写一个 Node.js 原生扩展，你希望提供一个对象给 JavaScript 侧，但你不想让用户能够更改这个对象。</p><p>首先，你需要创建一个 JavaScript 对象，并将其传递给 <code>napi_object_freeze</code> 函数进行冻结。以下是一个使用 C 语言编写的示例代码片段：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...其他必要的代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreateFrozenObject(napi_env env) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value my_object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的空对象</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;my_object);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在这里你可能会给对象添加一些初始属性</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 冻结对象以防止更改</span></span>
<span class="line"><span>    status = napi_object_freeze(env, my_object);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回冻结后的对象</span></span>
<span class="line"><span>    return my_object;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...更多代码...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在你的原生模块中调用 <code>CreateFrozenObject</code> 函数就会返回一个被冻结的对象，JavaScript 代码尝试去修改这个对象将会失败，并可能抛出异常。</p><p>记住，当你在实际开发中使用 <code>napi_object_freeze</code> 时，总是要检查返回状态确保操作成功。如果 <code>napi_object_freeze</code> 调用失败了，你应该妥善处理错误情况。</p><h4 id="napi-object-seal" tabindex="-1"><a class="header-anchor" href="#napi-object-seal"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_object_seal" target="_blank" rel="noopener noreferrer">napi_object_seal</a></span></a></h4><p><code>napi_object_seal</code> 是 Node.js 中的 N-API（原生 API）的一部分，它提供了一个与 JavaScript V8 引擎的直接交互层。这个函数用于使一个 JavaScript 对象变为“密封”的（sealed），也就是说，在对象被密封之后，你将不能再向这个对象添加新的属性，已有的属性也不能被删除，但是你仍然可以修改已有属性的值（只要这些属性不是可写的）。</p><p>在现实中，密封一个对象可能在你想固化某个对象的结构时非常有用，确保没有其他代码可以给对象添加或移除属性，这样可以提供更稳定的接口。</p><p>现在让我们以一个简单的例子来说明<code>napi_object_seal</code>如何工作：</p><p>假设你正在开发一个 Node.js 的原生插件，你需要创建一个 JavaScript 对象并且不允许用户对这个对象进行修改。</p><p>首先，你需要包含 N-API 的头文件，并定义你的原生函数，比如<code>SealObject</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的N-API初始化方法内部的一个函数实现</span></span>
<span class="line"><span>napi_value SealObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_status status;</span></span>
<span class="line"><span>  napi_value object;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个新的空对象</span></span>
<span class="line"><span>  status = napi_create_object(env, &amp;object);</span></span>
<span class="line"><span>  if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 给对象设置一些属性</span></span>
<span class="line"><span>  napi_value value;</span></span>
<span class="line"><span>  status = napi_create_string_utf8(env, &quot;value&quot;, NAPI_AUTO_LENGTH, &amp;value);</span></span>
<span class="line"><span>  if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span>  status = napi_set_named_property(env, object, &quot;key&quot;, value);</span></span>
<span class="line"><span>  if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 密封这个对象</span></span>
<span class="line"><span>  status = napi_object_seal(env, object);</span></span>
<span class="line"><span>  if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回这个密封的对象</span></span>
<span class="line"><span>  return object;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先创建了一个新的 JavaScript 对象，然后给它设置了名为&quot;key&quot;的属性，其对应的值为&quot;value&quot;。然后通过<code>napi_object_seal</code>函数，我们将这个对象密封起来，这样在返回给 JavaScript 后，就无法再给这个对象添加新的属性了。</p><p>在你的 JavaScript 代码中，当你调用这个原生模块中的<code>SealObject</code>方法时，它会返回一个密封的对象。如果你尝试给这个对象添加新的属性，JavaScript 运行时将会抛出错误。</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myNativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> sealedObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myNativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">SealObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">sealedObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: value</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 尝试添加新的属性，将失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">sealedObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">newKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;new value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 抛出错误</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 修改现有的属性值是可以的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">sealedObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;new value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这是有效的，前提是该属性是可写的</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 尝试删除属性，将失败</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> sealedObject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 抛出错误</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，这是一个原生插件的示例，通常，你需要编译 C/C++代码成为.node 文件，然后才能在 Node.js 环境中使用它。而使用<code>napi_object_seal</code>属于较高级的操作，对于编程新手而言，理解 JavaScript 层面的对象操作可能会更加直接和容易。</p><h2 id="working-with-javascript-functions" tabindex="-1"><a class="header-anchor" href="#working-with-javascript-functions"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#working-with-javascript-functions" target="_blank" rel="noopener noreferrer">Working with JavaScript functions</a></span></a></h2><p>Node.js 中的 N-API 是一个 C 语言的 API，它允许你编写能够与 JavaScript 代码交互的本地插件。在 N-API 中“Working with JavaScript functions”通常意味着你将会使用 C 或 C++代码来调用 JavaScript 中的函数，或者创建新的 JavaScript 函数让 JavaScript 代码去调用。</p><p>这里是一些基本的操作，你可能会执行当你使用 N-API 工作时：</p><h3 id="调用-javascript-函数" tabindex="-1"><a class="header-anchor" href="#调用-javascript-函数"><span>调用 JavaScript 函数：</span></a></h3><p>当你想从 C/C++代码调用一个现有的 JavaScript 函数时，你需要先获取到这个函数的引用，然后使用适当的 N-API 函数调用它。举个例子，如果你有一个 JavaScript 函数<code>hello</code>，你想从你的 C/C++插件内部调用它，你的代码可能会像这样：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设 `napi_value js_hello_function` 是之前获取的JavaScript函数引用</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>napi_call_function(env, global, js_hello_function, 0, NULL, &amp;result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>env</code>是一个表示当前 N-API 环境的变量，而<code>global</code>是全局对象的引用。这行代码实际上就是调用了<code>hello</code>函数，并且没有传递任何参数（因为 args 数量是 0，args 数组是 NULL）。</p><h3 id="创建新的-javascript-函数" tabindex="-1"><a class="header-anchor" href="#创建新的-javascript-函数"><span>创建新的 JavaScript 函数：</span></a></h3><p>如果你想创建一个新的函数并将其暴露给 JavaScript 代码使用，你可以通过定义一个 C/C++函数，然后告诉 N-API 它应该被视为 JavaScript 函数。</p><p>这是如何完成的一个简化的例子：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 这是C函数，我们想在JavaScript中以函数形式调用</span></span>
<span class="line"><span>napi_value MyNativeFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 在这里处理函数调用</span></span>
<span class="line"><span>    return some_result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数使其在JavaScript中可用</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value my_function;</span></span>
<span class="line"><span>    napi_create_function(env, &quot;myFunction&quot;, NAPI_AUTO_LENGTH, MyNativeFunction, NULL, &amp;my_function);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将生成的函数添加到exports对象中，使其可以被JavaScript模块导出和访问</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, my_function);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码片段中，<code>MyNativeFunction</code>是 C 函数。通过调用<code>napi_create_function</code>，我们说“嘿 Node.js，请将此 C 函数视为 JavaScript 函数”，并且 Node.js 做了相应的内部连接。</p><p>现在，来自 JavaScript 世界的人可以这样调用这个函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;myAddon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 调用我们刚刚定义的函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="传递参数给-javascript-函数" tabindex="-1"><a class="header-anchor" href="#传递参数给-javascript-函数"><span>传递参数给 JavaScript 函数：</span></a></h3><p>如果你需要向 JavaScript 函数传递参数，你可以构建一个包含<code>napi_value</code>类型参数的数组，并将其传递给<code>napi_call_function</code>。</p><p>举个例子，如果你想传递一个字符串和一个数字：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value arg1, arg2;</span></span>
<span class="line"><span>napi_create_string_utf8(env, &quot;Hello&quot;, NAPI_AUTO_LENGTH, &amp;arg1);</span></span>
<span class="line"><span>napi_create_double(env, 123, &amp;arg2);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value args[] = {arg1, arg2};</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>napi_call_function(env, global, js_hello_function, 2, args, &amp;result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上只是 N-API 中与 JavaScript 函数操作相关的基础概念和例子。这些操作能够让你的本地插件与 JavaScript 代码无缝协同工作。记得每次操作都需要检查返回值，确保没有发生错误。</p><h3 id="napi-call-function" tabindex="-1"><a class="header-anchor" href="#napi-call-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_call_function" target="_blank" rel="noopener noreferrer">napi_call_function</a></span></a></h3><p><code>napi_call_function</code> 是 Node.js 中的一个 N-API 函数，它允许你在 JavaScript 环境中调用已存在的 JavaScript 函数。Node.js 的 N-API 是一个 C API，它提供了从原生代码（如 C 或 C++插件）与 JavaScript 代码进行交互的能力。</p><p>为了理解 <code>napi_call_function</code> 的作用，首先需要知道以下几点：</p><ol><li><strong>N-API</strong> （Node API）是用来构建原生插件的 API，使得你可以在不直接使用 JavaScript 但想要与 Node.js 交互的地方使用它。</li><li><strong>原生插件</strong> 是使用 C/C++等编写的模块，它们可以通过 N-API 与 Node.js 通信。</li><li><strong>JavaScript 函数调用</strong> 指的是在 JavaScript 代码中执行一个函数，并且给这个函数传递参数，当然函数本身可能会返回一些值。</li></ol><p>现在，具体到 <code>napi_call_function</code> 函数，其目的就是让你从 C/C++代码中调用 JavaScript 函数。它的基本步骤包括：</p><ul><li>确保你有一个 <code>napi_env</code> 环境变量。这个环境变量代表了一个活跃的 Node.js 环境，用于 N-API 调用。</li><li>获得一个指向 JavaScript 函数的 <code>napi_value</code> 引用。</li><li>准备你想要传递给 JavaScript 函数的参数，每个参数都是一个 <code>napi_value</code>。</li><li>使用 <code>napi_call_function</code> 来实际调用该函数，并将结果存储在另一个 <code>napi_value</code> 中。</li></ul><p>函数原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_call_function(napi_env env,</span></span>
<span class="line"><span>                               napi_value recv,</span></span>
<span class="line"><span>                               napi_value func,</span></span>
<span class="line"><span>                               size_t argc,</span></span>
<span class="line"><span>                               const napi_value* argv,</span></span>
<span class="line"><span>                               napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数描述：</p><ul><li><code>env</code>: 当前的 N-API 环境。</li><li><code>recv</code>: 这是调用函数时的 <code>this</code> 值，如果函数不是对象的方法，则可以传递 <code>undefined</code> 或全局对象。</li><li><code>func</code>: 一个引用了你想要调用的 JavaScript 函数的 <code>napi_value</code>。</li><li><code>argc</code>: 传递给函数的参数数量。</li><li><code>argv</code>: 参数列表的数组，其中每个元素都是一个 <code>napi_value</code>。</li><li><code>result</code>: 一个指向 <code>napi_value</code> 的指针，用来接收函数调用的返回值。</li></ul><p>举个简单例子，假设我们有一个 JavaScript 函数 <code>add</code> 如下:</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 C/C++中，我们想要调用这个函数并传入两个数字作为参数。以下是使用 <code>napi_call_function</code> 的大致代码示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...省略其他所需的N-API引导代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value addFunc; // 假设这是我们已经获取的JavaScript函数 &#39;add&#39; 的N-API引用</span></span>
<span class="line"><span>napi_value result;</span></span>
<span class="line"><span>napi_value args[2];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设n和m是我们想要相加的两个数字</span></span>
<span class="line"><span>double n = 1.0;</span></span>
<span class="line"><span>double m = 2.0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建两个napi_value表示我们要传递给add函数的参数</span></span>
<span class="line"><span>napi_create_double(env, n, &amp;args[0]);</span></span>
<span class="line"><span>napi_create_double(env, m, &amp;args[1]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用函数</span></span>
<span class="line"><span>napi_status status = napi_call_function(env, global, addFunc, 2, args, &amp;result);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 处理可能出现的错误</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 错误处理</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设函数执行成功，现在result变量中存储了返回值</span></span>
<span class="line"><span>double sum;</span></span>
<span class="line"><span>napi_get_value_double(env, result, &amp;sum);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// sum 现在应该等于 3.0，因为 1.0 + 2.0 = 3.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段 C/C++代码展示了如何设置参数，如何调用 JavaScript 函数，以及如何获取返回值。这只是一个非常基础的例子，实际上，在真正的原生插件开发中，你可能还需要处理很多额外的边界条件，比如异常处理等。</p><h3 id="napi-create-function" tabindex="-1"><a class="header-anchor" href="#napi-create-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_function" target="_blank" rel="noopener noreferrer">napi_create_function</a></span></a></h3><p><code>napi_create_function</code>是 Node.js 中的一个 API 函数，用于在原生模块（通常是用 C 或 C++编写的扩展）中创建一个新的 JavaScript 函数。这个 API 属于 N-API，它是一个独立于 JavaScript 运行时的接口，允许你构建可以跨不同版本的 Node.js 运行的原生插件。</p><p>N-API 旨在减少维护成本，并且通过提供与 Node.js 核心无关的稳定 API 层来提高模块的兼容性。</p><p>下面我将解释一下<code>napi_create_function</code>的使用方式，并给出一个简单的示例。</p><h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用"><span>基本使用</span></a></h3><p>当你想要在原生模块中定义一个可以从 JavaScript 代码调用的函数时，你会使用<code>napi_create_function</code>。</p><p>这个函数的基本签名如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_create_function(napi_env env,</span></span>
<span class="line"><span>                                 const char* utf8name,</span></span>
<span class="line"><span>                                 size_t length,</span></span>
<span class="line"><span>                                 napi_callback cb,</span></span>
<span class="line"><span>                                 void* data,</span></span>
<span class="line"><span>                                 napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数解释：</p><ul><li><code>env</code>: 这是一个表示 N-API 环境的句柄，它在很多 N-API 调用中都被使用。</li><li><code>utf8name</code>: 这是你想要创建的 JavaScript 函数的名称，表示为 UTF-8 编码的字符串。</li><li><code>length</code>: 这是上面名称字符串的长度，如果你传递<code>NAPI_AUTO_LENGTH</code>，则函数会自动计算长度。</li><li><code>cb</code>: 这是一个指向你的原生函数的指针，当 JavaScript 代码调用你的函数时，这个回调函数会被执行。</li><li><code>data</code>: 这是一个指向任意数据的指针，你可以将它设为 NULL 或者传递一些你的函数可能需要的数据。</li><li><code>result</code>: 这是一个指向新创建的 JavaScript 函数的指针，函数调用成功后，在此返回新函数。</li></ul><h3 id="实际运用的例子-9" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-9"><span>实际运用的例子</span></a></h3><p>假设我们想在原生模块中创建一个名为&quot;hello&quot;的函数，当从 JavaScript 调用时，它返回字符串&quot;Hello from native module!&quot;。</p><p>首先，我们定义原生函数的实现：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value HelloFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value greeting;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的字符串值，用于返回</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, &quot;Hello from native module!&quot;, NAPI_AUTO_LENGTH, &amp;greeting);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return greeting;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在模块初始化时，我们使用<code>napi_create_function</code>来创建&quot;hello&quot;函数并将其暴露给 JavaScript：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建函数</span></span>
<span class="line"><span>    status = napi_create_function(env, &quot;hello&quot;, NAPI_AUTO_LENGTH, HelloFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将创建的函数作为模块exports的属性</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;hello&quot;, fn);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当我们的原生模块被加载到 Node.js 中时，就会有一个名为&quot;hello&quot;的函数可供 JavaScript 代码调用：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/native-module.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: Hello from native module!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们展示了如何使用<code>napi_create_function</code>在原生模块中创建一个简单的函数，以及如何将该函数公开给 Node.js 环境。</p><h3 id="napi-get-cb-info" tabindex="-1"><a class="header-anchor" href="#napi-get-cb-info"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_cb_info" target="_blank" rel="noopener noreferrer">napi_get_cb_info</a></span></a></h3><p><code>napi_get_cb_info</code> 是 Node.js 中 N-API（原生 API）的一部分，旨在为构建原生插件提供一个稳定的 ABI（应用二进制接口）。这意味着使用 N-API 编写的插件不会因为 Node.js 版本的升级而需要重新编译，从而使得插件更加稳定。</p><p>具体来说，<code>napi_get_cb_info</code> 函数用于从原生扩展中的函数调用获取信息。当 JavaScript 调用一个 C/C++ 扩展模块中的函数时，你可以使用 <code>napi_get_cb_info</code> 来获取传递给该函数的参数。</p><p>这个函数的定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_cb_info(</span></span>
<span class="line"><span>    napi_env env,                // [in] 环境句柄</span></span>
<span class="line"><span>    napi_callback_info cb_info,  // [in] 回调信息</span></span>
<span class="line"><span>    size_t* argc,                // [in,out] 参数数量</span></span>
<span class="line"><span>    napi_value* argv,            // [out] 参数数组</span></span>
<span class="line"><span>    napi_value* this_arg,        // [out] this 指向的对象</span></span>
<span class="line"><span>    void** data                  // [out] 关联的数据指针</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里：</p><ul><li><code>env</code> 是表示当前执行上下文环境的句柄。</li><li><code>cb_info</code> 是一个回调信息类型的值，包含了关于当前函数调用的上下文信息。</li><li><code>argc</code> 初始时应该设置为你准备接收的参数的最大数量。函数执行完后，它将被设置为实际传递的参数数量。</li><li><code>argv</code> 是一个数组，用于接收函数的参数值。数组的大小应至少与 <code>argc</code> 的初始值一样大。</li><li><code>this_arg</code> 将被设置为调用函数时的 <code>this</code> 值。</li><li><code>data</code> 是指向与当前回调相关联的任何数据的指针。</li></ul><p>现在让我们看一个例子：</p><p>假设你正在编写一个 Node.js 的原生扩展，其中有一个函数 <code>MyFunction</code> 需要从 JavaScript 代码中获取两个参数：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// JavaScript 调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">MyFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 C++ 中，你可能会这样实现 <code>MyFunction</code>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 2;                       // 我们期望接收两个参数</span></span>
<span class="line"><span>    napi_value argv[2];                    // 创建一个数组来存储这些参数</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取函数调用的详细信息</span></span>
<span class="line"><span>    napi_status status = napi_get_cb_info(env, info, &amp;argc, argv, &amp;this_arg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否成功获取参数</span></span>
<span class="line"><span>    if (status != napi_ok || argc `&lt;` 2) {</span></span>
<span class="line"><span>        // 处理错误情况...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用参数进行计算或其他操作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果给 JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    // ... 省略创建和返回结果的代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册函数以便在 JS 中可以调用</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;MyFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>MyFunction</code> 通过 <code>napi_get_cb_info</code> 获取了 JavaScript 传递给它的两个参数。然后，你可以处理这些参数并返回某个结果。这个机制允许将 C/C++ 功能暴露给 JavaScript 代码，是构建高性能 Node.js 插件的基础。</p><h3 id="napi-get-new-target" tabindex="-1"><a class="header-anchor" href="#napi-get-new-target"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_new_target" target="_blank" rel="noopener noreferrer">napi_get_new_target</a></span></a></h3><p>Node.js 中的 N-API 是一个用 C 语言编写的底层 API，它允许你创建原生插件。这些原生插件可以直接与 Node.js 的 V8 引擎交互，提供比 JavaScript 更快的性能或访问系统资源和第三方库。</p><p><code>napi_get_new_target</code> 函数是 N-API 的一部分，它用来确定一个函数是否被当作构造函数（使用 <code>new</code> 关键字）调用。</p><p>在 JavaScript 中，你可以有两种方式调用函数：</p><ol><li>普通调用：<code>myFunction()</code></li><li>构造函数调用：<code>new MyConstructor()</code></li></ol><p>当你使用 <code>new</code> 调用函数时，JavaScript 引擎会创建一个新的对象，并将该对象作为函数执行过程中的 <code>this</code> 上下文。如果没有使用 <code>new</code>，通常 <code>this</code> 会引用到全局对象或者是 undefined（在严格模式下）。</p><p><code>napi_get_new_target</code> 允许原生插件检查一个函数是否通过 <code>new</code> 关键字被调用。如果是通过 <code>new</code> 被调用，那么它会返回一个指向新创建对象的引用；如果不是，它将返回 <code>NULL</code>。</p><p>请看一个示例，假设我们有如下的 C++ 代码作为 Node.js 插件：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value new_target;</span></span>
<span class="line"><span>    napi_status status = napi_get_new_target(env, info, &amp;new_target);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否通过 &quot;new&quot; 被调用</span></span>
<span class="line"><span>    bool is_constructor_call = (status == napi_ok &amp;&amp; new_target != nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (is_constructor_call) {</span></span>
<span class="line"><span>        // 这是一个构造函数调用</span></span>
<span class="line"><span>        // 可以继续操作 new_target</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 这是一个普通函数调用</span></span>
<span class="line"><span>        // 相应地处理这种情况...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回一个值...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个函数</span></span>
<span class="line"><span>    napi_create_function(env, nullptr, 0, MyFunction, nullptr, &amp;fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将函数暴露给模块导出</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个插件中：</p><ul><li>我们定义了一个名为 <code>MyFunction</code> 的函数，它可以用作构造函数。</li><li>在函数内部，我们使用 <code>napi_get_new_target</code> 检查它是否被当作构造函数调用。</li><li>根据是否通过 <code>new</code> 调用，我们可以决定如何处理这次函数调用。</li></ul><p>你需要在 JavaScript 中加载和使用这个插件，就像这样：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;myModule&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 使用 new 调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 不使用 new 调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在前者的情况中，<code>MyFunction</code> 内部的 <code>is_constructor_call</code> 会是 <code>true</code>，而在后者的情况中，则是 <code>false</code>。</p><p>总结起来，<code>napi_get_new_target</code> 是一个用于区分函数调用方式的工具，这在创建可以同时作为普通函数和构造函数的原生插件时非常有用。</p><h3 id="napi-new-instance" tabindex="-1"><a class="header-anchor" href="#napi-new-instance"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_new_instance" target="_blank" rel="noopener noreferrer">napi_new_instance</a></span></a></h3><p><code>napi_new_instance</code> 是 Node.js 中的一个 N-API 函数，它用于创建 JavaScript 中的新对象实例。N-API 是 Node.js 提供的一个 C API 层，使得原生模块（使用 C 或 C++编写）能够与 JavaScript 代码无缝交互，不受 Node.js 版本变化的影响。</p><p>在解释这个函数之前，让我们简单了解几个相关概念：</p><ol><li><strong>原生模块</strong>：指的是用 C 或 C++等编程语言编写并可以直接调用 Node.js 或 V8 引擎提供 API 的模块。</li><li><strong>JavaScript 实例</strong>：在 JavaScript 中，当你通过<code>new</code>关键字调用构造函数时，你会创建该构造函数的一个实例（即一个对象）。</li><li><strong>N-API</strong>：Node.js 提供的一组用 C 编写的 API，使得开发者可以构建原生插件，并保证跨 Node.js 版本的稳定性。</li></ol><p>现在，让我们详细了解<code>napi_new_instance</code>函数。</p><h3 id="napi-new-instance-1" tabindex="-1"><a class="header-anchor" href="#napi-new-instance-1"><span>napi_new_instance</span></a></h3><p>这个函数用于创建一个由原生模块定义的构造函数的新实例。例如，如果你有一个 C++类并且想要从 JavaScript 代码中创建它的实例，就可以使用<code>napi_new_instance</code>来做到这一点。</p><h4 id="函数签名-8" tabindex="-1"><a class="header-anchor" href="#函数签名-8"><span>函数签名</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_new_instance(napi_env env,</span></span>
<span class="line"><span>                              napi_value constructor,</span></span>
<span class="line"><span>                              size_t argc,</span></span>
<span class="line"><span>                              const napi_value* argv,</span></span>
<span class="line"><span>                              napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 当前的 N-API 环境句柄。</li><li><code>constructor</code>: JavaScript 中的函数，通常是你想要实例化的构造函数。</li><li><code>argc</code>: 传递给构造函数的参数数量。</li><li><code>argv</code>: 指向传递给构造函数的参数数组的指针。</li><li><code>result</code>: 此函数调用完成后，将创建的新实例的句柄写入此位置。</li></ul><h4 id="返回值-10" tabindex="-1"><a class="header-anchor" href="#返回值-10"><span>返回值</span></a></h4><p>返回<code>napi_status</code>，这表明函数调用成功还是失败。如果成功，新创建的实例将被赋值给<code>result</code>参数。</p><h4 id="实际运用示例-4" tabindex="-1"><a class="header-anchor" href="#实际运用示例-4"><span>实际运用示例</span></a></h4><p>假设你有一个 C++类叫<code>MyObject</code>，它有一个构造函数可以接收一个整数。你希望在 Node.js 中创建<code>MyObject</code>的实例，并传递一个数字作为参数。</p><p>首先，你会创建一个 N-API 的包装器，以便 JavaScript 可以调用它：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// C++ 端的 MyObject 类</span></span>
<span class="line"><span>class MyObject {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    MyObject(int value) : value_(value) {}</span></span>
<span class="line"><span>    int GetValue() const { return value_; }</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    int value_;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 包装器函数，JavaScript 中可以调用它来创建 MyObject 实例</span></span>
<span class="line"><span>napi_value CreateMyObjectInstance(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value thisArg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript调用时传递的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;thisArg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们已经有了一个指向MyObject构造函数的napi_value &#39;constructor&#39;</span></span>
<span class="line"><span>    napi_value instance;</span></span>
<span class="line"><span>    napi_status status = napi_new_instance(env, constructor, argc, args, &amp;instance);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return instance; // 返回新创建的MyObject实例</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在 JavaScript 中，你可以这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;native-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 加载原生模块</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> myObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createMyObjectInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 创建一个MyObject实例</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>createMyObjectInstance</code>会对应于 C++端的<code>CreateMyObjectInstance</code>函数。当你从 JavaScript 调用这个函数时，它会使用给定的参数（在这里是数字 42）创建一个新的<code>MyObject</code>实例。</p><h2 id="object-wrap" tabindex="-1"><a class="header-anchor" href="#object-wrap"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#object-wrap" target="_blank" rel="noopener noreferrer">Object wrap</a></span></a></h2><p>Node.js 中的<code>Object Wrap</code>是指使用 N-API（一组 C 语言 API）来绑定 C++对象与 JavaScript 对象。它允许你创建一个 C++对象，并在 JavaScript 代码中操作这个对象，就好像它是一个普通的 JavaScript 对象一样。</p><p>在 Node.js 中创建扩展的时候，我们可能需要从 JavaScript 调用 C++代码以利用其性能优势或者访问系统资源。但因为 JavaScript 和 C++是两种不同的编程语言，直接交互并非易事。为此，Node.js 提供了 N-API 这样的桥梁，使得这两种语言能够互相沟通。</p><h3 id="object-wrap-的基本原理" tabindex="-1"><a class="header-anchor" href="#object-wrap-的基本原理"><span>Object Wrap 的基本原理：</span></a></h3><ol><li><strong>C++侧创建类</strong>：首先在 C++侧定义一个类，并且为这个类定义构造函数、析构函数和一些方法。</li><li><strong>包装 C++对象</strong>：然后通过 Object Wrap 将这个 C++类的实例关联到一个新建的 JavaScript 对象上。</li><li><strong>在 JavaScript 中调用</strong>：JavaScript 代码可以创建和使用这个对象，调用其方法，而实际上运行的是 C++代码。</li></ol><h3 id="举例说明-1" tabindex="-1"><a class="header-anchor" href="#举例说明-1"><span>举例说明：</span></a></h3><p>假设我们要在 Node.js 中创建一个简单的 C++ <code>Counter</code> 类，该类有增加（<code>increment</code>）、减少（<code>decrement</code>）和获取值（<code>getValue</code>）的功能。</p><ol><li><strong>定义 C++类</strong>:</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`napi.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Counter : public Napi::ObjectWrap`&lt;`Counter&gt; {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    static Napi::Object Init(Napi::Env env, Napi::Object exports); // 初始化函数</span></span>
<span class="line"><span>    Counter(const Napi::CallbackInfo&amp; info); // 构造函数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    static Napi::FunctionReference constructor; // 构造函数引用</span></span>
<span class="line"><span>    double value_; // 私有变量，计数器的值</span></span>
<span class="line"><span>    Napi::Value Increment(const Napi::CallbackInfo&amp; info); // 实现增加</span></span>
<span class="line"><span>    Napi::Value Decrement(const Napi::CallbackInfo&amp; info); // 实现减少</span></span>
<span class="line"><span>    Napi::Value GetValue(const Napi::CallbackInfo&amp; info); // 获取当前值</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>实现方法</strong>:</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 此处省略包装方法初始化和构造函数的具体实现</span></span>
<span class="line"><span>//...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Value Counter::Increment(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>    value_ += 1;</span></span>
<span class="line"><span>    return Napi::Number::New(info.Env(), value_);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Value Counter::Decrement(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>    value_ -= 1;</span></span>
<span class="line"><span>    return Napi::Number::New(info.Env(), value_);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Napi::Value Counter::GetValue(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>    return Napi::Number::New(info.Env(), value_);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>创建和导出模块</strong>:</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Napi::Object Init(Napi::Env env, Napi::Object exports) {</span></span>
<span class="line"><span>    Counter::Init(env, exports);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>在 JavaScript 中使用</strong>:</li></ol><p>以上 C++代码编译成 Node.js 扩展后，你可以在 JavaScript 中这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> counterAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/counter-addon.node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myCounter</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> counterAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">increment</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">decrement</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">myCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们创建了一个 C++的<code>Counter</code>类，并且它有三个方法。当我们在 JavaScript 中调用这些方法时，实际上是在 C++层面执行相关操作的。通过这种方式，我们可以利用 C++的性能和特性来扩展 Node.js 的功能。</p><p>记住，N-API 是稳定的跨版本的 API 集合，意味着用它写的扩展可以在未来的 Node.js 版本中无需重新编译。这使得维护和升级 Node.js 扩展变得更加容易。</p><h3 id="napi-define-class" tabindex="-1"><a class="header-anchor" href="#napi-define-class"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_define_class" target="_blank" rel="noopener noreferrer">napi_define_class</a></span></a></h3><p><code>napi_define_class</code> 是 Node.js 中 N-API（原生 API）的一部分，它让你能够创建和定义一个新的 JavaScript 类，该类可以链接到 C 或者 C++ 的代码。这样做的好处是你可以在 Node.js 中使用性能更高、更接近硬件层面的编程语言写的代码。</p><p>当我们说“定义一个类”时，指的是在 JavaScript 中创建一个可以被实例化（即创建具体对象）的蓝图。这个类可以有自己的属性（properties）和方法（methods），就像其他任何 JavaScript 类一样。</p><p>下面我们来详细解释一下 <code>napi_define_class</code> 函数，并举几个例子来说明它的运用。</p><p>首先，这个函数的基本形式是：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_define_class(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    const char* utf8name,</span></span>
<span class="line"><span>    size_t length,</span></span>
<span class="line"><span>    napi_callback constructor,</span></span>
<span class="line"><span>    void* data,</span></span>
<span class="line"><span>    size_t property_count,</span></span>
<span class="line"><span>    const napi_property_descriptor* properties,</span></span>
<span class="line"><span>    napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里各个参数的含义是：</p><ul><li><code>env</code>: 当前的 N-API 环境句柄。</li><li><code>utf8name</code>: 新类的名称，它是一个 UTF-8 编码的字符串。</li><li><code>length</code>: 这个名称的长度，如果是以 null 结尾的字符串，则可以传递 <code>NAPI_AUTO_LENGTH</code>。</li><li><code>constructor</code>: 一个指向构造函数的指针，这个构造函数会在你通过 <code>new</code> 关键字创建类的实例时调用。</li><li><code>data</code>: 可选的数据，可以和构造函数一起传递，通常用于保存构造函数需要的状态或信息。</li><li><code>property_count</code>: 类属性的数量。</li><li><code>properties</code>: 类属性描述符数组，每个属性都对应一个 <code>napi_property_descriptor</code> 结构体，用于定义属性的名字、属性存在的位置、以及属性的访问器等。</li><li><code>result</code>: 这个函数执行完毕后，存放结果的地方，通常是新定义类的引用。</li></ul><p>现在，让我们看一个简单的例子：</p><p>想象一下，我们要在 Node.js 中创建一个原生扩展，表示一个简单的 &quot;Rectangle&quot; （矩形）类。这个类将拥有长度和宽度作为属性，并且有一个方法来计算面积。</p><p>在 C/C++ 代码中，你可能会这样定义 Rectangle 类：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 构造函数</span></span>
<span class="line"><span>napi_value RectangleConstructor(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // ... 创建和初始化 Rectangle 对象 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 计算面积的方法</span></span>
<span class="line"><span>napi_value CalculateArea(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // ... 计算面积的代码 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，用于创建类和导出相关功能</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 属性描述符：length 和 width</span></span>
<span class="line"><span>    napi_property_descriptor properties[] = {</span></span>
<span class="line"><span>        { &quot;length&quot;, 0, 0, 0, 0, 0, napi_default, 0 },</span></span>
<span class="line"><span>        { &quot;width&quot;, 0, 0, 0, 0, 0, napi_default, 0 }</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 定义 Rectangle 类</span></span>
<span class="line"><span>    napi_value rectangle_class;</span></span>
<span class="line"><span>    status = napi_define_class(env, &quot;Rectangle&quot;, NAPI_AUTO_LENGTH, RectangleConstructor, nullptr, 2, properties, &amp;rectangle_class);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 Rectangle 类导出给 JavaScript 使用</span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        status = napi_set_named_property(env, exports, &quot;Rectangle&quot;, rectangle_class);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码为了简洁并未包含完整的错误处理和实际的属性/方法实现细节，但它展示了如何使用 <code>napi_define_class</code> 来创建一个新的类。在实际应用中，你需要实现构造函数、面积计算方法，并确保所有的属性和方法都正确关联到对应的 C/C++ 函数。</p><p>最后，当你编译并加载了这个扩展之后，在 Node.js 中可以这样使用：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myNativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my-native-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Rectangle</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myNativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> rect</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">width</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">rect</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">CalculateArea</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出矩形的面积</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是 <code>napi_define_class</code> 在 Node.js v21.7.1 版本中的作用和一个基础的示例。</p><h3 id="napi-wrap" tabindex="-1"><a class="header-anchor" href="#napi-wrap"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_wrap" target="_blank" rel="noopener noreferrer">napi_wrap</a></span></a></h3><p>好的，让我们来谈谈 Node.js 中的 <code>napi_wrap</code>。</p><p>在 Node.js 中，<code>N-API</code>（Node.js API）是一个低层次的 API，它允许你编写本地插件，即用 C 或者 C++ 等语言编写的模块。这些本地插件可以直接操作 JavaScript 值和对象，以及与 JavaScript 代码交互。</p><p><code>napi_wrap</code> 是 N-API 所提供的一个函数，它的作用是将一个 JavaScript 对象与一个本地对象（通常是用 C/C++ 编写的对象）关联起来。通过这种关联，你可以在本地代码中保存私有数据，并且确保当 JavaScript 对象被垃圾回收时，相关的本地资源也能得到清理。</p><p>现在让我们详细了解一下 <code>napi_wrap</code> 的参数和使用方法：</p><h3 id="函数原型-3" tabindex="-1"><a class="header-anchor" href="#函数原型-3"><span>函数原型</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_wrap(</span></span>
<span class="line"><span>    napi_env env,</span></span>
<span class="line"><span>    napi_value js_object,</span></span>
<span class="line"><span>    void* native_object,</span></span>
<span class="line"><span>    napi_finalize finalize_cb,</span></span>
<span class="line"><span>    void* finalize_hint,</span></span>
<span class="line"><span>    napi_ref* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是表示当前执行环境的 <code>napi_env</code> 句柄。</li><li><code>js_object</code>: 这是要关联本地对象的 JavaScript 对象。</li><li><code>native_object</code>: 这是要附加到 JavaScript 对象上的本地对象的指针。</li><li><code>finalize_cb</code>: 当 JavaScript 对象被垃圾回收时调用的回调函数，用来清理 <code>native_object</code>。</li><li><code>finalize_hint</code>: 传递给 <code>finalize_cb</code> 回调的可选数据。</li><li><code>result</code>: 返回创建的引用，这是一个可选参数。</li></ul><h3 id="使用场景-2" tabindex="-1"><a class="header-anchor" href="#使用场景-2"><span>使用场景</span></a></h3><p>假设你想创建一个 JavaScript 类，称为 <code>MyNativeObject</code>，它背后有一个 C++ 类 <code>NativeObject</code> 提供支持。你可能会这样使用 <code>napi_wrap</code>:</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是你的 C++ 对象的类</span></span>
<span class="line"><span>class NativeObject {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    // 构造函数、析构函数和其他方法</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当 JS 对象被回收时需要调用的清理函数</span></span>
<span class="line"><span>void FinalizeCallback(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    // 转换 finalize_data 为 NativeObject 指针并删除它</span></span>
<span class="line"><span>    NativeObject* obj = static_cast`&lt;`NativeObject*&gt;(finalize_data);</span></span>
<span class="line"><span>    delete obj;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建新的 MyNativeObject 实例的函数</span></span>
<span class="line"><span>napi_value CreateMyNativeObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 从 JavaScript 端接收的参数等</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    status = napi_get_cb_info(env, info, &amp;argc, args, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建你的 C++ 对象</span></span>
<span class="line"><span>    NativeObject* obj = new NativeObject();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个新的空 JavaScript 对象</span></span>
<span class="line"><span>    napi_value js_object;</span></span>
<span class="line"><span>    status = napi_create_object(env, &amp;js_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将你的本地对象与 JavaScript 对象关联起来</span></span>
<span class="line"><span>    status = napi_wrap(env, js_object, obj, FinalizeCallback, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回新创建的 JavaScript 对象</span></span>
<span class="line"><span>    return js_object;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，设置 MyNativeObject</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置 CreateMyNativeObject 为导出函数</span></span>
<span class="line"><span>    napi_value new_function;</span></span>
<span class="line"><span>    status = napi_create_function(env, &quot;&quot;, NAPI_AUTO_LENGTH, CreateMyNativeObject, nullptr, &amp;new_function);</span></span>
<span class="line"><span>    status = napi_set_named_property(env, exports, &quot;createMyNativeObject&quot;, new_function);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 定义模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 <code>napi_wrap</code> 的一个实际应用示例，在这个例子中我们定义了一个 C++ 类 <code>NativeObject</code> 并在 JavaScript 环境中创建了一个对应的类 <code>MyNativeObject</code>。每当在 JavaScript 中创建 <code>MyNativeObject</code> 的实例时，都会在底层创建一个 <code>NativeObject</code> 实例并将其与 JavaScript 对象关联起来。当 JavaScript 对象被垃圾回收时，<code>FinalizeCallback</code> 函数会被调用，它将负责清理 C++ 对象，防止内存泄露。</p><h3 id="napi-unwrap" tabindex="-1"><a class="header-anchor" href="#napi-unwrap"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_unwrap" target="_blank" rel="noopener noreferrer">napi_unwrap</a></span></a></h3><p><code>napi_unwrap</code>是 Node.js 中 N-API（Node API）的一个函数，它使得原生模块开发人员能够把 JavaScript 对象与 C/C++的原生对象相关联并且管理这种关联。换句话说，你可以在一个 JavaScript 对象中隐藏一个指向 C/C++对象的指针，并且当需要时，再从 JavaScript 对象中检索出这个指针。这种技术经常用于创建和维护 JavaScript 对象与 C/C++资源之间的联系。</p><p>使用<code>napi_unwrap</code>的典型场景涉及以下步骤：</p><ol><li>使用<code>napi_wrap</code>将一个 C/C++对象（通常是一个类的实例）与一个新创建的或者已有的 JavaScript 对象关联起来。</li><li>在 JavaScript 代码执行期间，当需要访问这个 C/C++对象时，可以调用<code>napi_unwrap</code>来获取之前存储的指针。</li><li>使用这个指针，你可以在原生代码中操作对应的 C/C++对象。</li></ol><p>下面是一个简化的例子，说明了如何使用<code>napi_unwrap</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设你有一个C++类 MyObject</span></span>
<span class="line"><span>class MyObject {</span></span>
<span class="line"><span>  public:</span></span>
<span class="line"><span>    void DoSomething() {</span></span>
<span class="line"><span>      // ... 实际的操作 ...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是一个N-API函数，它将JavaScript对象与C++对象关联起来</span></span>
<span class="line"><span>napi_value CreateMyObject(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 创建一个C++对象</span></span>
<span class="line"><span>  MyObject* obj = new MyObject();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 获取JavaScript上下文和传递给函数的参数（如果有的话）</span></span>
<span class="line"><span>  size_t argc = 0;</span></span>
<span class="line"><span>  napi_value thisArg;</span></span>
<span class="line"><span>  napi_get_cb_info(env, info, &amp;argc, nullptr, &amp;thisArg, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将C++对象与JavaScript对象关联起来</span></span>
<span class="line"><span>  napi_wrap(env, thisArg, obj, MyObjectFinalizer, nullptr, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回JavaScript对象</span></span>
<span class="line"><span>  return thisArg;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这部分展示了如何在另一个函数中解析出C++对象</span></span>
<span class="line"><span>napi_value CallDoSomething(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  size_t argc = 0;</span></span>
<span class="line"><span>  napi_value thisArg;</span></span>
<span class="line"><span>  napi_get_cb_info(env, info, &amp;argc, nullptr, &amp;thisArg, nullptr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 解析出C++对象</span></span>
<span class="line"><span>  MyObject* obj;</span></span>
<span class="line"><span>  napi_unwrap(env, thisArg, reinterpret_cast`&lt;`void**&gt;(&amp;obj));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用C++对象的方法</span></span>
<span class="line"><span>  obj-&gt;DoSomething();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回undefined，因为这个函数不需要返回值</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，假设我们有一个叫作<code>MyObject</code>的 C++类，其中包含了一个方法<code>DoSomething</code>。我们想要让 JavaScript 代码能够创建这个类的实例，并且调用其<code>DoSomething</code>方法。</p><ul><li>在<code>CreateMyObject</code>函数中，我们创建了一个<code>MyObject</code>的实例，并使用<code>napi_wrap</code>将其与 JavaScript 的<code>thisArg</code>对象关联。</li><li>然后，在<code>CallDoSomething</code>函数中，我们使用<code>napi_unwrap</code>从<code>thisArg</code>中取回之前存储的<code>MyObject</code>实例的指针，然后调用其<code>DoSomething</code>方法。</li></ul><p>注意这里只是展示了如何使用这两个 API，详细实现会涉及错误处理、资源清理等其他考虑。</p><p>重要的是要记住，<code>napi_wrap</code>和<code>napi_unwrap</code>主要被用于管理 JavaScript 对象和 C/C++资源之间的生命周期和关系。 结合使用这两个函数，可以确保当 JavaScript 对象被垃圾回收时，相应的 C/C++资源也得到适当的释放。</p><h3 id="napi-remove-wrap" tabindex="-1"><a class="header-anchor" href="#napi-remove-wrap"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_remove_wrap" target="_blank" rel="noopener noreferrer">napi_remove_wrap</a></span></a></h3><p>Node.js 中的 N-API 是一个底层的 API，使得你可以用 C 或者 C++ 编写扩展。这些扩展可以和 Node.js 进行交互，让你能够以非常高效的方式执行一些不能或不方便直接用 JavaScript 实现的任务。</p><p><code>napi_remove_wrap</code> 是 N-API 的一个函数，它的作用是移除之前使用 <code>napi_wrap</code> 对一个 JavaScript 对象所附加的原生（native）指针。在详细解释这个概念之前，我们需要先理解几个和 N-API 相关的概念：</p><ol><li><strong>Native 指针（原生指针）</strong>: 这通常是一个指向 C/C++ 数据结构的指针。</li><li><strong>Wrap（包裹）</strong>: 在 N-API 中，“包裹”一个对象是指将一个 Native 指针和一个 JavaScript 对象相关联。这样做可以让 JavaScript 对象与 C/C++ 代码共享状态。</li><li><strong>Unwrap（解包）</strong>: 解包则是取回之前包裹的原生指针。</li></ol><p>现在，来看<code>napi_remove_wrap</code>这个函数。当你在 JavaScript 和 C/C++ 混合编程时，你可能会创建一些复杂的对象，这些对象在 JavaScript 层面上看起来只是普通的对象，但实际上它们背后有着 C/C++ 的原生资源（比如内存、文件描述符等）。通过 <code>napi_wrap</code> 函数，你可以将这些原生资源和 JavaScript 对象关联起来，这称为“包裹”。</p><p>然而，有时候你希望释放这些原生资源，例如，当对象不再需要时，或者你想重新分配资源到另一个对象上。这时候就需要用到<code>napi_remove_wrap</code>。调用<code>napi_remove_wrap</code>会做两件事情：</p><ol><li>它会移除 JavaScript 对象和原生指针之间的关联。</li><li>它允许你获取那个原生指针，这样你就可以适当地管理它，比如释放它占用的内存。</li></ol><h3 id="例子-3" tabindex="-1"><a class="header-anchor" href="#例子-3"><span>例子</span></a></h3><p>假设我们有一个 C++ 类 <code>MyObject</code>，并且我们想要从 JavaScript 访问它的实例。我们首先会用 <code>napi_wrap</code> 将 <code>MyObject</code> 的实例（原生指针）包裹到一个新的 JavaScript 对象中。稍后，如果我们想删除该对象，并且清理后台的 C++ 资源，我们会使用 <code>napi_remove_wrap</code> 来取得原生指针，然后删除它。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class MyObject {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    MyObject() { /* 构造函数逻辑 */ }</span></span>
<span class="line"><span>    ~MyObject() { /* 析构函数逻辑，负责释放资源 */ }</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 包裹 MyObject 实例到一个 JavaScript 对象</span></span>
<span class="line"><span>napi_status WrapMyObject(napi_env env, MyObject* obj, napi_value jsObj) {</span></span>
<span class="line"><span>    return napi_wrap(env, jsObj, obj, MyObject::Destructor, nullptr, nullptr);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 之后某个时间，我们想要移除包裹并且清理资源</span></span>
<span class="line"><span>napi_status RemoveWrapMyObject(napi_env env, napi_value jsObj) {</span></span>
<span class="line"><span>    MyObject* obj;</span></span>
<span class="line"><span>    napi_status status = napi_remove_wrap(env, jsObj, reinterpret_cast`&lt;`void**&gt;(&amp;obj));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        delete obj; // 调用 MyObject 的析构函数来清理</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return status;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请记住，以上的例子只是一个简化的演示，实际当中处理错误情况和生命周期管理会更加复杂。此外，在 Node.js 项目中直接编辑 C++ 代码并不常见，因为 Node.js 的核心优势在于其事件驱动和非阻塞的 I/O 模型，并且大多数常见任务都可以直接用 JavaScript 完成。不过，了解这些能力对于性能优化和编写更复杂的扩展可能是很有帮助的。</p><h3 id="napi-type-tag-object" tabindex="-1"><a class="header-anchor" href="#napi-type-tag-object"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_type_tag_object" target="_blank" rel="noopener noreferrer">napi_type_tag_object</a></span></a></h3><p>当然，我会尽量用简单易懂的语言来解释。<code>napi_type_tag_object</code> 是 Node.js 中 N-API（原生 API）的一部分，它允许你在 JavaScript 与原生 C/C++ 插件之间安全地传递对象。</p><p>为了理解 <code>napi_type_tag_object</code> 的作用，首先需要明白在 Node.js 中，JavaScript 代码可以调用 C/C++ 编写的原生模块，这个过程涉及到数据类型的转换。因为 JavaScript 和 C/C++ 使用不同的类型系统，所以在它们之间传递复杂的数据（比如对象）时，我们需要确保传递的是正确的类型，防止发生意外的行为或者安全问题。</p><p><code>napi_type_tag_object</code> 就是用来帮助标识和验证对象类型的。通过给对象添加一个唯一的“类型标签”，你可以在后续的代码中检查传入的对象是否拥有正确的类型标签，这样就可以确认它是从预期的源头传入的，而不是其他可能造成问题的对象。</p><p>来举几个例子：</p><p>假设你有一个原生的 C/C++插件，它提供了一个函数来创建一个特定类型的对象，比如表示一个网络连接的对象。你可以使用<code>napi_type_tag_object</code>来标记这个对象：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value connection_object;</span></span>
<span class="line"><span>napi_create_object(env, &amp;connection_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个唯一的类型标签</span></span>
<span class="line"><span>napi_type_tag type_tag;</span></span>
<span class="line"><span>napi_create_type_tag(env, &amp;type_tag);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 将类型标签附加到刚刚创建的对象上</span></span>
<span class="line"><span>napi_type_tag_object(env, connection_object, &amp;type_tag);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在另一个函数中，你可能想操作这个网络连接对象。但是你需要确保传进来的对象确实是一个网络连接对象，而不是随便哪个 JS 对象：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status = napi_check_object_type_tag(env, args[0], &amp;type_tag, &amp;matches);</span></span>
<span class="line"><span>if (status == napi_ok &amp;&amp; matches) {</span></span>
<span class="line"><span>    // 确认 args[0] 就是我们预期的那种网络连接对象</span></span>
<span class="line"><span>    // 可以安全地进行进一步的操作</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>    // 抛出错误，告诉调用者传入的不是有效的网络连接对象</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，即使 JavaScript 用户尝试传入一个普通的 JavaScript 对象来欺骗你的插件，由于没有匹配的类型标签，你的插件能识别并拒绝这种错误的使用方式，保护了代码的安全性。</p><p>总结一下，<code>napi_type_tag_object</code> 是 Node.js N-API 提供的一个功能，用于原生模块开发中更安全地处理和验证 JavaScript 对象。通过给对象添加和校验类型标签，程序员可以确保他们的原生函数只处理那些被标记为正确类型的对象，避免了潜在的类型错误和安全问题。</p><h3 id="napi-check-object-type-tag" tabindex="-1"><a class="header-anchor" href="#napi-check-object-type-tag"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_check_object_type_tag" target="_blank" rel="noopener noreferrer">napi_check_object_type_tag</a></span></a></h3><p>好的，Node.js 中的 N-API 是一个用于创建本地插件的 API，它允许你在 Node.js 环境中使用 C 或 C++ 代码。通过 N-API，开发者可以编写能够与 JavaScript 代码互操作的高性能本地模块。</p><p><code>napi_check_object_type_tag</code> 是 N-API 中的一个函数，其作用是帮助你验证一个 JavaScript 对象是否拥有一个特定的标记（tag）。在这里，“标记”是一个唯一标识符，用以区分不同类型的对象，确保你处理的是正确类型的对象。</p><h3 id="函数原型-4" tabindex="-1"><a class="header-anchor" href="#函数原型-4"><span>函数原型：</span></a></h3><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_check_object_type_tag(napi_env env,</span></span>
<span class="line"><span>                                       napi_value object,</span></span>
<span class="line"><span>                                       const napi_type_tag* type_tag,</span></span>
<span class="line"><span>                                       bool* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>napi_env env</code>: 当前的 N-API 环境句柄。</li><li><code>napi_value object</code>: 待检查的 JavaScript 对象。</li><li><code>const napi_type_tag* type_tag</code>: 指向你之前定义的 <code>napi_type_tag</code> 结构体的指针。</li><li><code>bool* result</code>: 函数执行后，通过这个指针返回检查结果（<code>true</code> 或 <code>false</code>）。</li></ul><h3 id="使用场景-3" tabindex="-1"><a class="header-anchor" href="#使用场景-3"><span>使用场景：</span></a></h3><p>假设你正在编写一个本地模块，该模块提供了一个自定义的文件读取器，你希望确保用户传递给你的对象是你认可的“文件读取器对象”。</p><p>首先，你会在你的模块初始化时为你的“文件读取器对象”定义一个 <code>napi_type_tag</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_type_tag file_reader_type_tag = {0};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当创建新的“文件读取器对象”时，你会将这个标记和对象关联起来：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value create_file_reader(napi_env env) {</span></span>
<span class="line"><span>    // 创建对象...</span></span>
<span class="line"><span>    napi_value file_reader;</span></span>
<span class="line"><span>    // ...创建对象的代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 关联标记到对象上</span></span>
<span class="line"><span>    napi_status status = napi_type_tag_object(env, file_reader, &amp;file_reader_type_tag);</span></span>
<span class="line"><span>    // 处理状态代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return file_reader;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，当要在另一个函数中使用这个对象时，你可以使用 <code>napi_check_object_type_tag</code> 来验证对象是否是一个有效的“文件读取器对象”：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status read_file(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_value this_arg;</span></span>
<span class="line"><span>    void* data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript提供的参数</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, &amp;this_arg, &amp;data);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查传入的对象是否是我们期待的文件读取器对象</span></span>
<span class="line"><span>    bool is_file_reader;</span></span>
<span class="line"><span>    napi_check_object_type_tag(env, args[0], &amp;file_reader_type_tag, &amp;is_file_reader);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (!is_file_reader) {</span></span>
<span class="line"><span>        // 如果不是，抛出错误或进行其他处理...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 是文件读取器对象，继续执行读取文件的操作...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 <code>napi_check_object_type_tag</code> 的基本用法。注意，这种类型检查主要用于增强本地模块的安全性和健壮性，以确保 API 的使用者按照预期传递了正确类型的对象。</p><h3 id="napi-add-finalizer" tabindex="-1"><a class="header-anchor" href="#napi-add-finalizer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_add_finalizer" target="_blank" rel="noopener noreferrer">napi_add_finalizer</a></span></a></h3><p>Node.js 中的 <code>napi_add_finalizer</code> 函数是一个属于 N-API 的 API，用来添加与一个 JavaScript 对象相关联的本地资源的终结器（或称为析构函数）。当这个 JavaScript 对象被垃圾回收时，会自动调用这个终结器函数来清理与之关联的本地资源。</p><p>N-API 是 Node.js 提供的一套 C API，它允许原生模块的作者编写独立于 Node.js 版本的代码。使用 N-API 创建的原生模块可以在不同版本的 Node.js 之间无需重新编译就能运行，大大提高了模块的兼容性和稳定性。</p><p>先解释几个概念：</p><ol><li><strong>JavaScript 对象</strong>：在 JavaScript 中创建的对象，可以存储数据和功能。</li><li><strong>本地资源</strong>：使用 C 或 C++ 等语言分配的资源，如内存、文件句柄或其他系统资源。</li><li><strong>终结器（Finalizer）</strong>：一个特殊的函数，它被设计为在对象不再需要时执行，用于释放对象所占用的资源。</li></ol><p>现在，我们来看看 <code>napi_add_finalizer</code> 的作用以及如何使用它。</p><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用:</span></a></h3><p><code>napi_add_finalizer</code> 的主要作用是确保当一个与原生资源相关联的 JavaScript 对象被垃圾回收时，这些原生资源也得到适当的清理和释放，防止内存泄漏等问题。</p><h3 id="使用场景示例" tabindex="-1"><a class="header-anchor" href="#使用场景示例"><span>使用场景示例:</span></a></h3><h4 id="示例-1-清理动态分配的内存" tabindex="-1"><a class="header-anchor" href="#示例-1-清理动态分配的内存"><span>示例 1: 清理动态分配的内存</span></a></h4><p>假设你在创建一个原生模块，这个模块需要在 C++ 中分配一块动态内存给一个 JavaScript 对象使用。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void* dynamicMemory;</span></span>
<span class="line"><span>size_t memorySize = 1024; // 假设我们要分配 1024 字节</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 分配内存</span></span>
<span class="line"><span>dynamicMemory = malloc(memorySize);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这里你可能会把 dynamicMemory 传递到 JavaScript 层面的某个对象中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了确保当 JavaScript 对象不再使用时，这块内存能够被正确地释放，你需要定义一个终结器函数：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void finalize_callback(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    // 清理动态分配的内存</span></span>
<span class="line"><span>    free(finalize_data);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你会使用 <code>napi_add_finalizer</code> 将这个终结器函数关联到相应的 JavaScript 对象上：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value jsObject;</span></span>
<span class="line"><span>// ... 创建或获取一个 jsObject ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 添加终结器</span></span>
<span class="line"><span>napi_add_finalizer(env, jsObject, dynamicMemory, finalize_callback, nullptr, nullptr);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>jsObject</code> 被垃圾回收器回收时，<code>finalize_callback</code> 函数将被自动调用，从而释放之前分配的内存。</p><h4 id="示例-2-清理打开的文件描述符" tabindex="-1"><a class="header-anchor" href="#示例-2-清理打开的文件描述符"><span>示例 2: 清理打开的文件描述符</span></a></h4><p>如果你的模块打开了文件，并且将文件描述符保存在了一个 JavaScript 对象中，你同样需要确保文件最终被关闭。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>int fileDescriptor = open(&quot;somefile.txt&quot;, O_RDONLY);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 fileDescriptor 被保存到了某个 jsObject 中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你需要定义一个适当的终结器来关闭这个文件描述符：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void finalize_file_descriptor(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>    int fd = *(int*)finalize_data;</span></span>
<span class="line"><span>    close(fd); // 关闭文件描述符</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，如同内存的例子那样，使用 <code>napi_add_finalizer</code> 关联终结器：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 添加终结器</span></span>
<span class="line"><span>napi_add_finalizer(env, jsObject, &amp;fileDescriptor, finalize_file_descriptor, nullptr, nullptr);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，当包含文件描述符的 JavaScript 对象被回收时，<code>finalize_file_descriptor</code> 将被调用，文件将被关闭，避免了文件描述符泄漏。</p><h3 id="注意事项-3" tabindex="-1"><a class="header-anchor" href="#注意事项-3"><span>注意事项:</span></a></h3><ul><li>当使用 <code>napi_add_finalizer</code> 时，你需要确保正确地管理本地资源的生命周期，确保不会在资源被清理后尝试访问它们。</li><li>使用 N-API 需要对 C/C++ 和 Node.js 的内部机制有一定的理解。</li></ul><p>希望这个解释有助于你理解 <code>napi_add_finalizer</code> 在 Node.js 中的作用和使用方式。</p><h4 id="node-api-post-finalizer" tabindex="-1"><a class="header-anchor" href="#node-api-post-finalizer"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_post_finalizer" target="_blank" rel="noopener noreferrer">node_api_post_finalizer</a></span></a></h4><p><code>node_api_post_finalizer</code> 是 Node.js 中的 N-API（原生 API）功能，它允许开发者在创建和使用原生扩展时，确保资源能够被妥善清理。为了解释这个概念，我们需要先了解一些背景知识。</p><p>在 Node.js 中，你可以编写 JavaScript 来执行各种任务，但有时候你可能需要更直接地访问底层系统资源或者进行更高性能的操作。这时，你就可以通过编写 C 或 C++ 的代码来创建所谓的“原生模块”，这样就能在 Node.js 项目中使用这些底层能力。</p><p>当使用这些原生模块时，经常会在原生代码中分配一些系统资源，比如内存、文件描述符或网络套接字等。正确地管理这些资源非常关键，因为如果不适当地释放资源，就可能导致内存泄漏或其他问题，影响应用程序的性能和稳定性。</p><p>这里的 <code>node_api_post_finalizer</code> 就是一个帮助函数，它使得开发者能够注册一个“终结器”（finalizer），也就是当一个原生对象即将被垃圾回收时将调用的函数。这个终结器负责清理与原生对象相关联的资源。</p><p>下面我举一个实际例子来说明如何使用 <code>node_api_post_finalizer</code>：</p><p>假设你在创建一个原生模块，该模块需要打开一个文件，并在操作完毕后关闭文件。在这个过程中，你会在原生代码中创建一个表示文件的对象，并且希望在这个对象不再需要时自动关闭文件。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设这是我们的原生对象结构体</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  FILE* file;</span></span>
<span class="line"><span>} MyFileHandle;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是我们的终结器函数</span></span>
<span class="line"><span>void Finalizer(napi_env env, void* finalize_data, void* finalize_hint) {</span></span>
<span class="line"><span>  MyFileHandle* handle = (MyFileHandle*)finalize_data;</span></span>
<span class="line"><span>  fclose(handle-&gt;file); // 关闭文件</span></span>
<span class="line"><span>  free(handle); // 释放分配的内存</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建一个新的 MyFileHandle 对象并与 JavaScript 对象关联</span></span>
<span class="line"><span>napi_value CreateMyFileHandle(napi_env env) {</span></span>
<span class="line"><span>  napi_value js_object;</span></span>
<span class="line"><span>  MyFileHandle* my_file_handle = (MyFileHandle*)malloc(sizeof(MyFileHandle));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 打开文件，只是举例，具体参数需根据实际情况填写</span></span>
<span class="line"><span>  my_file_handle-&gt;file = fopen(&quot;example.txt&quot;, &quot;r&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个新的空对象</span></span>
<span class="line"><span>  napi_create_object(env, &amp;js_object);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将我的文件处理对象与 JavaScript 对象关联，并指定终结器</span></span>
<span class="line"><span>  napi_wrap(env,</span></span>
<span class="line"><span>            js_object,</span></span>
<span class="line"><span>            (void*)my_file_handle,</span></span>
<span class="line"><span>            Finalizer,</span></span>
<span class="line"><span>            NULL, // 可选的提示数据</span></span>
<span class="line"><span>            NULL); // 不需要此处的返回值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return js_object;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码演示了如何使用 <code>node_api_post_finalizer</code>（在示例中表现为 <code>napi_wrap</code> 函数的一部分）。这个函数确保当 JavaScript 对象被垃圾回收时，我们的终结器函数 <code>Finalizer</code> 将被调用，从而关闭文件并释放分配的内存，避免资源泄漏。</p><p>请注意，本例中没有直接使用 <code>node_api_post_finalizer</code> 函数，因为通常它是通过 <code>napi_wrap</code> 隐式调用的。<code>napi_wrap</code> 用于将原生资源包装到 JavaScript 对象中，同时注册一个终结器以便资源可以在不需要时释放。</p><p>需要注意的是，<code>node_api_post_finalizer</code> 实际上是 Node.js 文档中的一个命名错误或者说是笔误，正确的名称应该是 <code>napi_add_finalizer</code>。这可能会导致混淆，所以开发者应该查找最新的官方文档来确认正确的 API 名称和使用方法。</p><h2 id="simple-asynchronous-operations" tabindex="-1"><a class="header-anchor" href="#simple-asynchronous-operations"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#simple-asynchronous-operations" target="_blank" rel="noopener noreferrer">Simple asynchronous operations</a></span></a></h2><p>Node.js 中的 N-API 是一个用于构建本地插件（也就是使用 C 或 C++编写的扩展模块）的 API。在 Node.js v21.7.1 的文档中，&quot;Simple asynchronous operations&quot;部分解释了如何使用 N-API 执行异步操作。</p><p>异步操作是指程序可以启动一个任务，在等待这个任务完成的同时继续执行其他代码，而不是停下来等待结果。这对于不阻塞 Node.js 主线程特别重要，因为 Node.js 是单线程的，长时间阻塞会导致整个应用程序无法响应其他任务。</p><p>在 N-API 中实现简单的异步操作一般需要以下几步：</p><ol><li><p><strong>定义工作结构</strong>: 首先，你需要创建一个<code>napi_work</code>的实例，这代表了一个异步任务。</p></li><li><p><strong>创建异步工作</strong>: 使用<code>napi_create_async_work</code>函数创建异步工作，其中你将指定完成这项任务时要调用的函数和销毁资源时要调用的函数。</p></li><li><p><strong>将工作排队</strong>: 使用<code>napi_queue_async_work</code>函数将定义的工作添加到事件循环中，使其在未来某个时间点执行。</p></li><li><p><strong>工作执行</strong>: Node.js 会在后台线程池中执行此工作，而不会影响主线程的执行。</p></li><li><p><strong>工作完成</strong>: 一旦后台任务完成，相关联的完成回调函数将被加入到事件循环中，并在主线程上执行。</p></li><li><p><strong>销毁工作</strong>: 完成该工作后，你需要使用<code>napi_delete_async_work</code>清理分配的资源。</p></li></ol><p>现在，让我们举一个实际的例子。假设你在开发一个 Node.js 的本地插件，该插件需要进行文件系统的操作，例如读取一个大文件。文件读取是一个耗时的过程，所以你希望以异步方式来处理它，以免阻塞主线程。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 伪代码 - 执行异步任务的函数</span></span>
<span class="line"><span>void Execute(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 这里你可以执行类似读取大文件的操作</span></span>
<span class="line"><span>    // 注意这个函数是在另一个线程中运行的，不会阻塞主线程</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 伪代码 - 异步任务完成后的回调函数</span></span>
<span class="line"><span>void Complete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 这里你可以处理执行结果，比如将文件内容传给JavaScript</span></span>
<span class="line"><span>    // 这个函数会在主线程中被调用</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 伪代码 - 启动异步任务的JS绑定函数</span></span>
<span class="line"><span>napi_value StartAsyncTask(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value work_name;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;workName&quot;, NAPI_AUTO_LENGTH, &amp;work_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, work_name, Execute, Complete, NULL, &amp;work);</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，在加载插件时调用</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value asyncTaskFunction;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, StartAsyncTask, NULL, &amp;asyncTaskFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;startAsyncTask&quot;, asyncTaskFunction);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个<code>StartAsyncTask</code>函数，它会启动一个异步操作来执行耗时的任务（例如读取大文件）。当任务开始时，会立即返回，从而不阻塞 Node.js 的主线程。完成后，会调用<code>Complete</code>函数来处理结果，比如将读取的数据通过事件或回调传递给 JavaScript 层面的代码。</p><p>这样，你就可以在 Node.js 中利用 N-API 进行高效的异步操作，而不会影响应用程序的性能和响应性。</p><h3 id="napi-create-async-work" tabindex="-1"><a class="header-anchor" href="#napi-create-async-work"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_async_work" target="_blank" rel="noopener noreferrer">napi_create_async_work</a></span></a></h3><p>当你使用 Node.js 编程时，有时候你会需要执行一些耗时的操作，比如访问文件系统、进行网络通信或者做一些复杂的计算。如果这些操作在主线程中执行，它们会阻塞其他代码运行，因为 JavaScript 是单线程的。为了解决这个问题，Node.js 提供了异步编程模型。</p><p>其中一个工具就是 N-API 中的<code>napi_create_async_work</code>函数。这个函数允许你创建一个可以在后台执行的任务，这样你的程序就可以继续执行其他任务，而不必等待这个耗时任务完成。</p><h3 id="如何使用-napi-create-async-work" tabindex="-1"><a class="header-anchor" href="#如何使用-napi-create-async-work"><span>如何使用 <code>napi_create_async_work</code></span></a></h3><p>要使用<code>napi_create_async_work</code>，你需要准备以下几个东西：</p><ol><li><strong>Execute Function</strong>: 这个函数包含了你想要异步执行的代码。</li><li><strong>Complete Function</strong>: 当异步执行完成后，这个函数将被调用。</li><li><strong>Data</strong>: 一个指向你的数据的指针，这些数据将被传递给 Execute Function 和 Complete Function。</li><li><strong>Async Work</strong>: 一个引用，代表了这个异步任务。</li></ol><p>创建异步任务大致的代码示例如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 执行函数，将在后台线程上运行</span></span>
<span class="line"><span>void Execute(napi_env env, void* data) {</span></span>
<span class="line"><span>    // ...耗时的操作...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 完成函数，当任务完成时，在主线程上运行</span></span>
<span class="line"><span>void Complete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // ...清理工作或者回调JavaScript代码...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建异步工作</span></span>
<span class="line"><span>napi_value CreateAsyncWork(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value work_name;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;MyWork&quot;, NAPI_AUTO_LENGTH, &amp;work_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, work_name,</span></span>
<span class="line"><span>                           Execute, Complete, NULL, &amp;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将异步工作队列化</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个更实际的例子：</p><p>假设你正在编写一个 Node.js 扩展，需要在 C++层面读取一个大文件，并且希望这个操作不会阻塞主线程。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设你已经包含了所需的头文件和设置好了环境</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 你可能定义了一个结构体来保存你的数据</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>    char* filename;</span></span>
<span class="line"><span>    char* fileContents;</span></span>
<span class="line"><span>} FileReadData;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Execute(napi_env env, void* data) {</span></span>
<span class="line"><span>    FileReadData* readData = (FileReadData*)data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 这里伪代码表示打开文件并读取内容</span></span>
<span class="line"><span>    readData-&gt;fileContents = ReadFile(readData-&gt;filename);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Complete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    FileReadData* readData = (FileReadData*)data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 伪代码表示将读取到的内容传递给JavaScript的回调函数</span></span>
<span class="line"><span>    PassToJSCallback(env, readData-&gt;fileContents);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 清理工作</span></span>
<span class="line"><span>    free(readData-&gt;fileContents);</span></span>
<span class="line"><span>    free(readData);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数会被JavaScript代码调用以启动异步文件读取</span></span>
<span class="line"><span>napi_value StartAsyncFileRead(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取文件名（JavaScript字符串参数）</span></span>
<span class="line"><span>    size_t filename_length;</span></span>
<span class="line"><span>    napi_get_value_string_utf8(env, args[0], NULL, 0, &amp;filename_length);</span></span>
<span class="line"><span>    char* filename = malloc(filename_length + 1);</span></span>
<span class="line"><span>    napi_get_value_string_utf8(env, args[0], filename, filename_length + 1, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置我们的数据</span></span>
<span class="line"><span>    FileReadData* readData = malloc(sizeof(FileReadData));</span></span>
<span class="line"><span>    readData-&gt;filename = filename;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建异步工作</span></span>
<span class="line"><span>    napi_value async_resource_name;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;asyncFileRead&quot;, NAPI_AUTO_LENGTH, &amp;async_resource_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, async_resource_name,</span></span>
<span class="line"><span>                           Execute, Complete, readData, &amp;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 队列化异步工作</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当你加载这个扩展模块时，你需要注册StartAsyncFileRead函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value asyncFileReadFunction;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, StartAsyncFileRead, NULL, &amp;asyncFileReadFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;startAsyncFileRead&quot;, asyncFileReadFunction);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，JavaScript 代码可以调用<code>startAsyncFileRead</code>函数，并传递一个文件名，然后这个模块将开始异步地读取文件内容，而不会阻塞其他 JavaScript 代码的执行。文件读取完毕后，会调用 Complete 函数，然后你可以在这里处理读取到的数据，例如，触发一个 JavaScript 事件，或者调用一个回调函数。</p><p>通过使用<code>napi_create_async_work</code>，你可以创建强大的 Node.js 扩展，能够执行复杂的、耗时的任务，同时保持应用程序的响应性。</p><h3 id="napi-delete-async-work" tabindex="-1"><a class="header-anchor" href="#napi-delete-async-work"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_delete_async_work" target="_blank" rel="noopener noreferrer">napi_delete_async_work</a></span></a></h3><p>在 Node.js 中，N-API 是一个与 JavaScript 运行时和引擎无关的 API 层，它允许你创建原生插件。使用 N-API，你可以编写用 C 或 C++ 编写的代码，这些代码可以直接与 Node.js 交互。</p><p><code>napi_delete_async_work</code> 是 N-API 中的一个函数，它用于删除以前创建的异步工作。在解释 <code>napi_delete_async_work</code> 之前，我们需要先理解几个基本概念：</p><ol><li><p><strong>异步编程</strong>：在 Node.js 中，很多操作都是异步进行的，比如文件读写、网络请求等，这意味着它们不会立即完成，而是在未来的某个时间点完成。这样可以避免阻塞主线程，提高程序的效率。</p></li><li><p><strong>异步工作</strong>：在使用 N-API 创建原生插件时，你可能需要执行一些耗时的任务，比如访问数据库或者大量数据的处理。这些任务通常在后台的线程上异步执行，以避免阻塞 Node.js 的主事件循环。</p></li><li><p><strong>napi_create_async_work</strong>：这是一个用于创建异步工作的函数。当你有一个耗时的任务时，你可以使用这个函数将任务放到后台线程去执行，同时你需要传递一些回调函数，它们定义了任务开始、执行和完成时应该做什么。</p></li></ol><p>现在让我们来看看 <code>napi_delete_async_work</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_delete_async_work(napi_env env,</span></span>
<span class="line"><span>                                   napi_async_work work);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>napi_delete_async_work</code> 的作用是删除通过 <code>napi_create_async_work</code> 创建出来的异步工作对象。当你的异步任务完成并且相关的回调被调用之后，你应该使用 <code>napi_delete_async_work</code> 来清理内存，防止内存泄漏。</p><p>参数说明：</p><ul><li><code>env</code>：这是代表 N-API 环境的句柄，每个 N-API 函数都会用到它，它贯穿整个 N-API 使用周期。</li><li><code>work</code>：这是你希望删除的异步工作对象的句柄，它是之前通过 <code>napi_create_async_work</code> 创建出来的。</li></ul><p>例子：</p><p>假设你正在编写一个原生插件，其中有一个函数需要做大量的计算，你想要将这部分工作移到后台线程去执行，以下是一个简化版的示例：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 声明一个执行大量计算的函数</span></span>
<span class="line"><span>void ExecuteWork(napi_env env, void* data) {</span></span>
<span class="line"><span>    // ... 在这里执行计算 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 声明一个当工作完成时会被调用的函数</span></span>
<span class="line"><span>void WorkComplete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 获取异步工作句柄</span></span>
<span class="line"><span>    napi_async_work work = (napi_async_work)data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 删除异步工作对象以释放资源</span></span>
<span class="line"><span>    napi_delete_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 这里还可以发送结果给JavaScript ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 接下来是暴露给 JavaScript 的函数，它会启动异步工作</span></span>
<span class="line"><span>napi_value StartAsyncWork(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value work_name;</span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建一个 JavaScript 字符串作为工作名称</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;Heavy computation&quot;, NAPI_AUTO_LENGTH, &amp;work_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建异步工作对象</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, work_name, ExecuteWork, WorkComplete, NULL, &amp;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将工作排入队列</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回 undefined 给 JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>StartAsyncWork</code> 是暴露给 JavaScript 的函数，它创建了一个名为 &quot;Heavy computation&quot; 的异步工作，并将其添加到队列中。<code>ExecuteWork</code> 是在后台线程上实际执行工作的函数，而 <code>WorkComplete</code> 则是工作完成后的回调函数，在这个回调中我们使用 <code>napi_delete_async_work</code> 来删除异步工作对象，释放资源。</p><p>这样，即使在执行大量的计算时，我们也不会阻塞 Node.js 的主事件循环，从而保证了应用程序的响应性能。</p><h3 id="napi-queue-async-work" tabindex="-1"><a class="header-anchor" href="#napi-queue-async-work"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_queue_async_work" target="_blank" rel="noopener noreferrer">napi_queue_async_work</a></span></a></h3><p>当然可以，首先让我们了解一下 Node.js 是什么。</p><p>Node.js 是一个跨平台的 JavaScript 运行环境，它能让开发者使用 JavaScript 来编写服务器端的代码。Node.js 使用非阻塞、事件驱动的模型，这使得它非常适合构建高效、可扩展的网络应用程序。</p><p>现在我们来谈谈 N-API 和 <code>napi_queue_async_work</code>。</p><p>N-API 是 Node.js 的一个 C API，它允许 native addons 与 Node.js 进行交互。native addons 是用 C 或 C++ 编写的模块，可以通过 Node.js 的 N-API 被直接集成到 Node.js 应用程序中。通过这样做，你可以在 Node.js 中执行那些 JavaScript 不擅长的 CPU 密集型任务，同时避免 Node.js 在执行这些任务时被阻塞。</p><p><code>napi_queue_async_work</code> 是 N-API 提供的一个函数，它允许你将异步工作（如文件读写、数据库操作或其他需要大量计算的任务）放入一个队列中，然后在后台线程中执行，从而不会阻塞主 JavaScript 线程。当这个工作完成时，它会将一个回调函数放回到 JavaScript 的事件循环中，从而让你能够处理结果。</p><p>举一个例子：</p><p>假设你正在编写一个 Node.js 应用程序，该程序需要处理图像，比如转换图片格式，这是一个 CPU 密集型任务。如果你在 Node.js 主线程中进行图像处理，那么在处理期间，你的服务器就无法响应任何其他请求，因为事件循环被阻塞了。这显然不是一个好的情况。</p><p>为了解决这个问题，你可以编写一个 native addon，并使用 <code>napi_queue_async_work</code> 将图像处理任务放到后台线程中去执行。这样，主线程就可以继续处理其他请求，而图像处理在后台进行。处理完成后，通过设置的回调函数，你的 JavaScript 代码可以获取到通知，并对处理结果进行相应的操作。</p><p>下面是使用 <code>napi_queue_async_work</code> 的一个简化流程：</p><ol><li>定义你需要在后台执行的任务。</li><li>创建一个 <code>napi_async_work</code> 句柄，它代表了这个任务。</li><li>使用 <code>napi_queue_async_work</code> 将任务加入队列并开始执行。</li><li>当任务完成时，Node.js 会自动将一个回调事件放入事件循环中，让你可以在 JavaScript 层面处理结果。</li></ol><p>值得注意的是，通常开发者并不需要直接使用 N-API 和 <code>napi_queue_async_work</code> 函数，除非他们正在编写 native addons。对于大多数情况，Node.js 核心 API 或者通过 npm 安装的模块已经足够用于处理各种异步任务。</p><h3 id="napi-cancel-async-work" tabindex="-1"><a class="header-anchor" href="#napi-cancel-async-work"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_cancel_async_work" target="_blank" rel="noopener noreferrer">napi_cancel_async_work</a></span></a></h3><p>好的，Node.js 中的 N-API（Node.js API）是一个用来编写本地插件的 API。这些本地插件是用 C 或 C++等语言编写的，它们能够直接与 Node.js 的运行时交互。N-API 旨在提供一个独立于 JavaScript 引擎的抽象层，这意味着编写的代码不依赖于特定的版本的 Node.js 或 V8 引擎，可以更稳定地跨版本工作。</p><p><code>napi_cancel_async_work</code> 是 N-API 中的一个函数，用于取消之前通过<code>napi_create_async_work</code>创建并通过<code>napi_queue_async_work</code>排队执行的异步任务。实际上，当你需要停止一个还没有开始或者正在执行但是希望提前终止的异步操作时，你可以调用这个函数。</p><p>举个简单的例子：</p><p>假设你创建了一个本地插件，该插件中有一个长时间运行的计算任务，但是在某些条件下，比如用户取消操作，或者超出一定的等待时间后，你想要取消这个任务。</p><p>首先，你会创建一个异步工作项：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value async_work;</span></span>
<span class="line"><span>napi_create_async_work(env, NULL, resource_name, execute, complete, data, &amp;async_work);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>execute</code> 是在异步线程池中运行的函数，而 <code>complete</code> 是在主线程中运行的，<code>data</code> 是传递给它们的数据。</p><p>然后，你将这个工作项加入到异步队列中：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_queue_async_work(env, async_work);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>现在假设你的应用程序遇到了某种情况，需要取消这个异步任务。这时候你就可以调用 <code>napi_cancel_async_work</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_cancel_async_work(env, async_work);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这将尝试取消排队的工作。如果工作已经开始执行，那么它会在下一个可能的机会点被取消。取消成功后，<code>complete</code> 回调仍然会被调用，你可以在这个回调中清理资源，但是 <code>execute</code> 函数的影响将不会生效。</p><p>这里需要注意，取消一个异步工作并不保证能立刻停止它，因为如果该工作已经开始，在它的执行过程中没有检查取消状态，则它将继续运行直到完成。只有在工作支持取消操作，并且正确地检查了异步工作的取消状态时，它才会被真正地取消掉。</p><p>使用 <code>napi_cancel_async_work</code> 提供了一种机制来处理那些需要长时间运行的操作，同时也给予了开发者控制权，以在必要时提前终止这些操作，这对于创建响应式良好的应用程序非常重要。</p><h2 id="custom-asynchronous-operations" tabindex="-1"><a class="header-anchor" href="#custom-asynchronous-operations"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#custom-asynchronous-operations" target="_blank" rel="noopener noreferrer">Custom asynchronous operations</a></span></a></h2><p>Node.js 的 N-API（Native API）是一个用于构建原生插件的接口。原生插件是用 C 或 C++编写的模块，可以直接调用 Node.js 底层 API。N-API 旨在隔离插件与 Node.js 引擎的变动，使得编写的插件可以无需修改就能适应新版本的 Node.js。</p><p>在 Node.js v21.7.1 中，“Custom asynchronous operations”指的是通过 N-API 创建自定义的异步操作。这允许你执行可能需要很长时间完成的任务（比如读取大文件、进行密集计算等），而不会阻塞 Node.js 的事件循环。简单来说，它可以帮助你提高应用程序的性能和响应速度，因为主线程可以继续处理其他事件，而不必等待耗时操作完成。</p><h3 id="实际应用例子-1" tabindex="-1"><a class="header-anchor" href="#实际应用例子-1"><span>实际应用例子</span></a></h3><p>假设我们要开发一个原生 Node.js 插件，该插件需要执行一个耗时的图像处理操作，例如将图片转换为黑白色。通常，这种操作如果在 Node.js 的主线程上同步执行，会导致应用程序的所有其他活动暂停，包括响应用户请求。</p><p>使用 N-API 创建的自定义异步操作可以将图像处理工作移至单独的线程中。以下是实现该功能的高级步骤：</p><ol><li><p><strong>定义异步工作结构</strong>：使用<code>napi_create_async_work</code>函数创建异步工作请求，并定义要在后台执行的函数。</p></li><li><p><strong>启动异步工作</strong>：通过<code>napi_queue_async_work</code>函数将异步工作添加到队列中，这样它就会在单独的线程上运行。</p></li><li><p><strong>完成处理</strong>：一旦后台操作完成，会调用一个完成回调函数，在这个函数中你可以将结果传回 JavaScript 代码。</p></li></ol><p>下面是一个伪代码示例，展示了这些步骤如何结合起来：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 图像处理函数，运行在单独的线程上</span></span>
<span class="line"><span>void ProcessImageInBackground(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 这里进行耗时的图像处理操作...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 完成回调函数，运行在主线程上，负责返回结果给JavaScript</span></span>
<span class="line"><span>void OnImageProcessed(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 通知JavaScript图像处理已完成...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// JavaScript调用的函数，启动异步图像处理</span></span>
<span class="line"><span>napi_value ConvertImageToBlackAndWhite(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建异步工作请求...</span></span>
<span class="line"><span>    napi_value work_name;</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;ConvertImage&quot;, NAPI_AUTO_LENGTH, &amp;work_name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, work_name,</span></span>
<span class="line"><span>                           ProcessImageInBackground,</span></span>
<span class="line"><span>                           OnImageProcessed, NULL, &amp;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将工作加入队列...</span></span>
<span class="line"><span>    napi_queue_async_work(env, work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回undefined，表示函数已非阻塞方式调用</span></span>
<span class="line"><span>    return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模块初始化代码</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value convert_fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, ConvertImageToBlackAndWhite, NULL, &amp;convert_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;convertImageToBlackAndWhite&quot;, convert_fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中：</p><ul><li><code>ProcessImageInBackground</code> 是在后台执行的耗时操作。</li><li><code>OnImageProcessed</code> 是异步操作完成后调用的回调函数。</li><li><code>ConvertImageToBlackAndWhite</code> 是从 JavaScript 代码中调用以启动整个异步过程的函数。</li></ul><p>虽然这只是一个大概的框架，它说明了如何使用 Node.js N-API 创建自定义的异步操作。对于编程新手来说，理解这些概念可能需要时间，但这是 Node.js 高性能原生扩展编程的基础知识之一。</p><h3 id="napi-async-init" tabindex="-1"><a class="header-anchor" href="#napi-async-init"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_init" target="_blank" rel="noopener noreferrer">napi_async_init</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。它提供了一些函数，可以让你在 C 或 C++代码中使用 JavaScript 功能。<code>napi_async_init</code>是 N-API 里的一个函数，用来初始化异步操作。</p><p>当你想在 Node.js 的原生插件中执行异步任务时，比如读取文件、网络请求或者一些长时间运行的计算，你需要通过正确的方式告诉 Node.js 的事件循环这个任务是异步的。这样做可以让 Node.js 的主线程继续处理其他事件，比如用户的输入、服务器的请求等，而不会因为等待某一个异步任务完成而阻塞。</p><p>现在，让我们详细解释一下<code>napi_async_init</code>：</p><h3 id="napi-async-init-1" tabindex="-1"><a class="header-anchor" href="#napi-async-init-1"><span>napi_async_init</span></a></h3><p><strong>语法：</strong></p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_async_init(napi_env env,</span></span>
<span class="line"><span>                            napi_value async_resource,</span></span>
<span class="line"><span>                            napi_value async_resource_name,</span></span>
<span class="line"><span>                            napi_async_context* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>env</strong>: 这是表示 N-API 环境的句柄。每次 N-API 函数被调用时，都会传递这个环境句柄。</li><li><strong>async_resource</strong>: 这通常是一个 JavaScript 对象，它与异步操作相关联。这个对象在异步操作期间保持活动状态，可以用来存储信息。</li><li><strong>async_resource_name</strong>: 这是一个 JavaScript 字符串，它给出了<code>async_resource</code>的名称，用于调试。</li><li><strong>result</strong>: 这是一个指向异步上下文句柄的指针，在调用<code>napi_async_init</code>后，这个句柄可以用于其他异步操作 API。</li></ul><h3 id="使用场景和例子" tabindex="-1"><a class="header-anchor" href="#使用场景和例子"><span>使用场景和例子</span></a></h3><p>假设你正在编写一个 Node.js 的原生插件，你需要从一个硬件设备中异步读取数据。你可能会写一个 C 函数来启动读取过程，并且当读取完毕时，你希望能够通知 Node.js。</p><ol><li><p>首先，你使用<code>napi_async_init</code>来初始化一个异步上下文。这个上下文将用于稍后在异步操作完成时通知 Node.js。</p></li><li><p>接着，你开启读取数据的硬件操作，这部分通常涉及向硬件发送命令，然后等待硬件的回应。</p></li><li><p>当硬件有数据返回时，你将使用另一个 N-API 函数（比如<code>napi_make_callback</code>）来将数据传回给 Node.js，同时利用之前创建的异步上下文。</p></li><li><p>最后，当所有异步操作都完成时，你应该使用<code>napi_async_destroy</code>来清理你创建的异步上下文，避免内存泄漏。</p></li></ol><p>以下是一个简化的示例代码片段，展示如何使用<code>napi_async_init</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设有一个异步操作函数</span></span>
<span class="line"><span>void read_data_from_hardware(/* 参数 */) {</span></span>
<span class="line"><span>    // ... 与硬件交互的代码 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value InitiateAsyncOperation(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span>    napi_async_context context;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 初始化异步上下文</span></span>
<span class="line"><span>    status = napi_async_init(env, NULL, NULL, &amp;context);</span></span>
<span class="line"><span>    // 检查是否成功</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误情况</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 启动硬件读取操作，此操作将在未来的某个时刻完成</span></span>
<span class="line"><span>    read_data_from_hardware(/* 参数 */);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 其他代码 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回结果给JavaScript</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    status = napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册这个函数到Node.js</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, InitiateAsyncOperation, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;initiateAsyncOperation&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，上述代码只是一个概念性展示，实际的异步操作需要使用事件循环和回调函数来正确地进行。</p><h3 id="napi-async-destroy" tabindex="-1"><a class="header-anchor" href="#napi-async-destroy"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_async_destroy" target="_blank" rel="noopener noreferrer">napi_async_destroy</a></span></a></h3><p><code>napi_async_destroy</code> 是 Node.js 中的一个函数，属于 N-API（Node API）的一部分。N-API 是一套 C 语言的 API，它允许你创建可以与 Node.js JavaScript 运行时交互的本地插件。这些本地插件通常是用 C 或 C++ 编写的，目的是为了提供一些 JavaScript 难以实现或者性能不足的功能。</p><h3 id="napi-async-destroy-的作用" tabindex="-1"><a class="header-anchor" href="#napi-async-destroy-的作用"><span>napi_async_destroy 的作用</span></a></h3><p>在解释 <code>napi_async_destroy</code> 之前，我们需要理解其中涉及的几个概念：</p><ol><li><p><strong>异步操作</strong>：在 Node.js 中，很多操作都是异步的，比如文件读写、网络请求等。这意味着这些操作会在后台执行，执行完毕后通过回调函数来通知结果，从而不会阻塞主线程。</p></li><li><p><strong>async_hooks</strong>：这是 Node.js 中用来追踪异步资源生命周期的模块。每当创建一个异步操作时，就会创建一个新的异步资源，并且这个资源会有一个唯一的标识。</p></li><li><p><strong>napi_async_context</strong>：这是 N-API 中的一个结构体，代表了与特定异步操作相关联的上下文信息。当你使用 N-API 创建一个异步操作时，你需要创建这样一个上下文。</p></li></ol><p>现在来看 <code>napi_async_destroy</code>，这个函数的作用是销毁一个已经不再需要的 <code>napi_async_context</code>。当你创建了一个 <code>napi_async_context</code> 后，在异步操作完成并且不再需要这个上下文时，你应该调用 <code>napi_async_destroy</code> 来清理它。如果不这样做，可能会造成内存泄漏。</p><h3 id="使用场景举例-3" tabindex="-1"><a class="header-anchor" href="#使用场景举例-3"><span>使用场景举例</span></a></h3><p>假设你正在编写一个本地插件，该插件需要在后台进行一些耗时的计算，并在计算完成后将结果返回给 JavaScript。你可能会这样做：</p><ol><li>在插件初始化时，创建一个 <code>napi_async_context</code>。</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_async_context async_context;</span></span>
<span class="line"><span>status = napi_async_init(env, NULL, &quot;example_async_context&quot;, &amp;async_context);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p>在开始异步操作时，传递这个上下文到一个异步工作队列中。</p></li><li><p>当异步操作完成时，使用这个上下文来触发回调。</p></li><li><p>在插件被清理或者不再需要处理异步操作时，销毁这个上下文。</p></li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>status = napi_async_destroy(env, async_context);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这样的方式，你确保了即使是在 C/C++ 层面进行异步操作，也能够正确地管理资源和内存，并且能够和 JavaScript 的事件循环无缝集成。</p><p>记住，<code>napi_async_destroy</code> 应该在确保所有使用了这个上下文的异步操作都已经完成之后调用，否则可能会导致无法预料的行为。</p><h3 id="napi-make-callback" tabindex="-1"><a class="header-anchor" href="#napi-make-callback"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_make_callback" target="_blank" rel="noopener noreferrer">napi_make_callback</a></span></a></h3><p>Node.js 的 <code>N-API</code> 是一个用于构建本机插件（native addons）的 API 层，它允许你使用 C 或 C++ 代码与 Node.js 运行时交互。这个接口设计得足够稳定，使得对 Node.js 版本的升级不会破坏使用 N-API 编写的模块。</p><p><code>napi_make_callback</code> 是 N-API 的一部分，它是一个函数，被用来从原生代码（C/C++ 插件）中调用 JavaScript 函数，并且正确地处理 Node.js 的事件循环和异步操作。</p><p>在详细解释 <code>napi_make_callback</code> 之前，需要了解两个概念：Node.js 事件循环和回调函数。</p><ol><li><p><strong>事件循环</strong>:<br> Node.js 使用事件驱动模型来处理并发，其中主要组成部分就是事件循环。事件循环负责监听事件（例如网络请求、文件读写完成等），并将对应的回调函数排队进行执行。</p></li><li><p><strong>回调函数</strong>:<br> 在 JavaScript 中，一个回调函数是传递给其他函数作为参数的函数，然后在某个事件或条件下被调用。Node.js 大量依赖回调函数来处理非阻塞的异步操作。</p></li></ol><p><code>napi_make_callback</code> 具体做什么？</p><p>当你在本机插件中执行一些异步操作，并希望在这些操作完成时调用 JavaScript 中定义的回调函数，可以使用 <code>napi_make_callback</code>。它确保回调函数的调用遵循 Node.js 事件循环的规则，尤其是在处理嵌套调用或多个异步事件时。</p><p>如何使用 <code>napi_make_callback</code>? 下面是一个简化的例子：</p><p>假设你在 C++ 插件中有这样一个场景，你想在读取完文件后执行 JavaScript 中的回调函数，你可能会这样写：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void OnFileReadComplete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    // 构造一个JavaScript函数的回调</span></span>
<span class="line"><span>    napi_value callback;</span></span>
<span class="line"><span>    napi_value global;</span></span>
<span class="line"><span>    napi_get_global(env, &amp;global);</span></span>
<span class="line"><span>    napi_get_reference_value(env, (napi_ref)data, &amp;callback);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设我们想要传递一个字符串 &#39;Hello world!&#39; 给回调</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_create_string_utf8(env, &quot;Hello world!&quot;, NAPI_AUTO_LENGTH, &amp;argv[0]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用JavaScript的回调函数，同时遵循事件循环的规则</span></span>
<span class="line"><span>    napi_value result;</span></span>
<span class="line"><span>    napi_make_callback(env, nullptr, global, callback, 1, argv, &amp;result);</span></span>
<span class="line"><span>    // ...省略清理引用和错误处理的代码...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中的 <code>OnFileReadComplete</code> 函数是在文件读取完毕之后被调用的，它准备好调用在 JavaScript 中提供的回调函数，并通过 <code>napi_make_callback</code> 安全地调用该 JavaScript 函数。<code>env</code> 参数是一个表示 N-API 环境的句柄，<code>status</code> 表示之前的操作状态，而 <code>data</code> 指向预先存储的用户数据（在这个例子中，可能是一个指向 JavaScript 回调函数引用的指针）。</p><p><code>napi_get_global</code> 获取 JavaScript 全局对象的引用，<code>napi_get_reference_value</code> 根据之前创建的引用获取实际的 JavaScript 函数对象。然后使用 <code>napi_create_string_utf8</code> 创建一个 JavaScript 字符串作为参数。最后，<code>napi_make_callback</code> 实际调用 JavaScript 函数。</p><p>总结一下，<code>napi_make_callback</code> 在 Node.js 的 N-API 中是一个高级函数，用于在本地代码中按照 Node.js 的事件循环规则调用 JavaScript 函数。通过使用这个函数，开发者能够编写出更安全、更稳定的本机插件，确保与 JavaScript 代码的交互不会违背 Node.js 的设计原则。</p><h3 id="napi-open-callback-scope" tabindex="-1"><a class="header-anchor" href="#napi-open-callback-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_open_callback_scope" target="_blank" rel="noopener noreferrer">napi_open_callback_scope</a></span></a></h3><p>Node.js 中的 <code>napi_open_callback_scope</code> 是一个函数，属于 Node.js 的 N-API。N-API 是一组稳定的应用程序编程接口（API），允许你创建原生插件。原生插件是用 C 或 C++等语言编写的动态链接库（DLL），可以直接调用 Node.js 运行时和 V8 引擎的功能，通常用于执行特定硬件操作、处理大量数据或其他需要高性能的场景。</p><p>在使用 N-API 编写原生代码时，有时你需要在 JavaScript 环境外部创建一个回调，这就是<code>napi_open_callback_scope</code>发挥作用的地方。这个函数帮助你开启一个新的“回调作用域”（callback scope），它允许你在非 JavaScript 线程中安全地调用 JavaScript 函数。</p><p>实际上，当你想要从一个原生线程调用一个 JavaScript 函数时，你不能直接这样做，因为 JavaScript 是单线程的，且运行在 V8 引擎的主线程中。因此，你需要通过<code>napi_open_callback_scope</code>来确保你的调用在正确的上下文中执行。</p><p>现在，让我们看几个例子：</p><ol><li><p><strong>异步操作完成后的回调</strong>：假设你正在编写一个文件读取模块。你可能会用 C++进行文件的读取操作，并利用 N-API 暴露这个功能给 Node.js。一旦文件读取完毕，你想要运行一个 JavaScript 回调函数来处理读取到的数据。在这种情况下，就需要用到<code>napi_open_callback_scope</code>。</p></li><li><p><strong>自定义事件发射器</strong>：如果你的原生模块像硬件设备那样工作，可能需要在某些事件发生时触发 JavaScript 侧的监听器。例如，在一个温度计模块中，每当检测到温度变化时，你可能会调用一个 JavaScript 函数来处理这个事件。为此，你也需要创建一个新的回调作用域。</p></li><li><p><strong>定时器回调</strong>：如果你的原生模块暴露了一个定时器功能，JavaScript 代码可以提供一个回调函数，在定时器触发时执行。原生代码部分将使用<code>napi_open_callback_scope</code>来确保当定时器在原生线程触发时，回调函数能够正确地在 JavaScript 环境中执行。</p></li></ol><p>简而言之，<code>napi_open_callback_scope</code>是与<code>napi_close_callback_scope</code>结合使用的，它们包裹你需要在原生线程中执行的 JavaScript 回调函数，确保所有与执行该回调相关的资源被正确管理，并且调用是在合适的上下文中进行的。这对维护 Node.js 应用程序的稳定性和性能至关重要。</p><h3 id="napi-close-callback-scope" tabindex="-1"><a class="header-anchor" href="#napi-close-callback-scope"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_close_callback_scope" target="_blank" rel="noopener noreferrer">napi_close_callback_scope</a></span></a></h3><p>好的，我会直接进入主题。</p><p>首先，让我们理解一下 N-API 是什么。N-API 是一个 Node.js 的 API 层，它允许你使用 C 或 C++编写可以与 JavaScript 代码交互的原生插件。通过使用 N-API，你可以创建性能更高且不会随 Node.js 版本更新而改变的扩展。这对于想要在 Node.js 中利用现有 C/C++库的开发者来说非常有帮助。</p><p>当我们提到<code>napi_close_callback_scope</code>，我们正在讨论 N-API 的一个功能，它涉及到所谓的“回调作用域”。当你在原生插件中调用 JavaScript 函数或传递数据时，Node.js 使用“回调作用域”来跟踪和处理这些调用。每次从原生代码调用 JavaScript 代码时，都会创建一个新的回调作用域。</p><p>现在，来谈谈<code>napi_close_callback_scope</code>函数本身。这个函数的作用是结束当前的回调作用域。当你打开一个作用域来执行一些操作，并在所有操作完成后，你需要关闭这个作用域，以确保资源得到正确的释放。这就像在编程中打开了一个文件进行读写操作，之后必须关闭它，防止资源泄露或其他潜在问题。</p><p>在 N-API 中，开始一个新的回调作用域你会使用<code>napi_open_callback_scope</code>，并在所有操作完成后，使用<code>napi_close_callback_scope</code>来关闭它。</p><p>举个例子，假设你有一个 C++函数，它将在某些条件下调用一个 JavaScript 回调函数。在这个场景下，你可能会这样做：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status status;</span></span>
<span class="line"><span>napi_callback_scope scope;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设env是你当前的napi环境，cb为JavaScript回调函数</span></span>
<span class="line"><span>status = napi_open_callback_scope(env, cb, &amp;scope);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 调用JavaScript中的回调函数</span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 完成所有的调用后，你需要关闭这个作用域</span></span>
<span class="line"><span>status = napi_close_callback_scope(env, scope);</span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，这段代码并未展示完整的实现细节，比如如何创建<code>napi_env</code>、<code>napi_value</code>等，但它给出了如何在一个简单情况下使用<code>napi_close_callback_scope</code>来结束回调作用域的概念。</p><p>总结，<code>napi_close_callback_scope</code>是 N-API 的一部分，用于确保当你完成与 JavaScript 的交互后，任何相关的资源都能被妥善管理和释放。这有助于避免内存泄漏，确保 Node.js 应用程序的稳定性和效率。在实际应用中，任何时候你通过 N-API 打开回调作用域，最终都应当关闭它，以保持良好的资源管理。</p><h2 id="version-management" tabindex="-1"><a class="header-anchor" href="#version-management"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#version-management" target="_blank" rel="noopener noreferrer">Version management</a></span></a></h2><p>Node.js 中的 N-API 是一个用于构建原生插件（native addons）的 API。原生插件是直接与 Node.js 运行时进行交互的，用 C 或 C++ 编写的模块。N-API 的目的是保证不同版本的 Node.js 之间原生插件的兼容性。</p><p>在 Node.js v21.7.1 的文档中，“Version management”通常指的是 N-API 版本管理。每当 Node.js 发布新版本时，N-API 都可能引入新的功能或者变更，这就产生了不同的 N-API 版本。为了保持向后兼容性，并让插件开发者可以针对特定版本编写代码，N-API 提供了版本管理机制。</p><p>实际运用示例：</p><ol><li><p><strong>编写兼容多个 Node.js 版本的原生插件：</strong><br> 假设你希望创建一个原生插件，用于提高图像处理的性能。你会用 C++ 编写处理图像的逻辑，并通过 N-API 将这些功能暴露给 Node.js 代码。在编写插件时，你可以指定你的插件兼容哪些 N-API 版本。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...你的 C++ 代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  napi_create_string_utf8(env, &quot;Hello World!&quot;, NAPI_AUTO_LENGTH, &amp;result);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>package.json</code> 文件中，你可以指明 N-API 的版本：</p><div class="language-json line-numbers-mode" data-highlighter="shiki" data-ext="json" data-title="json" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;awesome-native-addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">    &quot;node-addon-api&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;^3.2.1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;gypfile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">  &quot;binary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#E06C75;">    &quot;napi_versions&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这表明你的原生插件是与 N-API 版本 3、4 和 5 兼容的。</p></li><li><p><strong>检查运行时的 N-API 版本：</strong><br> 当你的 Node.js 应用启动并加载原生插件时，该插件可以检查当前环境下的 N-API 版本是否符合其兼容性需求。如果不符合，你可以选择输出错误消息或者采取其他措施。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 检查当前环境中支持的 N-API 版本</span></span>
<span class="line"><span>  uint32_t napi_version = 0;</span></span>
<span class="line"><span>  napi_get_version(env, &amp;napi_version);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (napi_version `&lt;` 3) {</span></span>
<span class="line"><span>    // 如果 N-API 版本小于3，抛出错误</span></span>
<span class="line"><span>    napi_throw_error(env, NULL, &quot;N-API version 3 or higher is required for this addon&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...初始化插件...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>这样的版本管理使得即使 Node.js 更新了，只要不超出你声明的 N-API 版本范围，你的原生插件仍应该能够正常工作，无需修改代码。这大大降低了维护成本，并提高了原生插件的稳定性和可靠性。</p><p>总结一下，N-API 的版本管理是 Node.js 提供的一种机制，它旨在确保原生插件跨不同 Node.js 版本的兼容性，而无需频繁地对插件代码进行更新。通过使用这种机制，插件开发者可以更容易地维护和分发他们的代码，并确保最终用户有更加平滑的体验。</p><h3 id="napi-get-node-version" tabindex="-1"><a class="header-anchor" href="#napi-get-node-version"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_node_version" target="_blank" rel="noopener noreferrer">napi_get_node_version</a></span></a></h3><p>好的，我会直接回答你的问题。</p><p>Node.js 中的 <code>napi_get_node_version</code> 函数是 N-API 的一部分，N-API 是一个稳定的 Node.js API 层，它允许本地插件的开发者编写能够在不同版本的 Node.js 上运行的代码，而不需要对每个版本重编译。</p><p>当你使用 <code>napi_get_node_version</code> 这个函数时，它可以让你获取当前正在运行的 Node.js 的版本信息。这包括主版本号、次版本号和修订号。这对于确保你的本地插件与特定版本的 Node.js 兼容非常有用。</p><p>函数原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_get_node_version(napi_env env,</span></span>
<span class="line"><span>                                  const napi_node_version** version);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code> 是一个表示 N-API 环境的句柄。</li><li><code>version</code> 是一个指向 <code>napi_node_version</code> 结构体的指针的指针，这个结构体将会被填充为当前 Node.js 版本信息。</li></ul><p><code>napi_node_version</code> 结构体通常定义如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  uint32_t major;</span></span>
<span class="line"><span>  uint32_t minor;</span></span>
<span class="line"><span>  uint32_t patch;</span></span>
<span class="line"><span>  const char* release;</span></span>
<span class="line"><span>} napi_node_version;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>major</code> 表示主版本号。</li><li><code>minor</code> 表示次版本号。</li><li><code>patch</code> 表示修订号。</li><li><code>release</code> 是一个字符串，表示预发布版本标签或空字符串。</li></ul><p>调用 <code>napi_get_node_version</code> 并处理返回结果的简单示例代码片段可能如下所示（C 语言）：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>// ... 其他必要的头文件 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_env env; // 假设已经初始化了 N-API 环境变量env</span></span>
<span class="line"><span>const napi_node_version* node_version;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_status status = napi_get_node_version(env, &amp;node_version);</span></span>
<span class="line"><span>if (status == napi_ok) {</span></span>
<span class="line"><span>  printf(&quot;Node.js version: %d.%d.%d\n&quot;,</span></span>
<span class="line"><span>    node_version-&gt;major,</span></span>
<span class="line"><span>    node_version-&gt;minor,</span></span>
<span class="line"><span>    node_version-&gt;patch);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (node_version-&gt;release[0]) {</span></span>
<span class="line"><span>    printf(&quot;Pre-release tag: %s\n&quot;, node_version-&gt;release);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span>  // 处理错误情况</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你运行这段代码时，它会输出类似 &quot;Node.js version: 14.15.1&quot; 的信息，根据你运行的 Node.js 版本不同，打印出来的版本号也会不同。</p><p>在实际应用中，你可以使用这个函数来确定是否某些特定功能在当前运行的 Node.js 版本中可用，或者如果你在开发一个需要与多个 Node.js 版本兼容的本地模块，你可以使用这个函数来适配不同的版本。</p><h3 id="napi-get-version" tabindex="-1"><a class="header-anchor" href="#napi-get-version"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_version" target="_blank" rel="noopener noreferrer">napi_get_version</a></span></a></h3><p><code>napi_get_version</code>是 Node.js 中 N-API（即 Node API）的一部分，这是一个用来构建原生插件的 API。原生插件通常是用 C 或 C++编写的模块，它们可以直接运行在操作系统层面，因此性能高效。</p><p>在了解<code>napi_get_version</code>之前，先简要介绍一下 N-API：</p><p><strong>什么是 N-API?</strong></p><p>N-API 是 Node.js 的一个稳定特性，允许开发者用 C 或 C++编写与 Node.js 交互的代码，而不必担心 Node.js 和 V8 引擎之间的变动。这提供了一个抽象层，使得编写的原生插件可以跨 Node.js 的不同版本运行，减少了因版本变更而导致的维护负担。</p><p><strong>那么<code>napi_get_version</code>是做什么的？</strong></p><p><code>napi_get_version</code>是一个函数，它允许开发者在他们的原生模块中查询正在使用的 N-API 的版本号。使用这个函数可以确保原生模块能够检查它所支持的 N-API 版本是否与当前环境兼容。</p><p><strong>如何使用<code>napi_get_version</code>?</strong></p><p>假设你正在编写一个原生模块，并且想要确认你支持的最低 N-API 版本是否被当前的 Node.js 环境支持。你可以调用<code>napi_get_version</code>来获取这个信息。</p><p>以下是一个简单的示例，展示如何在 C 代码中调用<code>napi_get_version</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 此处声明版本号的变量</span></span>
<span class="line"><span>  uint32_t napi_version;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 调用napi_get_version获取当前的N-API版本号</span></span>
<span class="line"><span>  napi_status status = napi_get_version(env, &amp;napi_version);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 检查调用是否成功</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在可以根据得到的版本号napi_version进行逻辑处理了</span></span>
<span class="line"><span>  // 比如，检查版本号是否满足你的原生模块所需的最小版本</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们定义了一个名为<code>Init</code>的初始化函数，它将在模块加载时被调用。在这个函数里，我们通过调用<code>napi_get_version</code>获得了当前环境的 N-API 版本并存储在变量<code>napi_version</code>中。然后，我们可以根据这个版本号来决定是否需要执行某些特定的行为。例如，如果我们知道我们的模块需要至少第 3 版的 N-API，我们便可以比较<code>napi_version</code>和数字 3，以确定是否继续或提供错误消息。</p><p>这样的版本检查是很重要的，因为它有助于确保你的代码在不同版本的 Node.js 上都能正常工作，从而提高代码的可靠性和稳定性。</p><h2 id="memory-management" tabindex="-1"><a class="header-anchor" href="#memory-management"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#memory-management" target="_blank" rel="noopener noreferrer">Memory management</a></span></a></h2><p>在 Node.js 中，内存管理是指如何分配、使用和释放内存资源。Node.js v21.7.1 的文档中关于“内存管理”通常会提到 N-API，这是 Node.js 提供给 C 和 C++扩展的一个 API 接口，它允许这些语言编写的代码与 Node.js 交互。</p><p>理解内存管理的重要性，在于防止内存泄漏（程序不需要的内存没有被释放掉）和有效地使用内存资源。下面我会用一些例子来解释在 Node.js 中内存管理的一些概念和实践。</p><h3 id="_1-buffer-和-typedarray" tabindex="-1"><a class="header-anchor" href="#_1-buffer-和-typedarray"><span>1. Buffer 和 TypedArray</span></a></h3><p>在 Node.js 中处理原始二进制数据时会使用<code>Buffer</code>类或者<code>TypedArray</code>。<code>Buffer</code>是 Node.js 特有的全局对象，而<code>TypedArray</code>是 JavaScript 的一部分。比如，当你从网络接收数据或者读取文件时，这些数据通常会被存储在<code>Buffer</code>对象中。</p><p>举个例子：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 异步读取文件内容到Buffer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;/path/to/file&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// data是一个Buffer对象，包含了文件的二进制数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-垃圾回收-garbage-collection" tabindex="-1"><a class="header-anchor" href="#_2-垃圾回收-garbage-collection"><span>2. 垃圾回收（Garbage Collection）</span></a></h3><p>JavaScript 和 Node.js 中的内存大多是自动管理的。意味着创建的变量和对象在不再使用后，会由 JavaScript 的垃圾回收器(GC)自动清理。但是，在使用 C/C++编写的原生扩展模块时，需要手动管理内存。</p><p>例如，如果你创建了一个原生的对象，Node.js 就不知道何时该清理这个对象占用的内存。因此，N-API 提供了一系列的函数来帮助开发者确保这部分内存得到合适的处理。</p><h3 id="_3-n-api-中的内存管理函数" tabindex="-1"><a class="header-anchor" href="#_3-n-api-中的内存管理函数"><span>3. N-API 中的内存管理函数</span></a></h3><p>对于使用 N-API 的扩展模块，Node.js 提供了一些 API 来帮助开发者管理内存：</p><ul><li><code>napi_create_external()</code>: 创建一个 JavaScript 对象，其中包含外部分配的数据。</li><li><code>napi_create_external_buffer()</code>: 为一个已经存在的数据创建一个 Buffer 对象。</li><li><code>napi_create_external_arraybuffer()</code>: 创建一个 ArrayBuffer，其数据是外部提供的。</li><li><code>napi_ref</code>: 创建一个对象的引用以避免它被垃圾回收器回收。</li><li><code>napi_unref</code>: 删除之前设置的引用。</li></ul><p>假设你正在编写 C++扩展，并希望将一些 C++创建的数据传给 JavaScript，可以使用<code>napi_create_external()</code>。这样，你就能在 JS 中使用这些数据，同时确保在数据不再需要时能够正确地释放内存。</p><h3 id="实际应用的例子-创建一个外部-buffer" tabindex="-1"><a class="header-anchor" href="#实际应用的例子-创建一个外部-buffer"><span>实际应用的例子 - 创建一个外部 Buffer</span></a></h3><p>以下是一个简单的示例，展示如何在一个 N-API 模块中创建外部 Buffer：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个外部分配的数据源</span></span>
<span class="line"><span>char* external_data = (char*)malloc(1024);</span></span>
<span class="line"><span>size_t external_data_length = 1024;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是一个用来创建外部Buffer的函数</span></span>
<span class="line"><span>napi_value CreateExternalBuffer(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_value buffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个Buffer，它引用了外部分配的数据</span></span>
<span class="line"><span>  napi_create_external_buffer(env,</span></span>
<span class="line"><span>                              external_data_length,</span></span>
<span class="line"><span>                              external_data,</span></span>
<span class="line"><span>                              NULL, // 可选的，当Buffer被GC时调用的finalize回调</span></span>
<span class="line"><span>                              NULL, // finalize回调的hint参数</span></span>
<span class="line"><span>                              &amp;buffer);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return buffer;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在模块初始化时注册这个函数</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value externalBufferFunction;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 将CreateExternalBuffer函数暴露给JavaScript</span></span>
<span class="line"><span>  napi_create_function(env,</span></span>
<span class="line"><span>                       &quot;createExternalBuffer&quot;,</span></span>
<span class="line"><span>                       NAPI_AUTO_LENGTH,</span></span>
<span class="line"><span>                       CreateExternalBuffer,</span></span>
<span class="line"><span>                       NULL,</span></span>
<span class="line"><span>                       &amp;externalBufferFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 设置导出的属性</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;createExternalBuffer&quot;, externalBufferFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们使用 C 代码创建了一个外部数据源和一个函数<code>CreateExternalBuffer</code>，然后将这个函数暴露给了 JavaScript。当 JavaScript 代码调用这个函数时，它会返回一个 Node.js 的<code>Buffer</code>对象，这个对象引用了那块外部分配的内存。这样就可以在 Node.js 中直接操作这些数据，而不需要复制它们。注意，当你这样做的时候，必须确保在 JavaScript 层面上不再需要这个 Buffer 时，相应的内存也被释放了。</p><p>总的来说，内存管理是一项程序员必须关心的话题，尤其是在涉及到本机扩展的时候。正确的内存管理可以避免内存泄漏，提高程序稳定性和性能。</p><h3 id="napi-adjust-external-memory" tabindex="-1"><a class="header-anchor" href="#napi-adjust-external-memory"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_adjust_external_memory" target="_blank" rel="noopener noreferrer">napi_adjust_external_memory</a></span></a></h3><p>Node.js 中的<code>napi_adjust_external_memory</code>函数是一个用于通知 V8 引擎调整其跟踪的外部内存使用情况的 API。这个函数属于 Node.js 的 N-API，它是一个稳定的 API 层面，允许原生模块的作者编写与 Node.js 版本无关的代码。</p><p>首先我们需要了解几个概念：</p><ol><li><strong>V8 引擎</strong>：这是 Node.js 底层使用的 JavaScript 引擎，负责执行 JavaScript 代码。</li><li><strong>N-API</strong>：这是 Node.js 提供的一组 C 语言的 API，允许开发者编写本地插件。这些插件可以直接与 Node.js 底层进行交互，性能高效，并且不依赖于 Node.js 版本。</li><li><strong>外部内存</strong>：在创建原生插件时，可能会使用到非 V8 管理的内存资源，比如通过 C/C++分配的内存。这部分内存对于 V8 来说是“外部”的，因为 V8 的垃圾回收器无法直接管理这些内存。</li></ol><p>现在，来具体看<code>napi_adjust_external_memory</code>：</p><p>这个函数主要用途是手动告诉 V8，有多少外部内存正在被使用。因为 V8 自己的垃圾回收器并不知道这些外部内存的存在，没有这个信息，V8 可能就不会及时地进行垃圾收集，从而导致 Node.js 进程使用的总内存过大。</p><p><code>napi_adjust_external_memory</code>的使用方法大致如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在某个函数内部，你已经分配了一些外部内存：</span></span>
<span class="line"><span>void* buffer = malloc(1024); // 分配了1024字节的内存</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 然后你需要通知V8这1024字节的外部内存已经被使用</span></span>
<span class="line"><span>int64_t change_in_bytes = 1024;</span></span>
<span class="line"><span>int64_t adjusted_value;</span></span>
<span class="line"><span>napi_status status = napi_adjust_external_memory(env, change_in_bytes, &amp;adjusted_value);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if (status != napi_ok) {</span></span>
<span class="line"><span>  // 处理错误...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中：</p><ul><li><code>buffer</code>是通过 malloc 分配的堆内存，它在 C/C++的领域，但对 V8 引擎来说是外部的。</li><li>通过调用<code>napi_adjust_external_memory</code>，我们告诉 V8 有 1024 字节的外部内存被使用。</li><li><code>change_in_bytes</code>参数是我们刚刚分配或者释放的内存量。</li><li><code>adjusted_value</code>会返回调整后 V8 当前跟踪的外部内存总量。</li><li>我们也检查<code>status</code>变量以确保调用成功。</li></ul><p><strong>实际应用示例：</strong></p><p>假设你正在编写一个 Node.js 的原生拓展，该拓展需要处理图像。在处理过程中，你可能会分配大量内存来存储图像数据。如果处理多张图像，那么分配的内存将会相当可观。使用<code>napi_adjust_external_memory</code>就可以告诉 V8 引擎这个情况，以便 V8 可以在合适的时候运行垃圾收集器，避免应用程序消耗过多内存。</p><p>正确使用这个 API 有助于改善 Node.js 应用的性能和内存管理，特别是在处理大量数据且不希望影响 V8 垃圾回收行为时。</p><h2 id="promises" tabindex="-1"><a class="header-anchor" href="#promises"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#promises" target="_blank" rel="noopener noreferrer">Promises</a></span></a></h2><p>Node.js 是一个运行在服务器端的 JavaScript 运行环境，它允许你使用 JavaScript 来编写可以处理文件系统、网络通信等后端任务的程序。而 Promises 是 Node.js（以及现代 JavaScript）中用于处理异步操作的一种机制。</p><p>在深入解释 Promises 之前，我们需要理解“异步”这个概念。在编程中，“异步操作”指的是不会立即完成的操作，例如读取文件、查询数据库或发起网络请求。因为这些操作可能需要一些时间来完成，所以如果我们同步地（按顺序一步接一步地）等待它们完成，那么程序的其他部分就会被阻塞，无法执行。为了提高效率和用户体验，我们需要异步地处理这些操作。</p><p>Promises 就是为了简化异步编程而生的。一个 Promise 是一个代表未来将要结束的事件的对象。它有三种状态：</p><ol><li><strong>Pending（进行中）</strong>：初始状态，既没有被兑现，也没有被拒绝。</li><li><strong>Fulfilled（已兑现）</strong>：意味着操作成功完成。</li><li><strong>Rejected（已拒绝）</strong>：意味着操作失败。</li></ol><p>Promise 对象用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理这些状态。<code>.then()</code> 接收两个函数作为参数，第一个是当 Promise 状态变为 Fulfilled 时调用的，第二个是当 Promise 状态变为 Rejected 时调用的。<code>.catch()</code> 则是专门用来捕获 Promise 如果处于 Rejected 状态的情况。</p><p>下面是一些实际运用的例子：</p><h3 id="例子-1-读取文件" tabindex="-1"><a class="header-anchor" href="#例子-1-读取文件"><span>例子 1：读取文件</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">promises</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// Node.js 文件系统模块的 Promise 版本</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 异步读取一个文件的内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;example.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;utf8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 成功读取后，输出文件内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 如果读取失败，输出错误信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>fs.readFile</code> 是一个异步操作，它返回一个 Promise。如果文件读取成功，Promise 变为 Fulfilled 状态，并且 <code>.then()</code> 中的函数将被调用来输出文件内容。如果读取失败，Promise 变为 Rejected 状态，<code>.catch()</code> 中的函数将被调用来处理错误。</p><h3 id="例子-2-网络请求" tabindex="-1"><a class="header-anchor" href="#例子-2-网络请求"><span>例子 2：网络请求</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fetch</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;node-fetch&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// node-fetch 是一个用来发起网络请求的库</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;https://api.example.com/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 发起 GET 请求到指定的 URL</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">ok</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">      throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Network response was not ok&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> response</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 解析 JSON 数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 处理数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;There has been a problem with your fetch operation:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>fetch</code> 函数用来发起一个网络请求。它返回一个 Promise，该 Promise 在网络响应后被解决。如果响应状态良好，我们继续解析 JSON 数据，然后在下一个 <code>.then()</code> 块中处理它。如果网络请求失败或者响应状态不是 OK 的，我们通过抛出异常来直接触发 <code>.catch()</code> 块，打印出错信息。</p><h3 id="例子-3-链式操作" tabindex="-1"><a class="header-anchor" href="#例子-3-链式操作"><span>例子 3：链式操作</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> doSomethingElse</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">newResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> doThirdThing</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">newResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">finalResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`Got the final result: </span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">${</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">finalResult</span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">failureCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 假设这里是一些异步操作...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;first value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 操作成功，调用 resolve 并传入结果</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 如果有什么问题，应该调用 reject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> doSomethingElse</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 返回新的 Promise，依赖于前一个操作的结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 又是一些异步操作...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> newResult</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> `new result based on </span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">${</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">newResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> doThirdThing</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">newResult</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // ...又是依赖上一步结果的操作...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`third result based on </span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">${</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">newResult</span><span style="--shiki-light:#032F62;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">`</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们演示了如何用 <code>.then()</code> 方法来串联多个异步操作，每一步都根据上一步的结果来进行操作。最终，我们打印出最后的结果，或者在任何地方遇到错误时捕获并处理错误。</p><p>这些例子展示了在 Node.js 中使用 Promises 来处理异步操作的基本方式。由于 Promises 是原生支持的，因此它们与 Node.js 中的许多库和工具相互集成，大大简化了异步编程的复杂性。</p><h3 id="napi-create-promise" tabindex="-1"><a class="header-anchor" href="#napi-create-promise"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_promise" target="_blank" rel="noopener noreferrer">napi_create_promise</a></span></a></h3><p>Node.js 中的 <code>napi_create_promise</code> 是 N-API 的一部分，N-API 是一个用于构建原生插件的 C API。原生插件是使用 C 或 C++ 编写的模块，它们可以直接与 Node.js 运行时进行交互。<code>napi_create_promise</code> 允许原生代码创建一个 Promise 对象，这个对象可以和 JavaScript 中的 Promise 一样使用，以支持异步操作。</p><p>在 JavaScript 中，Promises 是处理异步操作的一种方式。当你有一个可能花费些时间执行的任务，比如从网络读取数据或者查询数据库，你通常会用到 Promise。一个 Promise 代表了一个尚未完成但预计将来会完成的动作，并且提供了一种方法来处理其结果。</p><p>现在，让我们看看 <code>napi_create_promise</code> 是如何工作的。下面是一个例子说明了在原生插件中如何创建一个 Promise：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value CreatePromise(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  napi_value promise;</span></span>
<span class="line"><span>  napi_deferred deferred;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 创建一个Promise对象</span></span>
<span class="line"><span>  napi_status status = napi_create_promise(env, &amp;deferred, &amp;promise);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 在此处执行异步任务...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 假设异步任务完成后，我们要解决（resolve）这个Promise</span></span>
<span class="line"><span>  // 首先创建一个表示成功结果的JavaScript值</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  status = napi_create_string_utf8(env, &quot;Success&quot;, NAPI_AUTO_LENGTH, &amp;result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 解决这个Promise</span></span>
<span class="line"><span>  status = napi_resolve_deferred(env, deferred, result);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回创建的Promise对象</span></span>
<span class="line"><span>  return promise;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册上面的函数为一个模块导出</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>  napi_value export_fn;</span></span>
<span class="line"><span>  napi_create_function(env, NULL, 0, CreatePromise, NULL, &amp;export_fn);</span></span>
<span class="line"><span>  napi_set_named_property(env, exports, &quot;createPromise&quot;, export_fn);</span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们定义了一个 <code>CreatePromise</code> 函数，它首先调用 <code>napi_create_promise</code> 来创建一个新的 Promise 对象和一个与之关联的 <code>napi_deferred</code> 对象。<code>napi_deferred</code> 对象用于稍后解决（fulfill）或拒绝（reject）这个 Promise。</p><p>该函数返回创建的 Promise 对象，然后你可以在 JavaScript 代码中调用这个原生函数获取 Promise 对象，并添加 <code>.then()</code>、<code>.catch()</code> 或 <code>.finally()</code> 回调来处理异步结果。</p><p>假设原生模块名为 <code>my_native_module</code>，我们可以在 JavaScript 中这样使用它：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> myNativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;my_native_module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> promise</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> myNativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createPromise</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">promise</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: &#39;Success&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>myNativeModule.createPromise()</code> 调用原生函数 <code>CreatePromise</code>，后者创建并返回一个 Promise。当异步操作完成后，如果成功，则由原生代码通过 <code>napi_resolve_deferred</code> 解决这个 Promise；如果失败，则通过 <code>napi_reject_deferred</code> 拒绝它。</p><p>记住，真正的异步操作应该在其他线程或者事件循环中发生，以避免阻塞 Node.js 的主线程。而本例中的异步操作被简化了，只是为了演示如何创建和使用 <code>napi_create_promise</code>。</p><h3 id="napi-resolve-deferred" tabindex="-1"><a class="header-anchor" href="#napi-resolve-deferred"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_resolve_deferred" target="_blank" rel="noopener noreferrer">napi_resolve_deferred</a></span></a></h3><p><code>napi_resolve_deferred</code> 是 Node.js 的 N-API（原生 API）中的一个功能。在 Node.js 中，N-API 提供了一个与 JavaScript 运行时交互的稳定层，允许创建可以跨多个 Node.js 版本运行的本地插件。</p><p>首先，要理解 <code>napi_resolve_deferred</code>，我们需要了解什么是 “deferred” 和 “promise”。在 JavaScript 中，Promise 是异步编程的一种很重要的概念，它代表了一个可能现在、也可能将来才会结束的操作，并且这个操作可以有两种结果：成功（resolved）或失败（rejected）。</p><p>Deferred 对象是 Promise 的来源，通常用于底层的实现。一个 deferred 包含了一个 promise 以及改变这个 promise 状态的方法（resolve 来表示成功，reject 表示失败）。你可以把 deferred 想象成带有控制按钮的 promise 工厂。</p><p>在使用 N-API 创建原生插件时，你可能会遇到这样的情况：你想要执行一些异步的本地操作（比如读取文件、访问数据库等），并且希望把结果传递回 JavaScript 层面。此时，你可以通过创建一个 deferred 对象和相应的 promise，然后当本地操作完成后，使用 <code>napi_resolve_deferred</code> 来解决（resolve）该 deferred 对象，从而使得 JavaScript 层面的 promise 变为 fulfilled 状态，并且将结果传递给任何等待这个 promise 的处理程序。</p><p><strong>例子：</strong></p><p>假设你正在编写一个原生插件，该插件提供了一个异步函数 <code>doSomethingAsyncNative</code>，该函数在本地执行一些操作，并在结束时返回一个结果。这里展示如何使用 <code>napi_resolve_deferred</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 异步工作结构体，用于传递数据到异步执行函数和完成回调</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>    napi_deferred deferred;</span></span>
<span class="line"><span>    napi_async_work work;</span></span>
<span class="line"><span>    // 其他需要传递到异步工作中的数据</span></span>
<span class="line"><span>} AsyncWorkData;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 异步执行函数，此处为假设函数</span></span>
<span class="line"><span>void ExecuteAsyncWork(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 执行一些耗时的操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 假设完成后的结果是一个整数</span></span>
<span class="line"><span>    int result = 42;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将结果存储在 AsyncWorkData 结构中以供完成回调使用</span></span>
<span class="line"><span>    ((AsyncWorkData*)data)-&gt;result = result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 完成回调函数</span></span>
<span class="line"><span>void CompleteAsyncWork(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>    AsyncWorkData* asyncWorkData = (AsyncWorkData*)data;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (status == napi_ok) {</span></span>
<span class="line"><span>        // 创建一个JavaScript数字以包装结果</span></span>
<span class="line"><span>        napi_value jsResult;</span></span>
<span class="line"><span>        napi_create_int32(env, asyncWorkData-&gt;result, &amp;jsResult);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 解决 deferred，即解决关联的 promise 并传递结果</span></span>
<span class="line"><span>        napi_resolve_deferred(env, asyncWorkData-&gt;deferred, jsResult);</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果有错误，拒绝 promise</span></span>
<span class="line"><span>        napi_reject_deferred(env, asyncWorkData-&gt;deferred, NULL);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 删除异步工作项</span></span>
<span class="line"><span>    napi_delete_async_work(env, asyncWorkData-&gt;work);</span></span>
<span class="line"><span>    free(asyncWorkData);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 绑定到 JavaScript 的表示异步操作的函数</span></span>
<span class="line"><span>napi_value DoSomethingAsyncNative(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建一个 deferred 和 promise</span></span>
<span class="line"><span>    napi_deferred deferred;</span></span>
<span class="line"><span>    napi_value promise;</span></span>
<span class="line"><span>    napi_create_promise(env, &amp;deferred, &amp;promise);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 分配 AsyncWorkData 结构并初始化</span></span>
<span class="line"><span>    AsyncWorkData* asyncWorkData = malloc(sizeof(AsyncWorkData));</span></span>
<span class="line"><span>    asyncWorkData-&gt;deferred = deferred;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建和队列异步工作</span></span>
<span class="line"><span>    napi_create_async_work(env, NULL, NULL, ExecuteAsyncWork, CompleteAsyncWork, asyncWorkData, &amp;asyncWorkData-&gt;work);</span></span>
<span class="line"><span>    napi_queue_async_work(env, asyncWorkData-&gt;work);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回 promise 给 JavaScript</span></span>
<span class="line"><span>    return promise;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码展示了如何在原生模块中使用 <code>napi_resolve_deferred</code>。我们定义了一个 <code>DoSomethingAsyncNative</code> 函数，它创建了一个异步任务并立即返回一个 promise。当这个异步任务完成时，它将调用 <code>CompleteAsyncWork</code> 回调函数，在这个回调中，我们最终调用了 <code>napi_resolve_deferred</code> 来解决 promise，如果异步工作成功，则返回结果；如果失败，则拒绝 promise。</p><p>请注意，这个例子是对 N-API 使用方式的简化说明，实际使用时还需要考虑错误处理、内存管理等更多因素。</p><h3 id="napi-reject-deferred" tabindex="-1"><a class="header-anchor" href="#napi-reject-deferred"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_reject_deferred" target="_blank" rel="noopener noreferrer">napi_reject_deferred</a></span></a></h3><p>Node.js 中的 <code>napi_reject_deferred</code> 是一个用于 N-API（Native API）的函数，它允许你在编写原生插件时拒绝一个之前创建的延迟对象（Deferred）。首先，我们要理解几个关键概念：</p><ol><li><p><strong>N-API</strong>：这是 Node.js 提供的一套 C 语言的 API，允许你编写可以直接与 JavaScript 交互的原生插件。原生插件通常是为了提高性能或者利用 C/C++ 库。</p></li><li><p><strong>Promise</strong>：这是 JavaScript 中的一个对象，代表一个异步操作的最终完成（或失败），以及它的结果值。</p></li><li><p><strong>Deferred</strong>：这是实现 Promise 功能的一种方式。当你创建一个 Deferred 对象时，实际上你获得了控制相应 Promise 解决（resolve）或拒绝（reject）的能力。简单来说，Deferred 具有解决和拒绝两个操作，分别对应 Promise 的成功和失败状态。</p></li></ol><p>现在，让我们谈谈 <code>napi_reject_deferred</code> 函数的作用。此函数用于拒绝一个已经创建的 Deferred 对象，这意味着与该 Deferred 相关联的 Promise 将会以失败结束，并且你可以指定错误原因。</p><p>下面是 <code>napi_reject_deferred</code> 函数的定义：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_reject_deferred(napi_env env,</span></span>
<span class="line"><span>                                 napi_deferred deferred,</span></span>
<span class="line"><span>                                 napi_value rejection);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>：环境句柄，用于表示 Node.js 运行时的上下文。</li><li><code>deferred</code>：Deferred 对象的句柄，之前使用 <code>napi_create_promise</code> 创建。</li><li><code>rejection</code>：一个 <code>napi_value</code>，表示拒绝的原因，通常是一个 Error 对象。</li></ul><h3 id="实践示例" tabindex="-1"><a class="header-anchor" href="#实践示例"><span>实践示例</span></a></h3><p>假设你正在编写一个原生模块，它需要执行一个长时间运行的操作，例如从网络下载文件。你希望提供一个函数，返回一个 Promise，在操作完成时解决，如果出现错误则拒绝。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 模拟的异步操作回调</span></span>
<span class="line"><span>void download_complete_callback(bool is_success, napi_deferred deferred, napi_env env) {</span></span>
<span class="line"><span>    if (is_success) {</span></span>
<span class="line"><span>        // 假设下载成功，我们解决 Promise</span></span>
<span class="line"><span>        napi_value undefined;</span></span>
<span class="line"><span>        napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>        napi_resolve_deferred(env, deferred, undefined);</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 如果下载失败，我们拒绝 Promise</span></span>
<span class="line"><span>        napi_value error;</span></span>
<span class="line"><span>        napi_create_string_utf8(env, &quot;Download failed&quot;, NAPI_AUTO_LENGTH, &amp;error);</span></span>
<span class="line"><span>        napi_reject_deferred(env, deferred, error);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 你的原生模块导出的函数</span></span>
<span class="line"><span>napi_value start_download(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    napi_value promise;</span></span>
<span class="line"><span>    napi_deferred deferred;</span></span>
<span class="line"><span>    napi_create_promise(env, &amp;deferred, &amp;promise);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 执行异步下载操作 ...</span></span>
<span class="line"><span>    // 假设下载完成后会调用 `download_complete_callback`</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return promise; // 返回 Promise 给 JavaScript 调用者</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们通过 N-API 创建了一个 Promise 和一个相关联的 Deferred。然后我们开始一个异步的下载操作，并且在下载完成时调用 <code>download_complete_callback</code>。根据操作成功或者失败，我们调用 <code>napi_resolve_deferred</code> 或者 <code>napi_reject_deferred</code> 来改变 Promise 的状态。</p><p>在 JavaScript 中使用时可能像这样：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;your-native-module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeModule</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">start_download</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;下载成功&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;下载失败:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 <code>napi_reject_deferred</code> 的基本概念、用法，以及在实际情况中如何使用它来管理原生模块中的异步操作。</p><h3 id="napi-is-promise" tabindex="-1"><a class="header-anchor" href="#napi-is-promise"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_is_promise" target="_blank" rel="noopener noreferrer">napi_is_promise</a></span></a></h3><p><code>napi_is_promise</code> 是 Node.js 中的一个 API 函数，属于 N-API。N-API 是一套用 C 或 C++ 编写的原生插件的接口，允许你创建可以在不同版本的 Node.js 中稳定运行的原生模块。</p><p>具体来说，<code>napi_is_promise</code> 函数用来检查一个给定的 N-API 值是否是一个 Promise 对象。在 JavaScript 中，Promise 是处理异步操作的常用方式。当你有一个异步任务，如从文件系统读取文件或从网络请求数据时，你可能会使用 Promise 来管理这些异步操作。</p><p>下面是对 <code>napi_is_promise</code> 函数的解释：</p><ol><li><p><strong>函数作用</strong>：该函数用来识别一个 N-API 值是否是一个 Promise。如果是，那么你可以对其进行 Promise 相关的操作，比如 then、catch 等。</p></li><li><p><strong>参数</strong>：<code>napi_is_promise</code> 接受两个参数：</p><ul><li><code>env</code>：当前执行环境。</li><li><code>value</code>：待检查的 N-API 值。</li><li><code>is_promise</code>：输出参数，指向布尔值的指针，如果 <code>value</code> 是 Promise，则设置为 <code>true</code>，否则设置为 <code>false</code>。</li></ul></li><li><p><strong>返回值</strong>：返回状态码，通常这些状态码表示操作是否成功。在正常情况下，你会得到 <code>napi_ok</code> 表示没有发生错误。</p></li></ol><p>现在，让我们通过一个实际的例子来说明怎样使用 <code>napi_is_promise</code>。假设你正在编写一个原生模块，并且你想提供一个函数，这个函数接受一个参数，但是你需要验证这个参数是否为 Promise。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个 N-API 的原生函数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value args[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, args, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 检查是否传入了至少一个参数</span></span>
<span class="line"><span>    if (argc `&lt;` 1) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Function expects a parameter.&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确认这个参数是否为 Promise</span></span>
<span class="line"><span>    bool is_promise = false;</span></span>
<span class="line"><span>    napi_is_promise(env, args[0], &amp;is_promise);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (is_promise) {</span></span>
<span class="line"><span>        // 参数是 Promise，可以执行一些与 Promise 相关的操作</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        // 参数不是 Promise，抛出异常或者进行其他处理</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Expected a Promise.&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回 undefined</span></span>
<span class="line"><span>    napi_value undefined;</span></span>
<span class="line"><span>    napi_get_undefined(env, &amp;undefined);</span></span>
<span class="line"><span>    return undefined;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，注册 MyFunction</span></span>
<span class="line"><span>NAPI_MODULE_INIT() {</span></span>
<span class="line"><span>    napi_value fn;</span></span>
<span class="line"><span>    napi_create_function(env, NULL, 0, MyFunction, NULL, &amp;fn);</span></span>
<span class="line"><span>    napi_set_named_property(env, exports, &quot;myFunction&quot;, fn);</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，我们定义了一个名为 <code>MyFunction</code> 的原生函数，它检查传递给它的第一个参数是否为 Promise，并据此进行相应的处理。</p><p>要注意的是，这个代码片段是用 C 语言编写的，如果你是 Node.js 开发者而不是插件作者，你可能不需要直接与这类底层代码打交道。对于 JavaScript 开发者来说，Node.js 引擎已经内置了对 Promises 的支持，您通常会直接使用 JavaScript 的 <code>Promise</code> 类来处理异步流程。</p><h2 id="script-execution" tabindex="-1"><a class="header-anchor" href="#script-execution"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#script-execution" target="_blank" rel="noopener noreferrer">Script execution</a></span></a></h2><p>Node.js 是一个基于 Chrome V8 JavaScript 引擎的 JavaScript 运行环境。它允许你在服务器端运行 JavaScript 代码，这意味着你可以用 JavaScript 写程序来处理网站后台逻辑、数据库操作，以及构建可扩展的网络应用等。</p><p>在 Node.js 的文档中，&quot;Script execution&quot; 指的是如何在 Node.js 环境中执行 JavaScript 脚本。这里特别涉及 N-API（Node.js API），它是一个为了构建原生插件而设计的稳定的 API 层。N-API 允许开发者不必担心底层 JavaScript 引擎的变化而影响他们的模块。开发者可以通过使用 N-API 编写与 Node.js 版本无关的代码，从而提升原生模块的兼容性和稳定性。</p><p>下面我将用一些实际的例子来解释 Node.js 中的脚本执行：</p><h3 id="示例-1-执行简单脚本" tabindex="-1"><a class="header-anchor" href="#示例-1-执行简单脚本"><span>示例 1: 执行简单脚本</span></a></h3><p>假设你有一个简单的 JavaScript 文件 <code>hello.js</code>，内容如下：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在 Node.js 中执行这个脚本很简单。你只需在终端中运行以下命令：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">node</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> hello.js</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行后，你将看到控制台输出 &quot;Hello, World!&quot;。</p><h3 id="示例-2-使用-n-api-执行脚本" tabindex="-1"><a class="header-anchor" href="#示例-2-使用-n-api-执行脚本"><span>示例 2: 使用 N-API 执行脚本</span></a></h3><p>N-API 主要用于编写 C 或 C++ 的扩展，然后通过 JavaScript 调用这些扩展。当你需要更高性能或者需要在 Node.js 中使用一些 JavaScript 原生不支持的功能时，N-API 就派上用场。</p><p>例如，我们有一个 C++ 函数，用于计算两个数字的和，并希望能在 Node.js 中调用它。首先我们需要使用 N-API 来创建一个包装函数（binding）：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include `&lt;`node.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Add(const v8::FunctionCallbackInfo`&lt;`v8::Value&gt;&amp; args) {</span></span>
<span class="line"><span>  v8::Isolate* isolate = args.GetIsolate();</span></span>
<span class="line"><span>  int sum = args[0].As`&lt;`v8::Number&gt;()-&gt;Value() + args[1].As`&lt;`v8::Number&gt;()-&gt;Value();</span></span>
<span class="line"><span>  auto result = v8::Number::New(isolate, sum);</span></span>
<span class="line"><span>  args.GetReturnValue().Set(result);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void Initialize(v8::Local`&lt;`v8::Object&gt; exports) {</span></span>
<span class="line"><span>  NODE_SET_METHOD(exports, &quot;add&quot;, Add);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在 Node.js 中，我们可以加载并使用这个原生模块：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> nativeAddon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nativeAddon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出：8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例中，我们首先在 C++ 代码中定义了一个 <code>Add</code> 函数，然后通过 <code>NODE_MODULE</code> 宏将其暴露给 Node.js。在 JavaScript 代码中，我们通过 <code>require</code> 加载编译后的模块文件，并调用 <code>add</code> 方法。</p><p>请注意，N-API 相关的代码编写比较低级且复杂，通常只有在性能非常关键或需要使用 Node.js 不直接支持的系统级功能时，才会考虑使用。</p><p>以上就是对 Node.js 脚本执行和 N-API 的一个简介和实例说明。希望这对你理解 Node.js 的脚本执行有所帮助！</p><h3 id="napi-run-script" tabindex="-1"><a class="header-anchor" href="#napi-run-script"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_run_script" target="_blank" rel="noopener noreferrer">napi_run_script</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它让开发者能够在服务器端运行 JavaScript 代码。N-API（Node.js API）是 Node.js 提供的一组 C 语言接口，允许原生插件的编写者不受 Node.js 版本变化的影响，提高其稳定性和维护性。</p><p><code>napi_run_script</code> 是 N-API 的一个函数，它使得原生模块可以执行一个字符串中包含的 JavaScript 代码，并获取执行结果。这个功能类似于在全局作用域中调用 <code>eval()</code> 函数，但是 <code>napi_run_script</code> 是由 N-API 提供的，因此它是在 C 或 C++ 代码中使用的。</p><p>下面我会详细解释 <code>napi_run_script</code> 功能，并给出一个如何在实际中使用它的例子。</p><h3 id="函数原型-5" tabindex="-1"><a class="header-anchor" href="#函数原型-5"><span>函数原型</span></a></h3><p>在 Node.js 的 N-API 文档中，<code>napi_run_script</code> 的函数原型是：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_status napi_run_script(napi_env env,</span></span>
<span class="line"><span>                            napi_value script,</span></span>
<span class="line"><span>                            napi_value* result);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>env</code>: 这是一个表示 N-API 调用环境的句柄。</li><li><code>script</code>: 这是一个包含了要执行的 JavaScript 代码的 N-API 值。</li><li><code>result</code>: 这是一个指向 N-API 值的指针，在函数执行成功后，它将指向脚本的返回值。</li></ul><h3 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用"><span>如何使用</span></a></h3><p>为了使用 <code>napi_run_script</code>，你需要完成下面的步骤：</p><ol><li>编写一个原生模块，其中包含 C/C++ 代码，调用 <code>napi_run_script</code> 函数。</li><li>创建一个 JavaScript 字符串，包含你想要执行的代码。</li><li>将这个字符串转换为 N-API 值（<code>napi_value</code>）。</li><li>调用 <code>napi_run_script</code> 并传入该 N-API 值。</li><li>获取执行的结果，并处理它。</li></ol><h3 id="实际例子-10" tabindex="-1"><a class="header-anchor" href="#实际例子-10"><span>实际例子</span></a></h3><p>假设我们想在一个原生模块中执行一段 JavaScript 代码来计算两数之和并返回结果。</p><p>首先，你需要包含 Node.js 的 N-API 头文件，然后编写一个原生函数，比如 <code>ExecuteScript</code>：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设 &#39;env&#39; 和 &#39;exports&#39; 已经通过初始化函数获得</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value ExecuteScript(napi_env env, const char* code) {</span></span>
<span class="line"><span>    napi_value script, result;</span></span>
<span class="line"><span>    napi_status status;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将 C 字符串转换为 N-API 的字符串值</span></span>
<span class="line"><span>    status = napi_create_string_utf8(env, code, NAPI_AUTO_LENGTH, &amp;script);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 执行 JavaScript 代码</span></span>
<span class="line"><span>    status = napi_run_script(env, script, &amp;result);</span></span>
<span class="line"><span>    if (status != napi_ok) return nullptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回执行结果</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在你可以使用这个函数来执行脚本了。例如，下面的代码片段执行了一个简单的相加操作：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 在原生模块中调用 ExecuteScript</span></span>
<span class="line"><span>napi_value sum_result = ExecuteScript(env, &quot;1 + 2&quot;);</span></span>
<span class="line"><span>if (sum_result == nullptr) {</span></span>
<span class="line"><span>    // 错误处理</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：在真实的应用中，你需要检查每次 N-API 调用的返回状态以确保没有错误发生。如果有错误发生，你应该适当地处理它们。</p><p>总结起来，<code>napi_run_script</code> 让你能够在 N-API 插件中执行 JavaScript 代码，并且可以在 C/C++ 中处理执行结果。它主要用于那些需要从本地代码中动态运行 JavaScript 代码的场景。</p><h2 id="libuv-event-loop" tabindex="-1"><a class="header-anchor" href="#libuv-event-loop"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#libuv-event-loop" target="_blank" rel="noopener noreferrer">libuv event loop</a></span></a></h2><p>好的，让我来解释一下 Node.js 中的 libuv event loop。</p><p>在计算中，事件循环是一个编程构造，它等待并发送消息或事件。Node.js 使用 libuv 库，这是一个跨平台的 C 库，用于处理异步 I/O（输入/输出）操作和实现事件循环。</p><p>在 Node.js 中，当你启动一个应用时，Node.js 实例会创建一个事件循环。这个事件循环是用来处理非阻塞的异步操作的，比如：</p><ul><li>文件系统操作（读写文件）</li><li>网络请求（HTTP, TCP, UDP 等）</li><li>定时器（setTimeout, setInterval）</li><li>用户自定义事件</li></ul><p>实际上，libuv 将这些操作转化为底层的系统调用，并且在操作完成时，它将结果返回给 Node.js ，然后 Node.js 能够继续执行 JavaScript 回调函数。</p><p>事件循环主要分为几个阶段:</p><ol><li><strong>定时器阶段</strong> - 这里检查 setTimeout 和 setInterval 回调。</li><li><strong>I/O 回调阶段</strong> - 处理某些系统操作的回调，如 TCP 错误。</li><li><strong>空闲、准备阶段</strong> - 在这个阶段内部准备工作。</li><li><strong>轮询阶段</strong> - 检索新的 I/O 事件; 执行与 I/O 相关的回调，几乎所有情况下都会处理。</li><li><strong>检查阶段</strong> - setImmediate() 回调在这里执行。</li><li><strong>关闭回调阶段</strong> - 比如 socket.on(&#39;close&#39;, ...)。</li></ol><p>了解这些概念后，让我们来看一些实际的例子。</p><h3 id="例子-1-文件读取" tabindex="-1"><a class="header-anchor" href="#例子-1-文件读取"><span>例子 1：文件读取</span></a></h3><p>假设你要读取一个大文件。在同步操作中，你的程序会停在那里直到整个文件都被读取。但在 Node.js 中，你可以这样做：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;fs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">fs</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;/path/to/a-large-file.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 <code>fs.readFile</code> 被调用时，Node.js 会将文件读取操作交给 libuv，然后继续执行事件循环的下一个任务。一旦文件读取完成，读取文件的回调就会被加入到事件循环中以供执行。</p><h3 id="例子-2-网络请求-1" tabindex="-1"><a class="header-anchor" href="#例子-2-网络请求-1"><span>例子 2：网络请求</span></a></h3><p>考虑这样一个 HTTP 服务器：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> http</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;http&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> http</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">createServer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  res</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">writeHead</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, { </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Content-Type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;text/plain&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  res</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Hello World</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">server</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">8080</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Server running at http://127.0.0.1:8080/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Node.js 启动 HTTP 服务器并监听端口 8080。每当有 HTTP 请求到达服务器时，事件循环就会运行回调函数，无论何时，只要准备好了，就会向客户端发送 &quot;Hello World&quot; 响应。</p><h3 id="例子-3-实时聊天应用" tabindex="-1"><a class="header-anchor" href="#例子-3-实时聊天应用"><span>例子 3：实时聊天应用</span></a></h3><p>如果你创建一个实时聊天应用，服务器需要同时处理多个客户端的消息。使用 Node.js 和 WebSocket，你可以这样做：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> WebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;ws&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> wss</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> WebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Server</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">({ </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">port</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">8080</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">wss</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;connection&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> connection</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">ws</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  ws</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> incoming</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;received: %s&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  ws</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;something&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每当一个新的客户端连接到 WebSocket 服务器时，&#39;connection&#39; 事件就会被触发，并传递一个代表该连接的 <code>ws</code> 对象。然后，你可以在这个对象上监听消息事件。由于 Node.js 是非阻塞的，因此可以同时服务于许多客户端，而不会因为单个操作而卡住。</p><p>总之，libuv 事件循环让 Node.js 能够高效地处理异步操作，它使得 Node.js 特别适合 I/O 密集型任务，而不必担心程序性能的问题。</p><h3 id="napi-get-uv-event-loop" tabindex="-1"><a class="header-anchor" href="#napi-get-uv-event-loop"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_uv_event_loop" target="_blank" rel="noopener noreferrer">napi_get_uv_event_loop</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建原生插件的 API。N-API 设计的目标是不依赖于 JavaScript 引擎的版本，这意味着使用 N-API 编写的插件可以在不同版本的 Node.js 上运行，而无需重新编译。</p><p>在 Node.js 中，<code>napi_get_uv_event_loop</code> 是一个函数，它允许你从 N-API 插件中访问 Node.js 的底层事件循环。事件循环是 Node.js 异步操作的核心，它负责调度并管理所有异步事件和操作，如文件 I/O、网络请求等。Node.js 使用了 libuv 作为其事件循环的实现，libuv 是一个跨平台的异步 I/O 库。</p><p>现在，让我们深入理解 <code>napi_get_uv_event_loop</code> 函数：</p><h3 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h3><p>当你在创建一个原生模块（也就是 C 或 C++ 编写的扩展）时，可能需要与 Node.js 的事件循环进行交互。通过 <code>napi_get_uv_event_loop</code> 函数，你可以获取指向事件循环的指针，然后在你的原生代码中使用 libuv 提供的各种功能。</p><h3 id="示例-3" tabindex="-1"><a class="header-anchor" href="#示例-3"><span>示例</span></a></h3><p>假设你正在开发一个原生模块，该模块需要执行一个异步操作，例如读取某个硬件设备的状态。在这种情况下，你可以使用 <code>napi_get_uv_event_loop</code> 来获得事件循环，并使用 libuv 提供的相关函数来创建一个异步请求。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>#include `&lt;`uv.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个异步工作结构体，用于保存你的数据和回调</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  uv_work_t request; // libuv</span></span>
<span class="line"><span>  napi_ref callback; // N-API</span></span>
<span class="line"><span>  // 其他需要的自定义数据...</span></span>
<span class="line"><span>} my_async_work;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是你的异步工作的执行函数</span></span>
<span class="line"><span>static void MyAsyncExecute(uv_work_t* req) {</span></span>
<span class="line"><span>  my_async_work* work = (my_async_work*)req-&gt;data;</span></span>
<span class="line"><span>  // 执行一些耗时的任务，比如读取硬件状态...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是完成耗时任务之后的回调函数</span></span>
<span class="line"><span>static void MyAsyncComplete(napi_env env, napi_status status, void* data) {</span></span>
<span class="line"><span>  my_async_work* work = (my_async_work*)data;</span></span>
<span class="line"><span>  // 调用 JavaScript 回调函数，传递结果...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是 N-API 暴露给 JavaScript 的函数</span></span>
<span class="line"><span>napi_value MyFunction(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>  // 获取事件循环</span></span>
<span class="line"><span>  uv_loop_t* loop;</span></span>
<span class="line"><span>  napi_get_uv_event_loop(env, &amp;loop);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 分配和初始化你的异步工作结构体</span></span>
<span class="line"><span>  my_async_work* work = (my_async_work*)malloc(sizeof(my_async_work));</span></span>
<span class="line"><span>  work-&gt;request.data = work;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 省略：解析 JavaScript 传递的参数，包括回调函数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 把你的异步请求排队到事件循环</span></span>
<span class="line"><span>  uv_queue_work(loop, &amp;work-&gt;request, MyAsyncExecute, MyAsyncComplete);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 返回一些值给 JavaScript</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  napi_get_undefined(env, &amp;result);</span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>MyFunction</code> 被暴露为一个可以从 JavaScript 调用的函数。当 JavaScript 代码调用这个函数时，它会初始化一个异步工作请求，并将其排队到 Node.js 的事件循环中。当异步任务执行完成后，<code>MyAsyncComplete</code> 将被调用，以便给 JavaScript 传递结果。</p><p>请注意，真实情况下的错误处理和内存管理会更复杂，这里的示例只是为了说明如何使用 <code>napi_get_uv_event_loop</code>。</p><p>总结起来，<code>napi_get_uv_event_loop</code> 让你的原生模块能够利用 Node.js 的事件循环机制来执行异步任务，使得原生模块可以像 Node.js 中的 JavaScript 代码那样非阻塞地运行。</p><h2 id="asynchronous-thread-safe-function-calls" tabindex="-1"><a class="header-anchor" href="#asynchronous-thread-safe-function-calls"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#asynchronous-thread-safe-function-calls" target="_blank" rel="noopener noreferrer">Asynchronous thread-safe function calls</a></span></a></h2><p>Node.js 是一个基于 JavaScript 的后端平台，它允许你使用 JavaScript 编写服务器端代码。它的优势在于非阻塞性 I/O 模型，这使得它很适合处理高并发情况。</p><p>在 Node.js 中，大部分操作都是异步的，比如文件读取、网络请求等，这些操作不会立即完成，所以它们不会阻塞程序的其他部分。然而，在某些情况下，我们可能需要执行 CPU 密集型任务或一些阻塞性操作，如果这些操作在 Node.js 的主线程上执行，就会影响整个应用的性能。</p><p>为此，Node.js 提供了<code>n-api</code>来创建本地插件，以便利用 C 或者 C++增强 Node.js 的性能。<code>n-api</code>还允许开发者在不同的线程中运行代码，这样做的好处是可以进行一些复杂的计算而不阻塞主事件循环。</p><p>&quot;异步线程安全函数调用（Asynchronous Thread-safe Function Calls）&quot; 是<code>n-api</code>提供的一个特性，它允许原生代码（例如 C/C++模块）在任何线程上安全地调用 JavaScript 函数。这是通过<code>Thread-safe function</code>来实现的。</p><h3 id="thread-safe-function" tabindex="-1"><a class="header-anchor" href="#thread-safe-function"><span>Thread-safe function</span></a></h3><p>这是一种特殊类型的函数，可以让你从任何线程安全地调用 JavaScript 回调函数。即使你的代码在不同的线程上运行，并且这些线程尝试并发地调用 JavaScript 代码，使用 Thread-safe function 也可以确保不会发生冲突或竞争条件。</p><h3 id="实际应用例子-2" tabindex="-1"><a class="header-anchor" href="#实际应用例子-2"><span>实际应用例子</span></a></h3><p>假设你正在编写一个图像处理应用，用户上传图片，你的服务需要对其进行压缩和格式转换。这个处理过程是 CPU 密集型的，如果在 Node.js 的主线程上进行，将会造成服务器响应迟缓。为了解决这个问题，你可以编写一个 C++扩展，使用 N-API 创建一个线程安全的函数。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`napi.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 工作函数，可能在后台线程上运行</span></span>
<span class="line"><span>void ProcessImage(const Napi::CallbackInfo&amp; info) {</span></span>
<span class="line"><span>    // ... 图像处理逻辑 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当完成工作时，调用JavaScript的回调函数</span></span>
<span class="line"><span>    Napi::ThreadSafeFunction tsfn = info[0].As`&lt;`Napi::ThreadSafeFunction&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 通知Node.js线程要调用的回调函数</span></span>
<span class="line"><span>    napi_status status = tsfn.BlockingCall([](Napi::Env env, Napi::Function jsCallback) {</span></span>
<span class="line"><span>        // 调用JavaScript层面的回调，并传递结果</span></span>
<span class="line"><span>        jsCallback.Call({Napi::String::New(env, &quot;处理完成&quot;)});</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 确保释放线程安全函数资源</span></span>
<span class="line"><span>    tsfn.Release();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 初始化函数，设置导出</span></span>
<span class="line"><span>Napi::Object Init(Napi::Env env, Napi::Object exports) {</span></span>
<span class="line"><span>    exports.Set(</span></span>
<span class="line"><span>        Napi::String::New(env, &quot;processImage&quot;),</span></span>
<span class="line"><span>        Napi::Function::New(env, ProcessImage)</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NODE_API_MODULE(addon, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 代码中，你会像这样调用这个扩展：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> addon</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;./build/Release/addon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> callback</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 输出: &#39;处理完成&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">addon</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">processImage</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>processImage</code>是一个异步函数，它启动了一个后台线程来处理图像，并且不会阻塞 Node.js 的主事件循环。一旦图像处理完成，它将安全地调用 JavaScript 层面的<code>callback</code>回调函数，即使这个调用发生在另一个线程上。</p><h3 id="calling-a-thread-safe-function" tabindex="-1"><a class="header-anchor" href="#calling-a-thread-safe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#calling-a-thread-safe-function" target="_blank" rel="noopener noreferrer">Calling a thread-safe function</a></span></a></h3><p>好的，让我们来深入了解 Node.js 中调用线程安全函数的概念。在 Node.js v21.7.1 文档中，关于&quot;Calling a thread-safe function&quot;是指使用 N-API 中提供的一种机制，来从任何线程安全地调用 JavaScript 函数。</p><p>首先需要明白几个关键点：</p><ol><li><p><strong>JavaScript 单线程性质</strong>：JavaScript 是单线程运行的，这意味着它一次只能执行一个任务。但在现实世界的应用中，我们经常需要执行后台任务（如文件读写、网络请求等），而不阻塞主线程。</p></li><li><p><strong>Node.js 的异步非阻塞 I/O</strong>：Node.js 通过事件循环和回调函数，使得可以非阻塞地处理这些耗时操作。</p></li><li><p><strong>多线程</strong>：尽管 JavaScript 是单线程的，但 Node.js 可以通过 C++扩展或者新的 Worker Threads 模块创建多线程。</p></li><li><p><strong>线程安全</strong>：当多个线程尝试同时访问和修改同一数据时，如果没有适当的同步，就会导致竞态条件。线程安全是指代码在多线程环境下执行时，能够正确处理访问共享资源的逻辑，以避免错误和数据损坏。</p></li></ol><p>现在，当我们需要在一个 Node.js 的原生模块（通常是用 C++编写）中的一个工作线程上运行代码，并且想要在某个时刻回到 JavaScript 环境中执行一些 JavaScript 代码时，我们就需要用到线程安全函数。N-API 提供了<code>napi_create_threadsafe_function</code>和相关 APIs 来创建这样一种函数。</p><p>让我们通过一个例子来说明这一点：</p><p>假设你正在编写一个 Node.js 原生模块，该模块需要执行 CPU 密集型的图像处理任务。因为这个任务可能需要几秒钟，所以你决定将其放在一个单独的工作线程中进行，以免阻塞 Node.js 的主线程。当图像处理完成后，你想通知 JavaScript 代码并发送结果回去。这里就可以使用线程安全函数了。</p><p>以下是该过程的简化步骤：</p><ol><li><p>在你的原生模块中，使用<code>napi_create_threadsafe_function</code>创建一个线程安全函数。你将提供一个 JavaScript 回调函数，在适当的时候，这个线程安全函数将被调用。</p></li><li><p>从工作线程中，当你完成了图像处理任务，使用<code>napi_call_threadsafe_function</code>调用这个线程安全函数，并传递处理后的图像数据。</p></li><li><p>这个线程安全函数将按照 Node.js 的规则安全地把控制权交还给 JavaScript 环境，并调用 Step 1 中提供的 JavaScript 回调函数，将图像处理结果传递给它。</p></li></ol><p>具体代码可能如下所示：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value MyNativeModuleInit(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // 执行一些初始化工作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建线程安全函数</span></span>
<span class="line"><span>    napi_value my_js_cb;</span></span>
<span class="line"><span>    // 假设my_js_callback_ref是已绑定的JavaScript回调函数的引用</span></span>
<span class="line"><span>    napi_get_reference_value(env, my_js_callback_ref, &amp;my_js_cb);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_threadsafe_function tsfn;</span></span>
<span class="line"><span>    napi_create_threadsafe_function(env, my_js_cb, NULL, &quot;MyThreadsafeFunction&quot;, 0, 1, NULL, NULL, NULL, MyCallJs, &amp;tsfn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 启动工作线程，传递线程安全函数给它</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void MyImageProcessingThread(void* data) {</span></span>
<span class="line"><span>    // ...执行图像处理...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 处理完毕，现在调用线程安全函数</span></span>
<span class="line"><span>    napi_call_threadsafe_function(tsfn, processed_image_data, napi_tsfn_blocking);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 被线程安全函数内部调用以触发JavaScript端的回调</span></span>
<span class="line"><span>void MyCallJs(napi_env env, napi_value js_cb, void* context, void* data) {</span></span>
<span class="line"><span>    // 创建一个napi_value来包装data，然后作为参数传递给回调函数js_cb</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码是一个高级概述，真正的实现将涉及更多细节，比如错误处理、资源清理等。通过使用线程安全函数，原生模块可以在不阻塞 Node.js 主线程的情况下，安全地协调 JavaScript 和 C++代码之间的交互。</p><h3 id="reference-counting-of-thread-safe-functions" tabindex="-1"><a class="header-anchor" href="#reference-counting-of-thread-safe-functions"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#reference-counting-of-thread-safe-functions" target="_blank" rel="noopener noreferrer">Reference counting of thread-safe functions</a></span></a></h3><p>Node.js 中的 N-API 是一套用于构建原生插件的 API。这些原生插件允许你用 C 或 C++编写代码，然后在 Node.js 环境中运行。这通常用于执行性能密集型任务，如数学计算、图像处理或与系统底层硬件交互。</p><h3 id="reference-counting-of-thread-safe-functions-1" tabindex="-1"><a class="header-anchor" href="#reference-counting-of-thread-safe-functions-1"><span>Reference Counting of Thread-Safe Functions</span></a></h3><p>在 Node.js 中，当我们谈论线程安全函数（Thread-safe functions）时，我们指的是一类特殊的函数，它们可以安全地从多个线程调用，并且能在 Node.js 的事件循环中正确地执行回调。</p><p>&quot;Reference counting&quot; 是一种资源管理技术，确保只要有任何地方需要使用一个资源（比如一个对象或者内存空间），该资源就不会被销毁。在资源不再被需要时，通过减少引用计数，最终可以释放它。</p><p>对于线程安全函数而言，使用引用计数意味着你可以跟踪有多少活动的异步操作正在使用该函数。每当开始一个新的操作时，增加引用计数；每当操作完成时，减少引用计数。当引用计数降至零时，表示没有任何异步操作正在使用该函数，它可以被安全销毁。</p><h4 id="实际应用例子-3" tabindex="-1"><a class="header-anchor" href="#实际应用例子-3"><span>实际应用例子：</span></a></h4><p>假设你正在开发一个 Node.js 应用程序，需要在后台线程中执行一些 CPU 密集型的图像处理任务。为了不阻塞主事件循环，你决定使用线程安全函数来从不同线程发送处理结果回到 Node.js 的主线程。</p><p>下面是一个简化的示例：</p><ol><li><strong>创建一个线程安全函数</strong>：<br> 你首先创建一个线程安全函数，它可以从其他线程调用，并将处理结果传回主线程。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void CallJs(napi_env env, napi_value js_callback, void* context, void* data) {</span></span>
<span class="line"><span>  // 这里可以调用JavaScript的回调函数，处理从其他线程传回的数据</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建线程安全函数</span></span>
<span class="line"><span>napi_create_threadsafe_function(env, js_callback, async_resource, async_resource_name, 0, 1, nullptr, nullptr, nullptr, CallJs, &amp;tsfn);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段代码中，<code>napi_create_threadsafe_function</code> 就是用来创建线程安全函数的 API 调用，其中 <code>CallJs</code> 是当其他线程准备好数据时将被调用的 C++函数。</p><ol start="2"><li><strong>增加引用计数</strong>：<br> 当你开始一个新的图像处理操作时，你会增加线程安全函数的引用计数。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_acquire_threadsafe_function(tsfn);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="3"><li><strong>在其他线程上处理图像并将结果传回</strong>：<br> 在后台线程中进行图像处理，处理完后使用线程安全函数将结果传回主线程。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void ProcessImageInBackground(std::string imagePath) {</span></span>
<span class="line"><span>  // 执行图像处理...</span></span>
<span class="line"><span>  // 处理完成后，将结果通过线程安全函数发送回主线程</span></span>
<span class="line"><span>  napi_call_threadsafe_function(tsfn, resultData, napi_tsfn_blocking);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>std::thread worker(ProcessImageInBackground, &quot;path/to/image.png&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>减少引用计数</strong>：<br> 当后台任务完成并且结果已经被传递回主线程后，你减少线程安全函数的引用计数。如果减少后计数为零，函数资源将被清理。</li></ol><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_release_threadsafe_function(tsfn, napi_tsfn_release);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="5"><li><strong>在 JavaScript 中接收结果</strong>：<br> 在 Node.js 的 JavaScript 部分，你定义了一个回调函数来接收处理结果。</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> onImageProcessed</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;Image processed:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上步骤演示了一个使用线程安全函数和引用计数机制的简单流程。这样可以确保在异步操作完成前，函数资源不会被错误地销毁。</p><h3 id="deciding-whether-to-keep-the-process-running" tabindex="-1"><a class="header-anchor" href="#deciding-whether-to-keep-the-process-running"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#deciding-whether-to-keep-the-process-running" target="_blank" rel="noopener noreferrer">Deciding whether to keep the process running</a></span></a></h3><p>Node.js 中的 N-API 是一个用于构建本地插件的 API。它允许你用 C 或 C++ 编写与 Node.js 交互的代码，这些代码可以直接调用 JavaScript 引擎提供的功能，并且可以创建或操作 JavaScript 值。</p><p>在使用 N-API 构建本地插件时，有时候需要决定是否让 Node.js 进程继续运行，即使 JavaScript 没有活动任务要执行。例如，如果你的本地插件启动了一个后台线程或者其他异步操作，可能希望保持 Node.js 进程运行直到这些操作完成。</p><p>为了控制这一行为，N-API 提供了两个重要的函数：</p><ol><li><code>napi_ref_threadsafe_function</code></li><li><code>napi_unref_threadsafe_function</code></li></ol><p>通过这些函数，你可以向 Node.js 引擎表明，尽管当前没有 JavaScript 代码在运行，但是后台仍有活动正在进行，因此不应该退出进程。</p><p>下面通过几个例子来说明这些函数的实际使用情况：</p><h3 id="例子-1-启动后台任务" tabindex="-1"><a class="header-anchor" href="#例子-1-启动后台任务"><span>例子 1：启动后台任务</span></a></h3><p>假设你有一个执行长时间计算的 C 函数，你不想阻塞 Node.js 的事件循环。你可能会在本地插件中创建一个线程来处理这个计算。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span>#include `&lt;`stdlib.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个函数将在新线程上执行的长时间计算任务</span></span>
<span class="line"><span>void LongComputationTask(void* data) {</span></span>
<span class="line"><span>    // ... 长时间计算 ...</span></span>
<span class="line"><span>    // 完成后通知 Node.js 主线程</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是暴露给 Node.js 使用的函数</span></span>
<span class="line"><span>napi_value StartLongComputation(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 创建一个线程并开始长时间计算任务</span></span>
<span class="line"><span>    pthread_t thread_id;</span></span>
<span class="line"><span>    pthread_create(&amp;thread_id, NULL, LongComputationTask, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 通知 Node.js 不要退出，即使事件循环为空</span></span>
<span class="line"><span>    napi_ref_threadsafe_function(env, ...);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们没有详细展示如何使用 <code>napi_ref_threadsafe_function</code> 来引用线程安全函数，因为这涉及到更复杂的 N-API 用法，包括创建 <code>napi_threadsafe_function</code> 和正确管理引用计数。</p><h3 id="例子-2-停止后台任务" tabindex="-1"><a class="header-anchor" href="#例子-2-停止后台任务"><span>例子 2：停止后台任务</span></a></h3><p>当后台任务完成时，你需要告诉 Node.js 它可以退出了，如果没有其他任务在运行的话。这是通过 <code>napi_unref_threadsafe_function</code> 来实现的：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 当后台任务完成后被调用</span></span>
<span class="line"><span>void OnTaskComplete(napi_env env, void* data) {</span></span>
<span class="line"><span>    // 告诉 Node.js 它可以退出了</span></span>
<span class="line"><span>    napi_unref_threadsafe_function(env, ...);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，一旦 <code>OnTaskComplete</code> 被调用，就会减少 <code>napi_threadsafe_function</code> 的引用计数。如果没有其他活动阻止 Node.js 退出，那么进程可能会在此之后结束。</p><p>最关键的是理解，通过这些 API，你可以精确地控制 Node.js 进程的生命周期，从而确保不会过早地退出，也不会无必要地挂起。在实际应用中，使用这些功能通常涉及到异步编程和对 Node.js 事件循环的深入理解。</p><h3 id="napi-create-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-create-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_create_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_create_threadsafe_function</a></span></a></h3><p>Node.js 中的 <code>napi_create_threadsafe_function</code> 是一个非常重要的功能，它允许你在原生扩展中安全地调用 JavaScript 函数，即使是在多线程的环境下。理解这个功能之前，先需要了解几个基本概念。</p><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h3><ol><li><strong>N-API</strong>: Node.js 的一个 API 层，允许你使用 C 或者 C++ 编写扩展模块，这些模块可以直接与 Node.js 的 V8 引擎交互。</li><li><strong>Thread-safe</strong>: 当多个线程同时运行代码时，如果每次运行结果和单线程运行结果一致，并且不会引发运行时错误，则认为这段代码是“线程安全”的。</li></ol><p>当你编写一个能够执行异步操作（例如文件读写、网络请求等）的 Node.js 原生扩展时，你可能需要在后台线程中执行一些任务，而完成这些任务后，你又想回到主线程中来更新 JavaScript 环境或调用 JavaScript 函数。在这种情况下，你不能简单地从后台线程直接调用 JavaScript 函数，因为 V8 不是线程安全的。所以你需要使用 <code>napi_create_threadsafe_function</code> 来创建一个可以跨线程安全调用的函数。</p><h3 id="工作机制" tabindex="-1"><a class="header-anchor" href="#工作机制"><span>工作机制</span></a></h3><p><code>napi_create_threadsafe_function</code> 允许你将一个 JavaScript 函数封装成一个可以从任何线程安全调用的 <code>ThreadsafeFunction</code>。内部机制大致如下：</p><ul><li>在主线程中，你调用 <code>napi_create_threadsafe_function</code> 创建一个 <code>ThreadsafeFunction</code>。</li><li>在后台线程中，你通过调用 <code>napi_call_threadsafe_function</code> 来触发这个 JavaScript 函数的执行。</li><li>Node.js 会确保不管在哪个线程调用该函数，最终都会在一个安全的上下文（比如主线程或事件循环的某个阶段）中执行原始的 JavaScript 函数。</li></ul><h3 id="实际例子-11" tabindex="-1"><a class="header-anchor" href="#实际例子-11"><span>实际例子</span></a></h3><p>假设你正在写一个原生模块，需要从一个 C/C++ 的后台线程获取数据然后在 JavaScript 端进行处理。</p><ol><li><strong>首先，在 JavaScript 层面定义一个回调函数</strong>：</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> processData</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 这里的 data 将是从 C/C++ 后台线程传递过来的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;处理数据:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>在原生模块中，创建一个 ThreadsafeFunction</strong>：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设我们有一个 processData 函数指针已经传入</span></span>
<span class="line"><span>napi_value processDataFn;</span></span>
<span class="line"><span>napi_value resourceName;</span></span>
<span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_create_string_utf8(env, &quot;ResourceName&quot;, NAPI_AUTO_LENGTH, &amp;resourceName);</span></span>
<span class="line"><span>napi_create_threadsafe_function(env, processDataFn, NULL, resourceName, 0, 1,</span></span>
<span class="line"><span>                                NULL, NULL, NULL, CallJs, &amp;tsfn);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>在后台线程中，你可以调用 <code>napi_call_threadsafe_function</code> 触发这个函数</strong>：</li></ol><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void* run_thread(void* arg) {</span></span>
<span class="line"><span>  // 模拟产生数据</span></span>
<span class="line"><span>  int data = 100;</span></span>
<span class="line"><span>  napi_call_threadsafe_function(tsfn, &amp;data, napi_tsfn_blocking);</span></span>
<span class="line"><span>  return NULL;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// somewhere in your code to start a new thread</span></span>
<span class="line"><span>pthread_t thread;</span></span>
<span class="line"><span>pthread_create(&amp;thread, NULL, run_thread, NULL);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>最后，清理资源</strong>：</li></ol><p>当你完成所有工作并且不再需要 <code>ThreadsafeFunction</code>，你应该释放它：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_release_threadsafe_function(tsfn, napi_tsfn_release);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以上，是对 <code>napi_create_threadsafe_function</code> 的一个简化的解释和例子。在实际的开发中，你将需要管理更复杂的情况，比如错误处理、正确的资源清理等。但基本原则是：使用 <code>napi_create_threadsafe_function</code> 可以在多线程环境中安全地调用 JavaScript 函数。</p><h3 id="napi-get-threadsafe-function-context" tabindex="-1"><a class="header-anchor" href="#napi-get-threadsafe-function-context"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_get_threadsafe_function_context" target="_blank" rel="noopener noreferrer">napi_get_threadsafe_function_context</a></span></a></h3><p>好的，让我们来聊一聊 Node.js 中的 napi_get_threadsafe_function_context 函数。</p><p>首先，要了解这个 API，你需要知道 N-API 是 Node.js 提供的一个用 C 编写的插件 API，它独立于底层的 JavaScript 运行时（比如 V8）并且是稳定的。也就是说，使用 N-API 编写的原生模块不用担心 Node.js 版本升级导致的兼容性问题。</p><p>再来，Thread-safe function（线程安全函数）是 N-API 中一个特殊概念。在多线程环境中，当你尝试从一个非主线程访问 Node.js 的环境时，通常会出现问题，因为 Node.js 的大部分核心都不是线程安全的。为了在背景工作线程与主事件循环之间安全地传递数据，N-API 提供了线程安全函数。</p><p>现在，当我们谈论<code>napi_get_threadsafe_function_context</code>，我们指的是从已经创建的线程安全函数中检索其上下文。每个线程安全函数都有一个关联的上下文，你在创建它的时候可以指定。这个上下文是个“黑盒子”，可以是任何你想要的数据结构，你可能会在调用该函数时用到这个上下文数据。</p><p>下面我会给你一个例子如何实际应用<code>napi_get_threadsafe_function_context</code>：</p><p>假设你正在编写一个原生 Node.js 模块，这个模块会在后台线程中执行一些耗时操作，然后需要将结果回传给 Node.js 的主线程。在这个场景中，你可能会创建一个线程安全函数，并且带有一些上下文数据，例如操作的类型或者其他状态信息。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 假设这是你的上下文结构体</span></span>
<span class="line"><span>typedef struct {</span></span>
<span class="line"><span>  int operationType;</span></span>
<span class="line"><span>  // ... 可能还有其他状态信息</span></span>
<span class="line"><span>} MyContext;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 创建线程安全函数时的某个回调函数</span></span>
<span class="line"><span>void CallJs(napi_env env, napi_value js_callback, void* context, void* data) {</span></span>
<span class="line"><span>  // 将context转化为你自己的上下文结构体</span></span>
<span class="line"><span>  MyContext* my_context = (MyContext*)context;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 你可以根据my_context中的信息来决定怎么处理data</span></span>
<span class="line"><span>  // 然后你可能会调用js_callback来将结果传递给Node.js的主线程</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 在某个地方你创建了线程安全函数</span></span>
<span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span>napi_create_threadsafe_function(</span></span>
<span class="line"><span>  env,</span></span>
<span class="line"><span>  js_callback, // JavaScript回调函数，将在主线程中被调用</span></span>
<span class="line"><span>  async_resource,</span></span>
<span class="line"><span>  async_resource_name,</span></span>
<span class="line"><span>  0, // 无限队列大小</span></span>
<span class="line"><span>  1, // 初始线程数</span></span>
<span class="line"><span>  my_context, // 这里你传入了上下文信息</span></span>
<span class="line"><span>  finalize_cb, // 当清除线程安全函数时调用的回调</span></span>
<span class="line"><span>  NULL, // finalize_hint</span></span>
<span class="line"><span>  CallJs, // 上面定义的CallJs功能</span></span>
<span class="line"><span>  &amp;tsfn</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ... 现在在你的后台线程中，你可能需要获取上下文做一些处理</span></span>
<span class="line"><span>void BackgroundThreadWork(napi_threadsafe_function tsfn) {</span></span>
<span class="line"><span>  // 从tsfn获得上下文</span></span>
<span class="line"><span>  void* context;</span></span>
<span class="line"><span>  napi_status status = napi_get_threadsafe_function_context(tsfn, &amp;context);</span></span>
<span class="line"><span>  if (status == napi_ok) {</span></span>
<span class="line"><span>    MyContext* my_context = (MyContext*)context;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 现在你拥有了上下文，可以根据上下文中保存的信息进行相应的工作</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...执行你的背景工作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 完成后，你可能想要调用线程安全函数来通知Node.js的主线程</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码展示了如何创建一个带有上下文的线程安全函数，并在后台线程中使用<code>napi_get_threadsafe_function_context</code>来获取这个上下文。这样，你就可以在多线程环境中安全地与 Node.js 的主线程进行通信了。</p><h3 id="napi-call-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-call-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_call_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_call_threadsafe_function</a></span></a></h3><p>Node.js 中的<code>napi_call_threadsafe_function</code>是一个函数，用于在 N-API（Node.js 的原生 API）中安全地从任何线程调用 JavaScript 函数。这个功能主要用于当你有一个原生插件（通常用 C 或者 C++写的模块）需要执行异步操作或者从不同的线程调用 Node.js 代码时。</p><p>首先，让我们理解什么是线程安全。当多个线程尝试同时访问相同的资源时，如果没有适当的同步机制，就可能会发生冲突和不可预知的行为。因此，线程安全是指代码可以被多个线程安全地调用，而不会产生竞争条件或其他问题。</p><p>在 Node.js 中，JavaScript 运行在单一的线程上，称为事件循环线程。但是，当你使用原生模块和异步 I/O 操作时，可能会涉及额外的线程。这时候如果你想要从这些附加线程安全地调用 JavaScript 函数，就需要用到<code>napi_call_threadsafe_function</code>。</p><p>下面是一个简化的例子，展示了如何使用<code>napi_call_threadsafe_function</code>：</p><p>假设你正在编写一个 Node.js 扩展，该扩展通过原生代码连接到某个服务，并且需要在接收到数据时回调 JavaScript 函数。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是从服务收到数据时要调用的JavaScript回调函数</span></span>
<span class="line"><span>napi_value js_callback;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这个结构体用来存储线程安全函数相关信息</span></span>
<span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 从其他线程调用这个函数以触发JavaScript回调</span></span>
<span class="line"><span>void service_callback(void* data) {</span></span>
<span class="line"><span>    // `data`是你从服务接收到的数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用JavaScript回调函数，确保它是线程安全的</span></span>
<span class="line"><span>    napi_status status = napi_call_threadsafe_function(tsfn, data, napi_tsfn_blocking);</span></span>
<span class="line"><span>    if (status != napi_ok) {</span></span>
<span class="line"><span>        // 处理错误...</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是创建线程安全函数并启动服务监听器的初始化代码</span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>    // ...初始化代码...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取JavaScript提供的回调函数，并保存引用</span></span>
<span class="line"><span>    napi_value js_callback;</span></span>
<span class="line"><span>    // 假设js_callback已经被正确获取并赋值...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 创建线程安全函数</span></span>
<span class="line"><span>    napi_create_threadsafe_function(env, js_callback, NULL, NAPI_AUTO_LENGTH, 0, 1, NULL, NULL, NULL, service_callback, &amp;tsfn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 启动服务监听器...</span></span>
<span class="line"><span>    // 当服务有数据时，service_callback将被调用</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 注册模块</span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，<code>napi_threadsafe_function</code>类型的变量<code>tsfn</code>被用来存储线程安全函数的信息。通过调用<code>napi_create_threadsafe_function</code>创建一个线程安全的函数，然后可以从任何线程通过<code>napi_call_threadsafe_function</code>调用该 JavaScript 函数。</p><p>注意：以上代码只是概念性的示例，实际使用时还需要考虑错误处理、资源释放和线程同步等问题。</p><p>重要的点是，当你从非事件循环线程调用 JavaScript 代码时，必须采取线程安全的措施，否则可能会破坏 Node.js 的单线程模型，导致不可预期的结果。<code>napi_call_threadsafe_function</code>正是提供了一种安全的方式来完成这样的任务。</p><h3 id="napi-acquire-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-acquire-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_acquire_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_acquire_threadsafe_function</a></span></a></h3><p>Node.js 的 N-API（原生 API）提供了一套在 Node.js 中使用 C 或 C++编写扩展的接口。这些接口允许本地代码安全地与 Node.js 的 JavaScript 运行时和对象进行交互。</p><p><code>napi_acquire_threadsafe_function</code> 是 N-API 中的一个函数，它用于多线程环境中安全地调用 JavaScript 函数。因为 Node.js 是单线程运行 JavaScript 的，在多线程 C/C++扩展中直接调用 JavaScript 代码通常是不安全的。所以这个 API 函数可以帮助我们从其他线程安全地调用 JavaScript 代码。</p><p>下面我将简要解释 <code>napi_acquire_threadsafe_function</code> 的用法，并给出一些实际例子来说明它的运用场景。</p><h3 id="解释" tabindex="-1"><a class="header-anchor" href="#解释"><span>解释</span></a></h3><p><code>napi_acquire_threadsafe_function</code> 用于“获取”一个线程安全函数，使得其他线程可以安全地调用这个函数。获取操作通常会增加内部引用计数，这样就可以确保在所有线程完成对该函数的使用前，函数不会被垃圾回收。</p><p>当你想在原生线程中调用一个 JavaScript 函数时，你首先需要通过 <code>napi_create_threadsafe_function</code> 创建一个线程安全函数，然后在每个线程开始调用之前使用 <code>napi_acquire_threadsafe_function</code>，并在调用结束后使用 <code>napi_release_threadsafe_function</code> 来释放它。</p><h3 id="使用步骤-1" tabindex="-1"><a class="header-anchor" href="#使用步骤-1"><span>使用步骤</span></a></h3><ol><li><strong>创建线程安全函数</strong>：使用 <code>napi_create_threadsafe_function</code> 创建一个可从任何线程调用的 JavaScript 函数。</li><li><strong>获取线程安全函数</strong>：在准备调用该函数的线程中，使用 <code>napi_acquire_threadsafe_function</code> 来获取权利调用它。</li><li><strong>调用函数</strong>：通过 <code>napi_call_threadsafe_function</code> 在任何线程里面调用这个函数。</li><li><strong>释放线程安全函数</strong>：调用完成后，使用 <code>napi_release_threadsafe_function</code> 释放你之前获得的权利。</li></ol><h3 id="实际运用的例子-10" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-10"><span>实际运用的例子</span></a></h3><p>假设您正在编写一个 Node.js 扩展，该扩展需要执行一些耗时的计算，而这个计算过程是在原生的 C/C++线程中完成的。你希望在计算完成后，能够安全地更新 Node.js 的某个 JavaScript 对象或调用某个 JavaScript 函数。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 假设这是您想在JavaScript中调用的函数</span></span>
<span class="line"><span>void JSFunctionCall(napi_env env, napi_value js_callback, void* context) {</span></span>
<span class="line"><span>    // ... 这里可能是调用 JavaScript 函数的代码 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 原生线程的工作函数</span></span>
<span class="line"><span>void* NativeThreadWork(void* arg) {</span></span>
<span class="line"><span>    napi_threadsafe_function ts_fn = (napi_threadsafe_function)arg;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 获取权限</span></span>
<span class="line"><span>    napi_acquire_threadsafe_function(ts_fn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 执行一些工作...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 调用JavaScript函数</span></span>
<span class="line"><span>    napi_call_threadsafe_function(ts_fn, nullptr, napi_tsfn_blocking);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 释放权限</span></span>
<span class="line"><span>    napi_release_threadsafe_function(ts_fn, napi_tsfn_release);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return nullptr;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述伪代码示例中，我们首先在主线程中创建了一个线程安全函数 <code>ts_fn</code>，然后传递给了原生线程 <code>NativeThreadWork</code>。在原生线程中，我们通过 <code>napi_acquire_threadsafe_function</code> 获取了调用 JavaScript 函数的权限，并在完成调用后通过 <code>napi_release_threadsafe_function</code> 释放了该权限。这样就可以确保在多线程环境下，我们的 JavaScript 函数调用是安全的。</p><p>总结来说，<code>napi_acquire_threadsafe_function</code> 是一个关键的函数，它在 Node.js 的 N-API 中使得多线程原生扩展能够安全地与 JavaScript 代码交互。通过使用它，开发者可以确保即使在多线程的情况下，也能安全地调用 JavaScript 函数，而不会导致竞态条件或崩溃等问题。</p><h3 id="napi-release-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-release-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_release_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_release_threadsafe_function</a></span></a></h3><p>在 Node.js 中，N-API 是一种用于构建原生插件的 API。它允许你使用 C 或 C++等语言编写可以被 Node.js 直接调用的代码块。这些原生插件通常用于执行性能敏感的任务，例如图像处理、数据库访问或其他需要高性能计算的操作。</p><p><code>napi_release_threadsafe_function</code> 是 N-API 中的一个函数，用于管理所谓的“线程安全函数”（thread-safe function）。这个概念可能对于初学者来说有些复杂，所以我会尽量用简单的例子来解释。</p><p>在 JavaScript 中，通常我们只在一个主线程上运行代码，而 Node.js 也是基于这样的事件驱动和非阻塞 I/O 模型。然而，在某些情况下，你可能需要在后台线程上执行一些任务，以避免阻塞主线程。比如当你在处理大量数据计算时，你不希望它影响到其他服务器请求的处理。</p><p>在这些后台线程上完成工作后，你可能需要将一些结果传回给主线程。这就是线程安全函数的用途：它允许从任何线程安全地调用 JavaScript 函数。</p><p>现在，假设你建立了一个线程安全函数，你的后台线程正在使用它来定期将数据发送回主线程。当你的应用程序结束或者你不再需要这个线程安全函数时，你必须告诉 Node.js，它可以清理与该函数相关的资源。这正是<code>napi_release_threadsafe_function</code>的作用。调用这个函数会减少线程安全函数的引用计数，当引用计数降到零时，Node.js 就会释放它占用的资源。</p><p>实际应用的例子：</p><ol><li><p><strong>异步日志记录</strong>：你可能想要在后台线程上进行日志记录，以免影响主线程的性能。每当后台线程需要记录信息时，它可以通过线程安全函数来完成。完成日志记录任务后，使用<code>napi_release_threadsafe_function</code>来释放资源。</p></li><li><p><strong>数据处理</strong>：如果你的应用程序接收到大量的数据需要处理，比如处理图像或分析文件，你可以在后台线程中处理这些数据，然后通过线程安全函数发送处理结果回主线程。最后，用<code>napi_release_threadsafe_function</code>来告知 Node.js 该线程安全函数不再需要。</p></li><li><p><strong>实时数据更新</strong>：考虑一个股票市场应用程序，你可能在后台线程中实时获取股价并更新数据库。同时，你可能还需要及时将更新推送给前端显示。线程安全函数可以用于将这些更新发送回主线程，以便进一步处理。当这个功能不再需要时，再次调用<code>napi_release_threadsafe_function</code>。</p></li></ol><p>在使用<code>napi_release_threadsafe_function</code>时，你需要考虑同步问题，确保没有其他线程试图在你释放资源后还使用该函数。正确地管理线程安全函数的创建和释放是开发稳定原生插件的重要方面。</p><h3 id="napi-ref-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-ref-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_ref_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_ref_threadsafe_function</a></span></a></h3><p>Node.js 中的 N-API（原生 API）是一个用于构建原生插件（通常是用 C 或 C++编写的模块）的底层 API。它提供了一组稳定的函数，允许原生代码与 JavaScript 代码交互。</p><p>在这个上下文中，<code>napi_ref_threadsafe_function</code> 是一个非常特殊的函数，它涉及到多线程和异步编程。我将首先解释什么是 threadsafe function，然后举例说明它如何被使用。</p><h3 id="什么是-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#什么是-threadsafe-function"><span>什么是 Threadsafe Function？</span></a></h3><p>在 Node.js 中，由于 JavaScript 运行在单线程环境中（主要是事件循环），所以在处理长时间运行的任务时通常会使用异步操作来避免阻塞该线程。但是，在某些情况下，你可能需要从一个不同的线程（可能是一个原生扩展创建的线程）中执行代码，并最终要将结果传递回 JavaScript 的主线程。为此，Node.js 提供了 <code>ThreadsafeFunction</code> 类型的对象，即可以安全地从任何线程调用的函数。</p><h3 id="napi-ref-threadsafe-function-功能" tabindex="-1"><a class="header-anchor" href="#napi-ref-threadsafe-function-功能"><span><code>napi_ref_threadsafe_function</code> 功能</span></a></h3><p><code>napi_ref_threadsafe_function</code> 函数的作用是增加对已存在的 <code>ThreadsafeFunction</code> 对象的引用计数。当你创建一个 threadsafe function 时，它的引用计数默认为 1。每次调用 <code>napi_ref_threadsafe_function</code>，引用计数会增加。这样做是为了防止该函数对象被垃圾回收机制回收，只有当引用计数降到 0 时，垃圾回收器才会考虑回收该对象。</p><h3 id="为什么需要引用-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#为什么需要引用-threadsafe-function"><span>为什么需要引用 threadsafe function？</span></a></h3><p>当你的程序创建了一个 threadsafe function 并且在多个地方使用时，你需要确保当它仍被需要时不会被回收。通过增加引用计数，你可以控制对象生命周期，并确保只有在所有地方都完成使用后，对象才能被清除。</p><h3 id="实际运用的例子-11" tabindex="-1"><a class="header-anchor" href="#实际运用的例子-11"><span>实际运用的例子</span></a></h3><p>想象你正在编写一个 Node.js 应用程序，这个应用程序需要执行 CPU 密集型的图像处理操作。为了不阻塞事件循环，你决定使用 C++编写一个原生模块来在背景线程进行图像处理。当处理完成时，你需要将处理结果返回到 JavaScript 主线程中更新 UI 或进一步处理。</p><p>以下是一个简化的示例流程：</p><ol><li>在 JavaScript 代码中，你引入了自己的原生模块并创建了一个 threadsafe function。</li><li>你把这个 threadsafe function 传递给原生模块。</li><li>原生模块开始在另一个线程上处理图像。</li><li>处理完毕后，原生模块使用 threadsafe function 将结果传回 JavaScript 主线程。</li><li>为确保 threadsafe function 在完成工作前不被回收，原生模块在开始工作前调用了 <code>napi_ref_threadsafe_function</code> 来增加引用计数。</li><li>当结果返回给 JavaScript 测并且不再需要 threadsafe function 时，原生模块调用 <code>napi_unref_threadsafe_function</code> 来减少引用计数。</li></ol><p>通过这种方式，你就能够安全地在多个线程间传递信息而不会破坏 Node.js 的单线程模型，并且不必担心对象在使用过程中被意外回收。</p><h3 id="napi-unref-threadsafe-function" tabindex="-1"><a class="header-anchor" href="#napi-unref-threadsafe-function"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#napi_unref_threadsafe_function" target="_blank" rel="noopener noreferrer">napi_unref_threadsafe_function</a></span></a></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，它允许你在服务器端运行 JavaScript 代码。N-API 是 Node.js 提供的一组 C 语言 API，它使得创建原生插件变得简单，而且保证了与 Node.js 不同版本的兼容性。</p><p><code>napi_unref_threadsafe_function</code> 是 N-API 中的一个函数，它用于管理一个叫做「线程安全函数」（thread-safe function）的引用计数。在解释这个函数之前，先说明几个背景知识点：</p><ol><li><p><strong>线程安全函数</strong>: 在 Node.js 中，JavaScript 通常在单一的主线程上运行，这样避免了多线程编程中的复杂性。但是，当需要执行耗时的操作时（例如文件读写、网络请求），可以使用其他线程来避免阻塞主线程。线程安全函数就是为了在这些工作线程和主线程之间安全地传递调用而设计的。</p></li><li><p><strong>引用计数</strong>: 引用计数是一种内存管理技术，用于跟踪一个对象被引用的次数。当一个对象的引用计数降到零时，意味着没有任何地方正在使用这个对象，因此它可以被垃圾回收。</p></li></ol><p>现在让我们来看看 <code>napi_unref_threadsafe_function</code> 本身：</p><ul><li><p><strong>作用</strong>：<code>napi_unref_threadsafe_function</code> 函数用于减少线程安全函数的引用计数。当一个线程不再需要调用该线程安全函数时，应该调用这个函数。</p></li><li><p><strong>为什么要减少引用计数</strong>：如果你创建了一个线程安全函数，但是永远不去减少它的引用计数，即使你的代码不再需要它，它也不会被垃圾回收。这可能会导致内存泄漏。</p></li><li><p><strong>如何使用</strong>：只有当你之前通过 <code>napi_ref_threadsafe_function</code> 增加了引用计数时，才需要调用 <code>napi_unref_threadsafe_function</code> 来减少引用计数。</p></li></ul><p><strong>实际运用的例子</strong>：</p><p>假设你有一个 Node.js 插件，该插件启动了一个新的线程来处理数据，处理完后需要将结果传回给 JavaScript 的主线程。你可以创建一个线程安全函数来做到这一点。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 线程安全函数的句柄</span></span>
<span class="line"><span>napi_threadsafe_function tsfn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 这是在工作线程中调用的函数</span></span>
<span class="line"><span>void worker_thread_function(void* data) {</span></span>
<span class="line"><span>    // ... 执行一些操作 ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 通知 Node.js 主线程执行回调</span></span>
<span class="line"><span>    napi_call_threadsafe_function(tsfn, data, napi_tsfn_blocking);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void some_init_function(napi_env env) {</span></span>
<span class="line"><span>    // 创建一个线程安全函数</span></span>
<span class="line"><span>    napi_create_threadsafe_function(</span></span>
<span class="line"><span>        env,</span></span>
<span class="line"><span>        ...,</span></span>
<span class="line"><span>        &amp;tsfn</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 增加引用计数，因为我们打算在工作线程中使用它</span></span>
<span class="line"><span>    napi_ref_threadsafe_function(env, tsfn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // ... 启动工作线程 ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void some_cleanup_function(napi_env env) {</span></span>
<span class="line"><span>    // 减少引用计数，因为我们不再需要在工作线程中使用它</span></span>
<span class="line"><span>    napi_unref_threadsafe_function(env, tsfn);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 释放线程安全函数</span></span>
<span class="line"><span>    napi_release_threadsafe_function(tsfn, napi_tsfn_release);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段展示了如何在一个原生模块中创建并使用线程安全函数。注意，在 <code>some_cleanup_function</code> 函数中，我们调用了 <code>napi_unref_threadsafe_function</code> 来减少由 <code>napi_ref_threadsafe_function</code> 增加的引用计数。这样确保了当这个线程安全函数不再需要时，它能够被正确地清理和垃圾回收。</p><h2 id="miscellaneous-utilities" tabindex="-1"><a class="header-anchor" href="#miscellaneous-utilities"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#miscellaneous-utilities" target="_blank" rel="noopener noreferrer">Miscellaneous utilities</a></span></a></h2><p>在 Node.js 中，<code>Miscellaneous utilities</code>通常指的是一系列的辅助函数或工具，它们可以帮助开发者完成不同的任务。在 N-API（即 Node-API）的上下文中，<code>Miscellaneous utilities</code>指的是那些和直接 API 功能不太相关，但仍然很有用的一些函数。</p><p>由于你提到的是 Node.js v21.7.1 中的内容，我们将聚焦于 N-API 中的<code>Miscellaneous utilities</code>。N-API 是一个 C 语言写的 API，它对原生插件（native addons）作者来说是稳定的，并且兼容不同版本的 Node.js。原生插件是使用 C 或 C++编写的模块，可以直接调用底层系统 API，这在性能上有一定的优势，因为它们运行在更低级别，更靠近硬件。</p><p>在<code>Miscellaneous utilities</code>部分，我们可能会看到以下几种类型的工具：</p><ol><li><p><strong>类型检查工具</strong> - 这包括了函数，比如<code>napi_is_array()</code>，它可以让你检查 JavaScript 值是否是一个数组。</p></li><li><p><strong>错误处理工具</strong> - 如<code>napi_throw_error()</code>，它用于生成并抛出一个 JavaScript 错误。</p></li><li><p><strong>引用管理工具</strong> - 比如<code>napi_ref</code>和<code>napi_unref</code>，它们用于管理对 JavaScript 对象的引用，在原生代码中保持对象活动状态，防止被垃圾回收器回收。</p></li><li><p><strong>线程安全功能</strong> - 比如<code>napi_acquire_threadsafe_function()</code>和<code>napi_release_threadsafe_function()</code>，它们用于在多线程环境下安全地调用 JavaScript 函数。</p></li></ol><p>实际应用的例子：</p><p><strong>类型检查</strong>:<br> 假设你正在编写一个原生模块，需要验证传入的参数是否为数组：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value my_function(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    size_t argc = 1;</span></span>
<span class="line"><span>    napi_value argv[1];</span></span>
<span class="line"><span>    napi_get_cb_info(env, info, &amp;argc, argv, NULL, NULL);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    napi_valuetype valuetype;</span></span>
<span class="line"><span>    napi_typeof(env, argv[0], &amp;valuetype);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (valuetype != napi_object) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Argument is not an object&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    bool is_array;</span></span>
<span class="line"><span>    napi_is_array(env, argv[0], &amp;is_array);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (!is_array) {</span></span>
<span class="line"><span>        napi_throw_type_error(env, NULL, &quot;Object is not an array&quot;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 继续处理数组...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>错误处理</strong>:<br> 如果你在原生模块的某个操作中遇到了错误，你可能想要抛出一个错误给 JavaScript:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_value my_function_that_may_fail(napi_env env, napi_callback_info info) {</span></span>
<span class="line"><span>    // 假设do_something_risky是一个可能失败的操作</span></span>
<span class="line"><span>    bool success = do_something_risky();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (!success) {</span></span>
<span class="line"><span>        napi_throw_error(env, NULL, &quot;Something risky failed!&quot;);</span></span>
<span class="line"><span>        return NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果成功，则继续执行...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>引用管理</strong>:<br> 当你需要在原生模块中存储一个 JavaScript 对象，并确保它不会在原生代码还在使用它时被垃圾收集器回收时，你可以使用引用管理:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>napi_ref my_ref;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void store_js_object(napi_env env, napi_value obj) {</span></span>
<span class="line"><span>    napi_create_reference(env, obj, 1, &amp;my_ref);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void use_stored_js_object(napi_env env) {</span></span>
<span class="line"><span>    napi_value obj;</span></span>
<span class="line"><span>    napi_get_reference_value(env, my_ref, &amp;obj);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 使用这个对象...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void cleanup(napi_env env) {</span></span>
<span class="line"><span>    napi_delete_reference(env, my_ref);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 Node.js 中 N-API <code>Miscellaneous utilities</code>的概览和一些简单的应用示例。这些工具为原生模块的开发提供了必要的辅助功能，使得与 JavaScript 交互更加安全和有效率。</p><h3 id="node-api-get-module-file-name" tabindex="-1"><a class="header-anchor" href="#node-api-get-module-file-name"><span><a href="https://nodejs.org/docs/latest/api/n-api.html#node_api_get_module_file_name" target="_blank" rel="noopener noreferrer">node_api_get_module_file_name</a></span></a></h3><p>Node.js 中的 <code>node_api_get_module_file_name</code> 是 N-API 的一部分，N-API 是一个用来构建原生插件的 API。换句话说，如果你想要在 Node.js 中使用 C 或 C++ 写一些代码来提升性能或者访问操作系统底层功能，那么这个 API 就是为此而设计的。</p><h3 id="什么是-node-api-get-module-file-name" tabindex="-1"><a class="header-anchor" href="#什么是-node-api-get-module-file-name"><span>什么是 <code>node_api_get_module_file_name</code>?</span></a></h3><p><code>node_api_get_module_file_name</code> 是一个函数，它的作用是帮助你获取当前正在执行的原生模块的文件名。原生模块是用 C 或 C++ 编写的，并且被编译成 <code>.node</code> 文件，通过 Node.js 加载和运行的。</p><h3 id="如何使用它" tabindex="-1"><a class="header-anchor" href="#如何使用它"><span>如何使用它？</span></a></h3><p>这个函数需要在 C 或 C++ 的代码中使用，通常在一个称为“初始化函数”的地方。初始化函数是当 Node.js 加载原生模块时会调用的。在初始化函数内，你可以调用 <code>node_api_get_module_file_name</code> 来获取包含该模块的完整路径。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value Init(napi_env env, napi_value exports) {</span></span>
<span class="line"><span>  // 获取模块文件名</span></span>
<span class="line"><span>  const char* module_file_name;</span></span>
<span class="line"><span>  napi_status status = node_api_get_module_file_name(env, &amp;module_file_name);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 现在 module_file_name 包含了模块的完整文件路径</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return exports;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的例子中，<code>Init</code> 函数就是我们提到的初始化函数。当 Node.js 加载原生模块时，它会调用这个函数。在这个函数里，我们使用 <code>node_api_get_module_file_name</code> 来获取模块的文件名。</p><h3 id="实际应用例子-4" tabindex="-1"><a class="header-anchor" href="#实际应用例子-4"><span>实际应用例子</span></a></h3><p>让我们来看一个实际的场景，假设你正在编写一个 Node.js 原生模块，该模块需要读取自身的源码或者相关数据文件。</p><p>例如，你可以有如下的 C++ 代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include `&lt;`fstream&gt;</span></span>
<span class="line"><span>#include `&lt;`string&gt;</span></span>
<span class="line"><span>##include `&lt;`node_api.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>napi_value ReadOwnSource(napi_env env, napi_callback_info args) {</span></span>
<span class="line"><span>  const char* module_file_name;</span></span>
<span class="line"><span>  napi_status status = node_api_get_module_file_name(env, &amp;module_file_name);</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 打开模块文件进行读取</span></span>
<span class="line"><span>  std::ifstream file(module_file_name);</span></span>
<span class="line"><span>  std::string file_contents((std::istreambuf_iterator`&lt;`char&gt;(file)),</span></span>
<span class="line"><span>                             std::istreambuf_iterator`&lt;`char&gt;());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // 转换为 JavaScript 字符串返回给 JS</span></span>
<span class="line"><span>  napi_value result;</span></span>
<span class="line"><span>  status = napi_create_string_utf8(</span></span>
<span class="line"><span>    env,</span></span>
<span class="line"><span>    file_contents.c_str(),</span></span>
<span class="line"><span>    file_contents.length(),</span></span>
<span class="line"><span>    &amp;result</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span>  if (status != napi_ok) {</span></span>
<span class="line"><span>    // 处理错误...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return result;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 还需要注册函数等操作...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上的 C++ 代码定义了一个函数 <code>ReadOwnSource</code>，这个函数使用 <code>node_api_get_module_file_name</code> 来获取当前模块的文件名，然后打开这个文件并读取内容，最后把内容作为字符串返回给 Node.js 端。</p><p>这只是一个简化的例子，实际使用中，你可能还需要处理各种错误情况以及安全问题，但它展示了如何使用 <code>node_api_get_module_file_name</code> 函数以及它的实际用途。</p></div><!----><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/document/node-doc/Net.html" aria-label="Net"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Net</div></a><a class="route-link auto-link next" href="/document/node-doc/OS.html" aria-label="OS"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">OS<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2022-present hanekawa-shiki</div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script src="/assets/js/runtime~app.2cf91084.js" defer></script><script src="/assets/js/7531.f2f134c8.js" defer></script><script src="/assets/js/app.a2d0f323.js" defer></script>
  </body>
</html>
